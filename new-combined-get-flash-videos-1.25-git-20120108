#!/usr/bin/env perl
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
#
# get_flash_videos -- download all the Flash videos off a web page
#
#   http://code.google.com/p/get-flash-videos/
#
# Copyright 2009, zakflash and MonsieurVideo
#
# This file includes various perl modules, see their original source for their
# copyright and license terms.

BEGIN { $INC{'HTTP/Cookies.pm'}++; }
BEGIN { $INC{'HTTP/Date.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTTP/Date.pm
{
package HTTP::Date;

$VERSION = "5.831";

require 5.004;
require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(time2str str2time);
@EXPORT_OK = qw(parse_date time2iso time2isoz);

use strict;
require Time::Local;

use vars qw(@DoW @MoY %MoY);
@DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
@MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
@MoY{@MoY} = (1..12);

my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);


sub time2str (;$)
{
    my $time = shift;
    $time = time unless defined $time;
    my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
    sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
	    $DoW[$wday],
	    $mday, $MoY[$mon], $year+1900,
	    $hour, $min, $sec);
}


sub str2time ($;$)
{
    my $str = shift;
    return undef unless defined $str;

    if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
	return eval {
	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
	    $t < 0 ? undef : $t;
	};
    }

    my @d = parse_date($str);
    return undef unless @d;
    $d[1]--;        # month

    my $tz = pop(@d);
    unless (defined $tz) {
	unless (defined($tz = shift)) {
	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
			  my $t = Time::Local::timelocal(reverse @d) + $frac;
			  $t < 0 ? undef : $t;
		        };
	}
    }

    my $offset = 0;
    if ($GMT_ZONE{uc $tz}) {
    }
    elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
	$offset = 3600 * $2;
	$offset += 60 * $3 if $3;
	$offset *= -1 if $1 && $1 eq '-';
    }
    else {
	eval { require Time::Zone } || return undef;
	$offset = Time::Zone::tz_offset($tz);
	return undef unless defined $offset;
    }

    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
		  my $t = Time::Local::timegm(reverse @d) + $frac;
		  $t < 0 ? undef : $t - $offset;
		};
}


sub parse_date ($)
{
    local($_) = shift;
    return unless defined;

    s/^\s+//;  # kill leading space
    s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday

    my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);

    (($day,$mon,$yr,$hr,$min,$sec,$tz) =
        /^
	 (\d\d?)               # day
	    (?:\s+|[-\/])
	 (\w+)                 # month
	    (?:\s+|[-\/])
	 (\d+)                 # year
	 (?:
	       (?:\s+|:)       # separator before clock
	    (\d\d?):(\d\d)     # hour:min
	    (?::(\d\d))?       # optional seconds
	 )?                    # optional clock
	    \s*
	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
	    \s*
	 (?:\(\w+\))?	       # ASCII representation of timezone in parens.
	    \s*$
	/x)

    ||

    (($mon, $day, $hr, $min, $sec, $tz, $yr) =
	/^
	 (\w{1,3})             # month
	    \s+
	 (\d\d?)               # day
	    \s+
	 (\d\d?):(\d\d)        # hour:min
	 (?::(\d\d))?          # optional seconds
	    \s+
	 (?:([A-Za-z]+)\s+)?   # optional timezone
	 (\d+)                 # year
	    \s*$               # allow trailing whitespace
	/x)

    ||

    (($mon, $day, $yr, $hr, $min, $sec) =
	/^
	 (\w{3})               # month
	    \s+
	 (\d\d?)               # day
	    \s+
	 (?:
	    (\d\d\d\d) |       # year
	    (\d{1,2}):(\d{2})  # hour:min
            (?::(\d\d))?       # optional seconds
	 )
	 \s*$
       /x)

    ||

    (($yr, $mon, $day, $hr, $min, $sec, $tz) =
	/^
	  (\d{4})              # year
	     [-\/]?
	  (\d\d?)              # numerical month
	     [-\/]?
	  (\d\d?)              # day
	 (?:
	       (?:\s+|[-:Tt])  # separator before clock
	    (\d\d?):?(\d\d)    # hour:min
	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
	 )?                    # optional clock
	    \s*
	 ([-+]?\d\d?:?(:?\d\d)?
	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
	    \s*$
	/x)

    ||

    (($mon, $day, $yr, $hr, $min, $ampm) =
        /^
          (\d{2})                # numerical month
             -
          (\d{2})                # day
             -
          (\d{2})                # year
             \s+
          (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
             \s*$
        /x)

    ||
    return;  # unrecognized format

    $mon = $MoY{$mon} ||
           $MoY{"\u\L$mon"} ||
	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
           return;

    unless (defined $yr) {
	my $cur_mon;
	($cur_mon, $yr) = (localtime)[4, 5];
	$yr += 1900;
	$cur_mon++;
	$yr-- if $mon > $cur_mon;
    }
    elsif (length($yr) < 3) {
	my $cur_yr = (localtime)[5] + 1900;
	my $m = $cur_yr % 100;
	my $tmp = $yr;
	$yr += $cur_yr - $m;
	$m -= $tmp;
	$yr += ($m > 0) ? 100 : -100
	    if abs($m) > 50;
    }

    $hr  = 0 unless defined($hr);
    $min = 0 unless defined($min);
    $sec = 0 unless defined($sec);

    if ($ampm) {
	$ampm = uc $ampm;
	$hr = 0 if $hr == 12 && $ampm eq 'AM';
	$hr += 12 if $ampm eq 'PM' && $hr != 12;
    }

    return($yr, $mon, $day, $hr, $min, $sec, $tz)
	if wantarray;

    if (defined $tz) {
	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
    }
    else {
	$tz = "";
    }
    return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
		   $yr, $mon, $day, $hr, $min, $sec, $tz);
}


sub time2iso (;$)
{
    my $time = shift;
    $time = time unless defined $time;
    my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
    sprintf("%04d-%02d-%02d %02d:%02d:%02d",
	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
}


sub time2isoz (;$)
{
    my $time = shift;
    $time = time unless defined $time;
    my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
    sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
            $year+1900, $mon+1, $mday, $hour, $min, $sec);
}

1;


}
##} /usr/local/libdata/perl5/site_perl/HTTP/Date.pm
BEGIN { $INC{'HTTP/Headers/Util.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTTP/Headers/Util.pm
{
package HTTP::Headers::Util;

use strict;
use vars qw($VERSION @ISA @EXPORT_OK);

$VERSION = "5.817";

require Exporter;
@ISA=qw(Exporter);

@EXPORT_OK=qw(split_header_words _split_header_words join_header_words);



sub split_header_words {
    my @res = &_split_header_words;
    for my $arr (@res) {
	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
	    $arr->[$i] = lc($arr->[$i]);
	}
    }
    return @res;
}

sub _split_header_words
{
    my(@val) = @_;
    my @res;
    for (@val) {
	my @cur;
	while (length) {
	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
		push(@cur, $1);
		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
		    my $val = $1;
		    $val =~ s/\\(.)/$1/g;
		    push(@cur, $val);
		}
		elsif (s/^\s*=\s*([^;,\s]*)//) {
		    my $val = $1;
		    $val =~ s/\s+$//;
		    push(@cur, $val);
		}
		else {
		    push(@cur, undef);
		}
	    }
	    elsif (s/^\s*,//) {
		push(@res, [@cur]) if @cur;
		@cur = ();
	    }
	    elsif (s/^\s*;// || s/^\s+//) {
	    }
	    else {
		die "This should not happen: '$_'";
	    }
	}
	push(@res, \@cur) if @cur;
    }
    @res;
}


sub join_header_words
{
    @_ = ([@_]) if @_ && !ref($_[0]);
    my @res;
    for (@_) {
	my @cur = @$_;
	my @attr;
	while (@cur) {
	    my $k = shift @cur;
	    my $v = shift @cur;
	    if (defined $v) {
		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
		    $k .= qq(="$v");
		}
		else {
		    $k .= "=$v";
		}
	    }
	    push(@attr, $k);
	}
	push(@res, join("; ", @attr)) if @attr;
    }
    join(", ", @res);
}


1;

}
##} /usr/local/libdata/perl5/site_perl/HTTP/Headers/Util.pm
BEGIN { $INC{'HTTP/Cookies/Netscape.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTTP/Cookies/Netscape.pm
{
package HTTP::Cookies::Netscape;

use strict;
use vars qw(@ISA $VERSION);

$VERSION = "5.832";

@ISA=qw(HTTP::Cookies);

sub load
{
    my($self, $file) = @_;
    $file ||= $self->{'file'} || return;
    local(*FILE, $_);
    local $/ = "\n";  # make sure we got standard record separator
    my @cookies;
    open(FILE, $file) || return;
    my $magic = <FILE>;
    unless ($magic =~ /^\#(?: Netscape)? HTTP Cookie File/) {
	warn "$file does not look like a netscape cookies file" if $^W;
	close(FILE);
	return;
    }
    my $now = time() - $HTTP::Cookies::EPOCH_OFFSET;
    while (<FILE>) {
	next if /^\s*\#/;
	next if /^\s*$/;
	tr/\n\r//d;
	my($domain,$bool1,$path,$secure, $expires,$key,$val) = split(/\t/, $_);
	$secure = ($secure eq "TRUE");
	$self->set_cookie(undef,$key,$val,$path,$domain,undef,
			  0,$secure,$expires-$now, 0);
    }
    close(FILE);
    1;
}

sub save
{
    my($self, $file) = @_;
    $file ||= $self->{'file'} || return;
    local(*FILE, $_);
    open(FILE, ">$file") || return;

    print FILE <<EOT;

EOT

    my $now = time - $HTTP::Cookies::EPOCH_OFFSET;
    $self->scan(sub {
	my($version,$key,$val,$path,$domain,$port,
	   $path_spec,$secure,$expires,$discard,$rest) = @_;
	return if $discard && !$self->{ignore_discard};
	$expires = $expires ? $expires - $HTTP::Cookies::EPOCH_OFFSET : 0;
	return if $now > $expires;
	$secure = $secure ? "TRUE" : "FALSE";
	my $bool = $domain =~ /^\./ ? "TRUE" : "FALSE";
	print FILE join("\t", $domain, $bool, $path, $secure, $expires, $key, $val), "\n";
    });
    close(FILE);
    1;
}

1;
}
##} /usr/local/libdata/perl5/site_perl/HTTP/Cookies/Netscape.pm
##{ /usr/local/libdata/perl5/site_perl/HTTP/Cookies.pm
{
package HTTP::Cookies;

use strict;
BEGIN { HTTP::Date->import( qw(str2time parse_date time2str)); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *str2time = \&HTTP::Date::str2time; *parse_date = \&HTTP::Date::parse_date; *time2str = \&HTTP::Date::time2str; }
BEGIN { HTTP::Headers::Util->import( qw(_split_header_words join_header_words)); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *_split_header_words = \&HTTP::Headers::Util::_split_header_words; *join_header_words = \&HTTP::Headers::Util::join_header_words; }

use vars qw($VERSION $EPOCH_OFFSET);
$VERSION = "5.837";


$EPOCH_OFFSET = 0;  # difference from Unix epoch
if ($^O eq "MacOS") {
    require Time::Local;
    $EPOCH_OFFSET = Time::Local::timelocal(0,0,0,1,0,70);
}


sub new
{
    my $class = shift;
    my $self = bless {
	COOKIES => {},
    }, $class;
    my %cnf = @_;
    for (keys %cnf) {
	$self->{lc($_)} = $cnf{$_};
    }
    $self->load;
    $self;
}


sub add_cookie_header
{
    my $self = shift;
    my $request = shift || return;
    my $url = $request->uri;
    my $scheme = $url->scheme;
    unless ($scheme =~ /^https?\z/) {
	return;
    }

    my $domain = _host($request, $url);
    $domain = "$domain.local" unless $domain =~ /\./;
    my $secure_request = ($scheme eq "https");
    my $req_path = _url_path($url);
    my $req_port = $url->port;
    my $now = time();
    _normalize_path($req_path) if $req_path =~ /%/;

    my @cval;    # cookie values for the "Cookie" header
    my $set_ver;
    my $netscape_only = 0; # An exact domain match applies to any cookie

    while ($domain =~ /\./) {
	my $cookies = $self->{COOKIES}{$domain};
	next unless $cookies;
	if ($self->{delayload} && defined($cookies->{'//+delayload'})) {
	    my $cookie_data = $cookies->{'//+delayload'}{'cookie'};
	    delete $self->{COOKIES}{$domain};
	    $self->load_cookie($cookie_data->[1]);
	    $cookies = $self->{COOKIES}{$domain};
	    next unless $cookies;  # should not really happen
	}

	my $path;
	for $path (sort {length($b) <=> length($a) } keys %$cookies) {
	    if (index($req_path, $path) != 0) {
		next;
	    }

	    my($key,$array);
	    while (($key,$array) = each %{$cookies->{$path}}) {
		my($version,$val,$port,$path_spec,$secure,$expires) = @$array;
		if ($secure && !$secure_request) {
		    next;
		}
		if ($expires && $expires < $now) {
		    next;
		}
		if ($port) {
		    my $found;
		    if ($port =~ s/^_//) {
			$found++ if $port eq $req_port;
			$port = "";
		    }
		    else {
			my $p;
			for $p (split(/,/, $port)) {
			    $found++, last if $p eq $req_port;
			}
		    }
		    unless ($found) {
			next;
		    }
		}
		if ($version > 0 && $netscape_only) {
		    next;
		}

		if (!$set_ver++) {
		    if ($version >= 1) {
			push(@cval, "\$Version=$version");
		    }
		    elsif (!$self->{hide_cookie2}) {
			$request->header(Cookie2 => '$Version="1"');
		    }
		}

		if ($val =~ /\W/ && $version) {
		    $val =~ s/([\\\"])/\\$1/g;
		    $val = qq("$val");
		}

		push(@cval, "$key=$val");
		if ($version >= 1) {
		    push(@cval, qq(\$Path="$path"))     if $path_spec;
		    push(@cval, qq(\$Domain="$domain")) if $domain =~ /^\./;
		    if (defined $port) {
			my $p = '$Port';
			$p .= qq(="$port") if length $port;
			push(@cval, $p);
		    }
		}

	    }
        }

    } continue {

	if ($domain =~ s/^\.+//) {
	    $netscape_only = 1;
	}
	else {
	    $domain =~ s/[^.]*//;
	    $netscape_only = 0;
	}
    }

    if (@cval) {
	if (my $old = $request->header("Cookie")) {
	    unshift(@cval, $old);
	}
	$request->header(Cookie => join("; ", @cval));
    }

    $request;
}


sub extract_cookies
{
    my $self = shift;
    my $response = shift || return;

    my @set = _split_header_words($response->_header("Set-Cookie2"));
    my @ns_set = $response->_header("Set-Cookie");

    return $response unless @set || @ns_set;  # quick exit

    my $request = $response->request;
    my $url = $request->uri;
    my $req_host = _host($request, $url);
    $req_host = "$req_host.local" unless $req_host =~ /\./;
    my $req_port = $url->port;
    my $req_path = _url_path($url);
    _normalize_path($req_path) if $req_path =~ /%/;

    if (@ns_set) {
	my $now = time();

	my %in_set2;
	for (@set) {
	    $in_set2{$_->[0]}++;
	}

	my $set;
	for $set (@ns_set) {
            $set =~ s/^\s+//;
	    my @cur;
	    my $param;
	    my $expires;
	    my $first_param = 1;
	    for $param (split(/;\s*/, $set)) {
                next unless length($param);
		my($k,$v) = split(/\s*=\s*/, $param, 2);
		if (defined $v) {
		    $v =~ s/\s+$//;
		}
		else {
		    $k =~ s/\s+$//;
		}
		if (!$first_param && lc($k) eq "expires") {
		    my $etime = str2time($v);
		    if (defined $etime) {
			push(@cur, "Max-Age" => $etime - $now);
			$expires++;
		    }
		    else {
			my($year, $mon, $day, $hour, $min, $sec, $tz) = parse_date($v);
			if ($year) {
			    my $thisyear = (gmtime)[5] + 1900;
			    if ($year < $thisyear) {
				push(@cur, "Max-Age" => -1);  # any negative value will do
				$expires++;
			    }
			    elsif ($year >= $thisyear + 10) {
				push(@cur, "Max-Age" => 10 * 365 * 24 * 60 * 60);
				$expires++;
			    }
			}
		    }
		}
                elsif (!$first_param && lc($k) =~ /^(?:version|discard|ns-cookie)/) {
                }
		else {
		    push(@cur, $k => $v);
		}
		$first_param = 0;
	    }
            next unless @cur;
	    next if $in_set2{$cur[0]};

	    push(@cur, "Discard" => undef) unless $expires;
	    push(@cur, "Version" => 0);
	    push(@cur, "ns-cookie" => 1);
	    push(@set, \@cur);
	}
    }

  SET_COOKIE:
    for my $set (@set) {
	next unless @$set >= 2;

	my $key = shift @$set;
	my $val = shift @$set;

	my %hash;
	while (@$set) {
	    my $k = shift @$set;
	    my $v = shift @$set;
	    my $lc = lc($k);
	    $k = $lc if $lc =~ /^(?:discard|domain|max-age|
                                    path|port|secure|version)$/x;
	    if ($k eq "discard" || $k eq "secure") {
		$v = 1 unless defined $v;
	    }
	    next if exists $hash{$k};  # only first value is significant
	    $hash{$k} = $v;
	};

	my %orig_hash = %hash;
	my $version   = delete $hash{version};
	$version = 1 unless defined($version);
	my $discard   = delete $hash{discard};
	my $secure    = delete $hash{secure};
	my $maxage    = delete $hash{'max-age'};
	my $ns_cookie = delete $hash{'ns-cookie'};

	my $domain  = delete $hash{domain};
	$domain = lc($domain) if defined $domain;
	if (defined($domain)
	    && $domain ne $req_host && $domain ne ".$req_host") {
	    if ($domain !~ /\./ && $domain ne "local") {
		next SET_COOKIE;
	    }
	    $domain = ".$domain" unless $domain =~ /^\./;
	    if ($domain =~ /\.\d+$/) {
		next SET_COOKIE;
	    }
	    my $len = length($domain);
	    unless (substr($req_host, -$len) eq $domain) {
		next SET_COOKIE;
	    }
	    my $hostpre = substr($req_host, 0, length($req_host) - $len);
	    if ($hostpre =~ /\./ && !$ns_cookie) {
		next SET_COOKIE;
	    }
	}
	else {
	    $domain = $req_host;
	}

	my $path = delete $hash{path};
	my $path_spec;
	if (defined $path && $path ne '') {
	    $path_spec++;
	    _normalize_path($path) if $path =~ /%/;
	    if (!$ns_cookie &&
                substr($req_path, 0, length($path)) ne $path) {
		next SET_COOKIE;
	    }
	}
	else {
	    $path = $req_path;
	    $path =~ s,/[^/]*$,,;
	    $path = "/" unless length($path);
	}

	my $port;
	if (exists $hash{port}) {
	    $port = delete $hash{port};
	    if (defined $port) {
		$port =~ s/\s+//g;
		my $found;
		for my $p (split(/,/, $port)) {
		    unless ($p =~ /^\d+$/) {
			next SET_COOKIE;
		    }
		    $found++ if $p eq $req_port;
		}
		unless ($found) {
		    next SET_COOKIE;
		}
	    }
	    else {
		$port = "_$req_port";
	    }
	}
	$self->set_cookie($version,$key,$val,$path,$domain,$port,$path_spec,$secure,$maxage,$discard, \%hash)
	    if $self->set_cookie_ok(\%orig_hash);
    }

    $response;
}

sub set_cookie_ok
{
    1;
}


sub set_cookie
{
    my $self = shift;
    my($version,
       $key, $val, $path, $domain, $port,
       $path_spec, $secure, $maxage, $discard, $rest) = @_;

    return $self if !defined($path) || $path !~ m,^/, ||
	            !defined($key)  || $key  =~ m,^\$,;

    if (defined $port) {
	return $self unless $port =~ /^_?\d+(?:,\d+)*$/;
    }

    my $expires;
    if (defined $maxage) {
	if ($maxage <= 0) {
	    delete $self->{COOKIES}{$domain}{$path}{$key};
	    return $self;
	}
	$expires = time() + $maxage;
    }
    $version = 0 unless defined $version;

    my @array = ($version, $val,$port,
		 $path_spec,
		 $secure, $expires, $discard);
    push(@array, {%$rest}) if defined($rest) && %$rest;
    pop(@array) while !defined $array[-1];

    $self->{COOKIES}{$domain}{$path}{$key} = \@array;
    $self;
}


sub save
{
    my $self = shift;
    my $file = shift || $self->{'file'} || return;
    local(*FILE);
    open(FILE, ">$file") or die "Can't open $file: $!";
    print FILE "#LWP-Cookies-1.0\n";
    print FILE $self->as_string(!$self->{ignore_discard});
    close(FILE);
    1;
}


sub load
{
    my $self = shift;
    my $file = shift || $self->{'file'} || return;
    local(*FILE, $_);
    local $/ = "\n";  # make sure we got standard record separator
    open(FILE, $file) or return;
    my $magic = <FILE>;
    unless ($magic =~ /^\#LWP-Cookies-(\d+\.\d+)/) {
	warn "$file does not seem to contain cookies";
	return;
    }
    while (<FILE>) {
	next unless s/^Set-Cookie3:\s*//;
	chomp;
	my $cookie;
	for $cookie (_split_header_words($_)) {
	    my($key,$val) = splice(@$cookie, 0, 2);
	    my %hash;
	    while (@$cookie) {
		my $k = shift @$cookie;
		my $v = shift @$cookie;
		$hash{$k} = $v;
	    }
	    my $version   = delete $hash{version};
	    my $path      = delete $hash{path};
	    my $domain    = delete $hash{domain};
	    my $port      = delete $hash{port};
	    my $expires   = str2time(delete $hash{expires});

	    my $path_spec = exists $hash{path_spec}; delete $hash{path_spec};
	    my $secure    = exists $hash{secure};    delete $hash{secure};
	    my $discard   = exists $hash{discard};   delete $hash{discard};

	    my @array =	($version,$val,$port,
			 $path_spec,$secure,$expires,$discard);
	    push(@array, \%hash) if %hash;
	    $self->{COOKIES}{$domain}{$path}{$key} = \@array;
	}
    }
    close(FILE);
    1;
}


sub revert
{
    my $self = shift;
    $self->clear->load;
    $self;
}


sub clear
{
    my $self = shift;
    if (@_ == 0) {
	$self->{COOKIES} = {};
    }
    elsif (@_ == 1) {
	delete $self->{COOKIES}{$_[0]};
    }
    elsif (@_ == 2) {
	delete $self->{COOKIES}{$_[0]}{$_[1]};
    }
    elsif (@_ == 3) {
	delete $self->{COOKIES}{$_[0]}{$_[1]}{$_[2]};
    }
    else {
	require Carp;
        Carp::carp('Usage: $c->clear([domain [,path [,key]]])');
    }
    $self;
}


sub clear_temporary_cookies
{
    my($self) = @_;

    $self->scan(sub {
        if($_[9] or        # "Discard" flag set
           not $_[8]) {    # No expire field?
            $_[8] = -1;            # Set the expire/max_age field
            $self->set_cookie(@_); # Clear the cookie
        }
      });
}


sub DESTROY
{
    my $self = shift;
    local($., $@, $!, $^E, $?);
    $self->save if $self->{'autosave'};
}


sub scan
{
    my($self, $cb) = @_;
    my($domain,$path,$key);
    for $domain (sort keys %{$self->{COOKIES}}) {
	for $path (sort keys %{$self->{COOKIES}{$domain}}) {
	    for $key (sort keys %{$self->{COOKIES}{$domain}{$path}}) {
		my($version,$val,$port,$path_spec,
		   $secure,$expires,$discard,$rest) =
		       @{$self->{COOKIES}{$domain}{$path}{$key}};
		$rest = {} unless defined($rest);
		&$cb($version,$key,$val,$path,$domain,$port,
		     $path_spec,$secure,$expires,$discard,$rest);
	    }
	}
    }
}


sub as_string
{
    my($self, $skip_discard) = @_;
    my @res;
    $self->scan(sub {
	my($version,$key,$val,$path,$domain,$port,
	   $path_spec,$secure,$expires,$discard,$rest) = @_;
	return if $discard && $skip_discard;
	my @h = ($key, $val);
	push(@h, "path", $path);
	push(@h, "domain" => $domain);
	push(@h, "port" => $port) if defined $port;
	push(@h, "path_spec" => undef) if $path_spec;
	push(@h, "secure" => undef) if $secure;
	push(@h, "expires" => HTTP::Date::time2isoz($expires)) if $expires;
	push(@h, "discard" => undef) if $discard;
	my $k;
	for $k (sort keys %$rest) {
	    push(@h, $k, $rest->{$k});
	}
	push(@h, "version" => $version);
	push(@res, "Set-Cookie3: " . join_header_words(\@h));
    });
    join("\n", @res, "");
}

sub _host
{
    my($request, $url) = @_;
    if (my $h = $request->header("Host")) {
	$h =~ s/:\d+$//;  # might have a port as well
	return lc($h);
    }
    return lc($url->host);
}

sub _url_path
{
    my $url = shift;
    my $path;
    if($url->can('epath')) {
       $path = $url->epath;    # URI::URL method
    }
    else {
       $path = $url->path;           # URI::_generic method
    }
    $path = "/" unless length $path;
    $path;
}

sub _normalize_path  # so that plain string compare can be used
{
    my $x;
    $_[0] =~ s/%([0-9a-fA-F][0-9a-fA-F])/
	         $x = uc($1);
                 $x eq "2F" || $x eq "25" ? "%$x" :
                                            pack("C", hex($x));
              /eg;
    $_[0] =~ s/([\0-\x20\x7f-\xff])/sprintf("%%%02X",ord($1))/eg;
}

1;

}
##} /usr/local/libdata/perl5/site_perl/HTTP/Cookies.pm
BEGIN { $INC{'HTTP/Config.pm'}++; }
BEGIN { $INC{'URI.pm'}++; }
BEGIN { $INC{'URI/Escape.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/URI/Escape.pm
{
package URI::Escape;
use strict;


use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
use vars qw(%escapes);

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
@EXPORT_OK = qw(%escapes);
$VERSION = "3.30";

use Carp ();

for (0..255) {
    $escapes{chr($_)} = sprintf("%%%02X", $_);
}

my %subst;  # compiled patterns

my %Unsafe = (
    RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
    RFC3986 => qr/[^A-Za-z0-9\-\._~"]/,
);

sub uri_escape
{
    my($text, $patn) = @_;
    return undef unless defined $text;
    if (defined $patn){
	unless (exists  $subst{$patn}) {
	    (my $tmp = $patn) =~ s,/,\\/,g;
	    eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
	    Carp::croak("uri_escape: $@") if $@;
	}
	&{$subst{$patn}}($text);
    } else {
	$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
    }
    $text;
}

sub _fail_hi {
    my $chr = shift;
    Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
}

sub uri_escape_utf8
{
    my $text = shift;
    if ($] < 5.008) {
	$text =~ s/([^\0-\x7F])/do {my $o = ord($1); sprintf("%c%c", 0xc0 | ($o >> 6), 0x80 | ($o & 0x3f)) }/ge;
    }
    else {
	utf8::encode($text);
    }

    return uri_escape($text, @_);
}

sub uri_unescape
{
    my $str = shift;
    if (@_ && wantarray) {
	my @str = ($str, @_);  # need to copy
	foreach (@str) {
	    s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
	}
	return @str;
    }
    $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
    $str;
}

sub escape_char {
    return join '', @URI::Escape::escapes{$_[0] =~ /(\C)/g};
}

1;
}
##} /usr/local/libdata/perl5/site_perl/URI/Escape.pm
##{ /usr/local/libdata/perl5/site_perl/URI.pm
{
package URI;

use strict;
use vars qw($VERSION);
$VERSION = "1.54";

use vars qw($ABS_REMOTE_LEADING_DOTS $ABS_ALLOW_RELATIVE_SCHEME $DEFAULT_QUERY_FORM_DELIMITER);

my %implements;  # mapping from scheme to implementor class


use vars qw($reserved $mark $unreserved $uric $scheme_re);
$reserved   = q(;/?:@&=+$,[]);
$mark       = q(-_.!~*'());                                    #'; emacs
$unreserved = "A-Za-z0-9\Q$mark\E";
$uric       = quotemeta($reserved) . $unreserved . "%";

$scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';

use Carp ();

use overload ('""'     => sub { ${$_[0]} },
              '=='     => sub { _obj_eq(@_) },
              '!='     => sub { !_obj_eq(@_) },
              fallback => 1,
             );

sub _obj_eq {
    return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
}

sub new
{
    my($class, $uri, $scheme) = @_;

    $uri = defined ($uri) ? "$uri" : "";   # stringify
    $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
    $uri =~ s/^"(.*)"$/$1/;
    $uri =~ s/^\s+//;
    $uri =~ s/\s+$//;

    my $impclass;
    if ($uri =~ m/^($scheme_re):/so) {
	$scheme = $1;
    }
    else {
	if (($impclass = ref($scheme))) {
	    $scheme = $scheme->scheme;
	}
	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
	    $scheme = $1;
        }
    }
    $impclass ||= implementor($scheme) ||
	do {
	    require URI::_foreign;
	    $impclass = 'URI::_foreign';
	};

    return $impclass->_init($uri, $scheme);
}


sub new_abs
{
    my($class, $uri, $base) = @_;
    $uri = $class->new($uri, $base);
    $uri->abs($base);
}


sub _init
{
    my $class = shift;
    my($str, $scheme) = @_;
    $str = $class->_uric_escape($str);
    $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                 $class->_no_scheme_ok;
    my $self = bless \$str, $class;
    $self;
}


sub _uric_escape
{
    my($class, $str) = @_;
    $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
    return $str;
}


sub implementor
{
    my($scheme, $impclass) = @_;
    if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
	require URI::_generic;
	return "URI::_generic";
    }

    $scheme = lc($scheme);

    if ($impclass) {
        my $old = $implements{$scheme};
        $impclass->_init_implementor($scheme);
        $implements{$scheme} = $impclass;
        return $old;
    }

    my $ic = $implements{$scheme};
    return $ic if $ic;

    $ic = "URI::$scheme";  # default location

    $ic =~ s/\+/_P/g;
    $ic =~ s/\./_O/g;
    $ic =~ s/\-/_/g;

    no strict 'refs';
    unless (@{"${ic}::ISA"}) {
        eval "require $ic";
        die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
        return unless @{"${ic}::ISA"};
    }

    $ic->_init_implementor($scheme);
    $implements{$scheme} = $ic;
    $ic;
}


sub _init_implementor
{
    my($class, $scheme) = @_;
}


sub clone
{
    my $self = shift;
    my $other = $$self;
    bless \$other, ref $self;
}


sub _no_scheme_ok { 0 }

sub _scheme
{
    my $self = shift;

    unless (@_) {
	return unless $$self =~ /^($scheme_re):/o;
	return $1;
    }

    my $old;
    my $new = shift;
    if (defined($new) && length($new)) {
	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
	$old = $1 if $$self =~ s/^($scheme_re)://o;
	my $newself = URI->new("$new:$$self");
	$$self = $$newself; 
	bless $self, ref($newself);
    }
    else {
	if ($self->_no_scheme_ok) {
	    $old = $1 if $$self =~ s/^($scheme_re)://o;
	    Carp::carp("Oops, opaque part now look like scheme")
		if $^W && $$self =~ m/^$scheme_re:/o
	}
	else {
	    $old = $1 if $$self =~ m/^($scheme_re):/o;
	}
    }

    return $old;
}

sub scheme
{
    my $scheme = shift->_scheme(@_);
    return unless defined $scheme;
    lc($scheme);
}


sub opaque
{
    my $self = shift;

    unless (@_) {
	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
	return $1;
    }

    $$self =~ /^($scheme_re:)?    # optional scheme
	        ([^\#]*)          # opaque
                (\#.*)?           # optional fragment
              $/sx or die;

    my $old_scheme = $1;
    my $old_opaque = $2;
    my $old_frag   = $3;

    my $new_opaque = shift;
    $new_opaque = "" unless defined $new_opaque;
    $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;

    $$self = defined($old_scheme) ? $old_scheme : "";
    $$self .= $new_opaque;
    $$self .= $old_frag if defined $old_frag;

    $old_opaque;
}

*path = \&opaque;  # alias


sub fragment
{
    my $self = shift;
    unless (@_) {
	return unless $$self =~ /\#(.*)/s;
	return $1;
    }

    my $old;
    $old = $1 if $$self =~ s/\#(.*)//s;

    my $new_frag = shift;
    if (defined $new_frag) {
	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
	$$self .= "#$new_frag";
    }
    $old;
}


sub as_string
{
    my $self = shift;
    $$self;
}


sub as_iri
{
    my $self = shift;
    my $str = $$self;
    if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {

	require Encode;
	my $enc = Encode::find_encoding("UTF-8");
	my $u = "";
	while (length $str) {
	    $u .= $enc->decode($str, Encode::FB_QUIET());
	    if (length $str) {
		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
	    }
	}
	$str = $u;
    }
    return $str;
}


sub canonical
{

    my $self = shift;
    my $scheme = $self->_scheme || "";
    my $uc_scheme = $scheme =~ /[A-Z]/;
    my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
    return $self unless $uc_scheme || $esc;

    my $other = $self->clone;
    if ($uc_scheme) {
	$other->_scheme(lc $scheme);
    }
    if ($esc) {
	$$other =~ s{%([0-9a-fA-F]{2})}
	            { my $a = chr(hex($1));
                      $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                    }ge;
    }
    return $other;
}

sub eq {
    my($self, $other) = @_;
    $self  = URI->new($self, $other) unless ref $self;
    $other = URI->new($other, $self) unless ref $other;
    ref($self) eq ref($other) &&                # same class
	$self->canonical->as_string eq $other->canonical->as_string;
}

sub abs { $_[0]; }
sub rel { $_[0]; }

sub secure { 0 }

sub STORABLE_freeze {
       my($self, $cloning) = @_;
       return $$self;
}

sub STORABLE_thaw {
       my($self, $cloning, $str) = @_;
       $$self = $str;
}

1;

}
##} /usr/local/libdata/perl5/site_perl/URI.pm
##{ /usr/local/libdata/perl5/site_perl/HTTP/Config.pm
{
package HTTP::Config;

use strict;
BEGIN { URI->import(); } # (added by utils/combine-perl.pl)
use vars qw($VERSION);

$VERSION = "5.835";

sub new {
    my $class = shift;
    return bless [], $class;
}

sub entries {
    my $self = shift;
    @$self;
}

sub empty {
    my $self = shift;
    not @$self;
}

sub add {
    if (@_ == 2) {
        my $self = shift;
        push(@$self, shift);
        return;
    }
    my($self, %spec) = @_;
    push(@$self, \%spec);
    return;
}

sub find2 {
    my($self, %spec) = @_;
    my @found;
    my @rest;
 ITEM:
    for my $item (@$self) {
        for my $k (keys %spec) {
            if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                push(@rest, $item);
                next ITEM;
            }
        }
        push(@found, $item);
    }
    return \@found unless wantarray;
    return \@found, \@rest;
}

sub find {
    my $self = shift;
    my $f = $self->find2(@_);
    return @$f if wantarray;
    return $f->[0];
}

sub remove {
    my($self, %spec) = @_;
    my($removed, $rest) = $self->find2(%spec);
    @$self = @$rest if @$removed;
    return @$removed;
}

my %MATCH = (
    m_scheme => sub {
        my($v, $uri) = @_;
        return $uri->_scheme eq $v;  # URI known to be canonical
    },
    m_secure => sub {
        my($v, $uri) = @_;
        my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
        return $secure == !!$v;
    },
    m_host_port => sub {
        my($v, $uri) = @_;
        return unless $uri->can("host_port");
        return $uri->host_port eq $v, 7;
    },
    m_host => sub {
        my($v, $uri) = @_;
        return unless $uri->can("host");
        return $uri->host eq $v, 6;
    },
    m_port => sub {
        my($v, $uri) = @_;
        return unless $uri->can("port");
        return $uri->port eq $v;
    },
    m_domain => sub {
        my($v, $uri) = @_;
        return unless $uri->can("host");
        my $h = $uri->host;
        $h = "$h.local" unless $h =~ /\./;
        $v = ".$v" unless $v =~ /^\./;
        return length($v), 5 if substr($h, -length($v)) eq $v;
        return 0;
    },
    m_path => sub {
        my($v, $uri) = @_;
        return unless $uri->can("path");
        return $uri->path eq $v, 4;
    },
    m_path_prefix => sub {
        my($v, $uri) = @_;
        return unless $uri->can("path");
        my $path = $uri->path;
        my $len = length($v);
        return $len, 3 if $path eq $v;
        return 0 if length($path) <= $len;
        $v .= "/" unless $v =~ m,/\z,,;
        return $len, 3 if substr($path, 0, length($v)) eq $v;
        return 0;
    },
    m_path_match => sub {
        my($v, $uri) = @_;
        return unless $uri->can("path");
        return $uri->path =~ $v;
    },
    m_uri__ => sub {
        my($v, $k, $uri) = @_;
        return unless $uri->can($k);
        return 1 unless defined $v;
        return $uri->$k eq $v;
    },
    m_method => sub {
        my($v, $uri, $request) = @_;
        return $request && $request->method eq $v;
    },
    m_proxy => sub {
        my($v, $uri, $request) = @_;
        return $request && ($request->{proxy} || "") eq $v;
    },
    m_code => sub {
        my($v, $uri, $request, $response) = @_;
        $v =~ s/xx\z//;
        return unless $response;
        return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
    },
    m_media_type => sub {  # for request too??
        my($v, $uri, $request, $response) = @_;
        return unless $response;
        return 1, 1 if $v eq "*/*";
        my $ct = $response->content_type;
        return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
        return 3, 1 if $v eq "html" && $response->content_is_html;
        return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
        return 10, 1 if $v eq $ct;
        return 0;
    },
    m_header__ => sub {
        my($v, $k, $uri, $request, $response) = @_;
        return unless $request;
        return 1 if $request->header($k) eq $v;
        return 1 if $response && $response->header($k) eq $v;
        return 0;
    },
    m_response_attr__ => sub {
        my($v, $k, $uri, $request, $response) = @_;
        return unless $response;
        return 1 if !defined($v) && exists $response->{$k};
        return 0 unless exists $response->{$k};
        return 1 if $response->{$k} eq $v;
        return 0;
    },
);

sub matching {
    my $self = shift;
    if (@_ == 1) {
        if ($_[0]->can("request")) {
            unshift(@_, $_[0]->request);
            unshift(@_, undef) unless defined $_[0];
        }
        unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
    }
    my($uri, $request, $response) = @_;
    $uri = URI->new($uri) unless ref($uri);

    my @m;
 ITEM:
    for my $item (@$self) {
        my $order;
        for my $ikey (keys %$item) {
            my $mkey = $ikey;
            my $k;
            $k = $1 if $mkey =~ s/__(.*)/__/;
            if (my $m = $MATCH{$mkey}) {
                my($c, $o);
                my @arg = (
                    defined($k) ? $k : (),
                    $uri, $request, $response
                );
                my $v = $item->{$ikey};
                $v = [$v] unless ref($v) eq "ARRAY";
                for (@$v) {
                    ($c, $o) = $m->($_, @arg);
                    last if $c;
                }
                next ITEM unless $c;
                $order->[$o || 0] += $c;
            }
        }
        $order->[7] ||= 0;
        $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
        push(@m, $item);
    }
    @m = sort { $b->{_order} cmp $a->{_order} } @m;
    delete $_->{_order} for @m;
    return @m if wantarray;
    return $m[0];
}

sub add_item {
    my $self = shift;
    my $item = shift;
    return $self->add(item => $item, @_);
}

sub remove_items {
    my $self = shift;
    return map $_->{item}, $self->remove(@_);
}

sub matching_items {
    my $self = shift;
    return map $_->{item}, $self->matching(@_);
}

1;

}
##} /usr/local/libdata/perl5/site_perl/HTTP/Config.pm
BEGIN { $INC{'HTTP/Request/Common.pm'}++; }
BEGIN { $INC{'HTTP/Request.pm'}++; }
BEGIN { $INC{'HTTP/Message.pm'}++; }
BEGIN { $INC{'HTTP/Headers.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTTP/Headers.pm
{
package HTTP::Headers;

use strict;
use Carp ();

use vars qw($VERSION $TRANSLATE_UNDERSCORE);
$VERSION = "5.835";

$TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;


my @general_headers = qw(
    Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
    Via Warning
);

my @request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language
    Authorization Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Proxy-Authorization Range Referer TE User-Agent
);

my @response_headers = qw(
    Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
    Vary WWW-Authenticate
);

my @entity_headers = qw(
    Allow Content-Encoding Content-Language Content-Length Content-Location
    Content-MD5 Content-Range Content-Type Expires Last-Modified
);

my %entity_header = map { lc($_) => 1 } @entity_headers;

my @header_order = (
    @general_headers,
    @request_headers,
    @response_headers,
    @entity_headers,
);

my %header_order;
my %standard_case;

{
    my $i = 0;
    for (@header_order) {
	my $lc = lc $_;
	$header_order{$lc} = ++$i;
	$standard_case{$lc} = $_;
    }
}



sub new
{
    my($class) = shift;
    my $self = bless {}, $class;
    $self->header(@_) if @_; # set up initial headers
    $self;
}


sub header
{
    my $self = shift;
    Carp::croak('Usage: $h->header($field, ...)') unless @_;
    my(@old);
    my %seen;
    while (@_) {
	my $field = shift;
        my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
	@old = $self->_header($field, shift, $op);
    }
    return @old if wantarray;
    return $old[0] if @old <= 1;
    join(", ", @old);
}

sub clear
{
    my $self = shift;
    %$self = ();
}


sub push_header
{
    my $self = shift;
    return $self->_header(@_, 'PUSH_H') if @_ == 2;
    while (@_) {
	$self->_header(splice(@_, 0, 2), 'PUSH_H');
    }
}


sub init_header
{
    Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
    shift->_header(@_, 'INIT');
}


sub remove_header
{
    my($self, @fields) = @_;
    my $field;
    my @values;
    foreach $field (@fields) {
	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
	my $v = delete $self->{lc $field};
	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
    }
    return @values;
}

sub remove_content_headers
{
    my $self = shift;
    unless (defined(wantarray)) {
	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
	return;
    }

    my $c = ref($self)->new;
    for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
	$c->{$f} = delete $self->{$f};
    }
    $c;
}


sub _header
{
    my($self, $field, $val, $op) = @_;

    unless ($field =~ /^:/) {
	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
	my $old = $field;
	$field = lc $field;
	unless(defined $standard_case{$field}) {
	    $old =~ s/\b(\w)/\u$1/g;
	    $standard_case{$field} = $old;
	}
    }

    $op ||= defined($val) ? 'SET' : 'GET';
    if ($op eq 'PUSH_H') {
	if (exists $self->{$field}) {
	    my $h = $self->{$field};
	    if (ref($h) eq 'ARRAY') {
		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
	    }
	    else {
		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
	    }
	    return;
	}
	$self->{$field} = $val;
	return;
    }

    my $h = $self->{$field};
    my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());

    unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
	if (defined($val)) {
	    my @new = ($op eq 'PUSH') ? @old : ();
	    if (ref($val) ne 'ARRAY') {
		push(@new, $val);
	    }
	    else {
		push(@new, @$val);
	    }
	    $self->{$field} = @new > 1 ? \@new : $new[0];
	}
	elsif ($op ne 'PUSH') {
	    delete $self->{$field};
	}
    }
    @old;
}


sub _sorted_field_names
{
    my $self = shift;
    return [ sort {
        ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
         $a cmp $b
    } keys %$self ];
}


sub header_field_names {
    my $self = shift;
    return map $standard_case{$_} || $_, @{ $self->_sorted_field_names },
	if wantarray;
    return keys %$self;
}


sub scan
{
    my($self, $sub) = @_;
    my $key;
    for $key (@{ $self->_sorted_field_names }) {
	next if substr($key, 0, 1) eq '_';
	my $vals = $self->{$key};
	if (ref($vals) eq 'ARRAY') {
	    my $val;
	    for $val (@$vals) {
		$sub->($standard_case{$key} || $key, $val);
	    }
	}
	else {
	    $sub->($standard_case{$key} || $key, $vals);
	}
    }
}


sub as_string
{
    my($self, $endl) = @_;
    $endl = "\n" unless defined $endl;

    my @result = ();
    for my $key (@{ $self->_sorted_field_names }) {
	next if index($key, '_') == 0;
	my $vals = $self->{$key};
	if ( ref($vals) eq 'ARRAY' ) {
	    for my $val (@$vals) {
		my $field = $standard_case{$key} || $key;
		$field =~ s/^://;
		if ( index($val, "\n") >= 0 ) {
		    $val = _process_newline($val, $endl);
		}
		push @result, $field . ': ' . $val;
	    }
	}
	else {
	    my $field = $standard_case{$key} || $key;
	    $field =~ s/^://;
	    if ( index($vals, "\n") >= 0 ) {
		$vals = _process_newline($vals, $endl);
	    }
	    push @result, $field . ': ' . $vals;
	}
    }

    join($endl, @result, '');
}

sub _process_newline {
    local $_ = shift;
    my $endl = shift;
    s/\s+$//;        # trailing newlines and space must go
    s/\n(\x0d?\n)+/\n/g;     # no empty lines
    s/\n([^\040\t])/\n $1/g; # intial space for continuation
    s/\n/$endl/g;    # substitute with requested line ending
    $_;
}



if (eval { require Storable; 1 }) {
    *clone = \&Storable::dclone;
} else {
    *clone = sub {
	my $self = shift;
	my $clone = HTTP::Headers->new;
	$self->scan(sub { $clone->push_header(@_);} );
	$clone;
    };
}


sub _date_header
{
    require HTTP::Date;
    my($self, $header, $time) = @_;
    my($old) = $self->_header($header);
    if (defined $time) {
	$self->_header($header, HTTP::Date::time2str($time));
    }
    $old =~ s/;.*// if defined($old);
    HTTP::Date::str2time($old);
}


sub date                { shift->_date_header('Date',                @_); }
sub expires             { shift->_date_header('Expires',             @_); }
sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
sub last_modified       { shift->_date_header('Last-Modified',       @_); }

sub client_date         { shift->_date_header('Client-Date',         @_); }


sub content_type      {
    my $self = shift;
    my $ct = $self->{'content-type'};
    $self->{'content-type'} = shift if @_;
    $ct = $ct->[0] if ref($ct) eq 'ARRAY';
    return '' unless defined($ct) && length($ct);
    my @ct = split(/;\s*/, $ct, 2);
    for ($ct[0]) {
	s/\s+//g;
	$_ = lc($_);
    }
    wantarray ? @ct : $ct[0];
}

sub content_type_charset {
    my $self = shift;
    require HTTP::Headers::Util;
    my $h = $self->{'content-type'};
    $h = $h->[0] if ref($h);
    $h = "" unless defined $h;
    my @v = HTTP::Headers::Util::split_header_words($h);
    if (@v) {
	my($ct, undef, %ct_param) = @{$v[0]};
	my $charset = $ct_param{charset};
	if ($ct) {
	    $ct = lc($ct);
	    $ct =~ s/\s+//;
	}
	if ($charset) {
	    $charset = uc($charset);
	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
	    undef($charset) if $charset eq "";
	}
	return $ct, $charset if wantarray;
	return $charset;
    }
    return undef, undef if wantarray;
    return undef;
}

sub content_is_text {
    my $self = shift;
    return $self->content_type =~ m,^text/,;
}

sub content_is_html {
    my $self = shift;
    return $self->content_type eq 'text/html' || $self->content_is_xhtml;
}

sub content_is_xhtml {
    my $ct = shift->content_type;
    return $ct eq "application/xhtml+xml" ||
           $ct eq "application/vnd.wap.xhtml+xml";
}

sub content_is_xml {
    my $ct = shift->content_type;
    return 1 if $ct eq "text/xml";
    return 1 if $ct eq "application/xml";
    return 1 if $ct =~ /\+xml$/;
    return 0;
}

sub referer           {
    my $self = shift;
    if (@_ && $_[0] =~ /#/) {
	my $uri = shift;
	if (ref($uri)) {
	    $uri = $uri->clone;
	    $uri->fragment(undef);
	}
	else {
	    $uri =~ s/\#.*//;
	}
	unshift @_, $uri;
    }
    ($self->_header('Referer', @_))[0];
}
*referrer = \&referer;  # on tchrist's request

sub title             { (shift->_header('Title',            @_))[0] }
sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
sub content_language  { (shift->_header('Content-Language', @_))[0] }
sub content_length    { (shift->_header('Content-Length',   @_))[0] }

sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
sub server            { (shift->_header('Server',           @_))[0] }

sub from              { (shift->_header('From',             @_))[0] }
sub warning           { (shift->_header('Warning',          @_))[0] }

sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
sub authorization     { (shift->_header('Authorization',    @_))[0] }

sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }

sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }

sub _basic_auth {
    require MIME::Base64;
    my($self, $h, $user, $passwd) = @_;
    my($old) = $self->_header($h);
    if (defined $user) {
	Carp::croak("Basic authorization user name can't contain ':'")
	  if $user =~ /:/;
	$passwd = '' unless defined $passwd;
	$self->_header($h => 'Basic ' .
                             MIME::Base64::encode("$user:$passwd", ''));
    }
    if (defined $old && $old =~ s/^\s*Basic\s+//) {
	my $val = MIME::Base64::decode($old);
	return $val unless wantarray;
	return split(/:/, $val, 2);
    }
    return;
}


1;

}
##} /usr/local/libdata/perl5/site_perl/HTTP/Headers.pm
##{ /usr/local/libdata/perl5/site_perl/HTTP/Message.pm
{
package HTTP::Message;

use strict;
use vars qw($VERSION $AUTOLOAD);
$VERSION = "5.837";

require Carp;

my $CRLF = "\015\012";   # "\r\n" is not portable
$HTTP::URI_CLASS ||= $ENV{PERL_HTTP_URI_CLASS} || "URI";
eval "require $HTTP::URI_CLASS"; die $@ if $@;

*_utf8_downgrade = defined(&utf8::downgrade) ?
    sub {
        utf8::downgrade($_[0], 1) or
            Carp::croak("HTTP::Message content must be bytes")
    }
    :
    sub {
    };

sub new
{
    my($class, $header, $content) = @_;
    if (defined $header) {
	Carp::croak("Bad header argument") unless ref $header;
        if (ref($header) eq "ARRAY") {
	    $header = HTTP::Headers->new(@$header);
	}
	else {
	    $header = $header->clone;
	}
    }
    else {
	$header = HTTP::Headers->new;
    }
    if (defined $content) {
        _utf8_downgrade($content);
    }
    else {
        $content = '';
    }

    bless {
	'_headers' => $header,
	'_content' => $content,
    }, $class;
}


sub parse
{
    my($class, $str) = @_;

    my @hdr;
    while (1) {
	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
	    push(@hdr, $1, $2);
	    $hdr[-1] =~ s/\r\z//;
	}
	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
	    $hdr[-1] .= "\n$1";
	    $hdr[-1] =~ s/\r\z//;
	}
	else {
	    $str =~ s/^\r?\n//;
	    last;
	}
    }
    local $HTTP::Headers::TRANSLATE_UNDERSCORE;
    new($class, \@hdr, $str);
}


sub clone
{
    my $self  = shift;
    my $clone = HTTP::Message->new($self->headers,
				   $self->content);
    $clone->protocol($self->protocol);
    $clone;
}


sub clear {
    my $self = shift;
    $self->{_headers}->clear;
    $self->content("");
    delete $self->{_parts};
    return;
}


sub protocol {
    shift->_elem('_protocol',  @_);
}

sub headers {
    my $self = shift;

    $self->_content unless exists $self->{_content};

    $self->{_headers};
}

sub headers_as_string {
    shift->headers->as_string(@_);
}


sub content  {

    my $self = $_[0];
    if (defined(wantarray)) {
	$self->_content unless exists $self->{_content};
	my $old = $self->{_content};
	$old = $$old if ref($old) eq "SCALAR";
	&_set_content if @_ > 1;
	return $old;
    }

    if (@_ > 1) {
	&_set_content;
    }
    else {
	Carp::carp("Useless content call in void context") if $^W;
    }
}


sub _set_content {
    my $self = $_[0];
    _utf8_downgrade($_[1]);
    if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
	${$self->{_content}} = $_[1];
    }
    else {
	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
	$self->{_content} = $_[1];
	delete $self->{_content_ref};
    }
    delete $self->{_parts} unless $_[2];
}


sub add_content
{
    my $self = shift;
    $self->_content unless exists $self->{_content};
    my $chunkref = \$_[0];
    $chunkref = $$chunkref if ref($$chunkref);  # legacy

    _utf8_downgrade($$chunkref);

    my $ref = ref($self->{_content});
    if (!$ref) {
	$self->{_content} .= $$chunkref;
    }
    elsif ($ref eq "SCALAR") {
	${$self->{_content}} .= $$chunkref;
    }
    else {
	Carp::croak("Can't append to $ref content");
    }
    delete $self->{_parts};
}

sub add_content_utf8 {
    my($self, $buf)  = @_;
    utf8::upgrade($buf);
    utf8::encode($buf);
    $self->add_content($buf);
}

sub content_ref
{
    my $self = shift;
    $self->_content unless exists $self->{_content};
    delete $self->{_parts};
    my $old = \$self->{_content};
    my $old_cref = $self->{_content_ref};
    if (@_) {
	my $new = shift;
	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
	delete $self->{_content};  # avoid modifying $$old
	$self->{_content} = $new;
	$self->{_content_ref}++;
    }
    $old = $$old if $old_cref;
    return $old;
}


sub content_charset
{
    my $self = shift;
    if (my $charset = $self->content_type_charset) {
	return $charset;
    }

    my $cref = $self->decoded_content(ref => 1, charset => "none");

    for ($$cref) {
	return "UTF-8"     if /^\xEF\xBB\xBF/;
	return "UTF-32-LE" if /^\xFF\xFE\x00\x00/;
	return "UTF-32-BE" if /^\x00\x00\xFE\xFF/;
	return "UTF-16-LE" if /^\xFF\xFE/;
	return "UTF-16-BE" if /^\xFE\xFF/;
    }

    if ($self->content_is_xml) {
	for ($$cref) {
	    return "UTF-32-BE" if /^\x00\x00\x00</;
	    return "UTF-32-LE" if /^<\x00\x00\x00/;
	    return "UTF-16-BE" if /^(?:\x00\s)*\x00</;
	    return "UTF-16-LE" if /^(?:\s\x00)*<\x00/;
	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
		    my $enc = $2;
		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
		    return $enc if $enc;
		}
	    }
	}
	return "UTF-8";
    }
    elsif ($self->content_is_html) {
	my $charset;
	require HTML::Parser;
	my $p = HTML::Parser->new(
	    start_h => [sub {
		my($tag, $attr, $self) = @_;
		$charset = $attr->{charset};
		unless ($charset) {
		    if (my $c = $attr->{content}) {
			require HTTP::Headers::Util;
			my @v = HTTP::Headers::Util::split_header_words($c);
			return unless @v;
			my($ct, undef, %ct_param) = @{$v[0]};
			$charset = $ct_param{charset};
		    }
		    return unless $charset;
		}
		if ($charset =~ /^utf-?16/i) {
		    $charset = "UTF-8";
		}
		$self->eof;
	    }, "tagname, attr, self"],
	    report_tags => [qw(meta)],
	    utf8_mode => 1,
	);
	$p->parse($$cref);
	return $charset if $charset;
    }
    if ($self->content_type =~ /^text\//) {
	for ($$cref) {
	    if (length) {
		return "US-ASCII" unless /[\x80-\xFF]/;
		require Encode;
		eval {
		    Encode::decode_utf8($_, Encode::FB_CROAK() | Encode::LEAVE_SRC());
		};
		return "UTF-8" unless $@;
		return "ISO-8859-1";
	    }
	}
    }

    return undef;
}


sub decoded_content
{
    my($self, %opt) = @_;
    my $content_ref;
    my $content_ref_iscopy;

    eval {
	$content_ref = $self->content_ref;
	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";

	if (my $h = $self->header("Content-Encoding")) {
	    $h =~ s/^\s+//;
	    $h =~ s/\s+$//;
	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
		next unless $ce;
		next if $ce eq "identity";
		if ($ce eq "gzip" || $ce eq "x-gzip") {
		    require IO::Uncompress::Gunzip;
		    my $output;
		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
		    $content_ref = \$output;
		    $content_ref_iscopy++;
		}
		elsif ($ce eq "x-bzip2") {
		    require IO::Uncompress::Bunzip2;
		    my $output;
		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
		    $content_ref = \$output;
		    $content_ref_iscopy++;
		}
		elsif ($ce eq "deflate") {
		    require IO::Uncompress::Inflate;
		    my $output;
		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
		    my $error = $IO::Uncompress::Inflate::InflateError;
		    unless ($status) {
			$output = undef;
			require IO::Uncompress::RawInflate;
			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
			    $self->push_header("Client-Warning" =>
				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
			    $output = undef;
			}
		    }
		    die "Can't inflate content: $error" unless defined $output;
		    $content_ref = \$output;
		    $content_ref_iscopy++;
		}
		elsif ($ce eq "compress" || $ce eq "x-compress") {
		    die "Can't uncompress content";
		}
		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
		    require MIME::Base64;
		    $content_ref = \MIME::Base64::decode($$content_ref);
		    $content_ref_iscopy++;
		}
		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
		    require MIME::QuotedPrint;
		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
		    $content_ref_iscopy++;
		}
		else {
		    die "Don't know how to decode Content-Encoding '$ce'";
		}
	    }
	}

	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
	    my $charset = lc(
	        $opt{charset} ||
		$self->content_type_charset ||
		$opt{default_charset} ||
		$self->content_charset ||
		"ISO-8859-1"
	    );
	    unless ($charset =~ /^(?:none|us-ascii|iso-8859-1)\z/) {
		require Encode;
		if (do{my $v = $Encode::VERSION; $v =~ s/_//g; $v} < 2.0901 &&
		    !$content_ref_iscopy)
		{
		    my $copy = $$content_ref;
		    $content_ref = \$copy;
		    $content_ref_iscopy++;
		}
		eval {
		    $content_ref = \Encode::decode($charset, $$content_ref,
			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
		};
		if ($@) {
		    my $retried;
		    if ($@ =~ /^Unknown encoding/) {
			my $alt_charset = lc($opt{alt_charset} || "");
			if ($alt_charset && $charset ne $alt_charset) {
			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
			        unless $alt_charset =~ /^(?:none|us-ascii|iso-8859-1)\z/;
			    $retried++;
			}
		    }
		    die unless $retried;
		}
		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
		if ($is_xml) {
		    $$content_ref =~ s/^\x{FEFF}//;
		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
		    }
		}
	    }
	}
    };
    if ($@) {
	Carp::croak($@) if $opt{raise_error};
	return undef;
    }

    return $opt{ref} ? $content_ref : $$content_ref;
}


sub decodable
{
    my $self = shift;
    my @enc;
    eval {
        require IO::Uncompress::Gunzip;
        push(@enc, "gzip", "x-gzip");
    };
    eval {
        require IO::Uncompress::Inflate;
        require IO::Uncompress::RawInflate;
        push(@enc, "deflate");
    };
    eval {
        require IO::Uncompress::Bunzip2;
        push(@enc, "x-bzip2");
    };
    return wantarray ? @enc : join(", ", @enc);
}


sub decode
{
    my $self = shift;
    return 1 unless $self->header("Content-Encoding");
    if (defined(my $content = $self->decoded_content(charset => "none"))) {
	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
	$self->content($content);
	return 1;
    }
    return 0;
}


sub encode
{
    my($self, @enc) = @_;

    Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
    Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;

    return 1 unless @enc;  # nothing to do

    my $content = $self->content;
    for my $encoding (@enc) {
	if ($encoding eq "identity") {
	}
	elsif ($encoding eq "base64") {
	    require MIME::Base64;
	    $content = MIME::Base64::encode($content);
	}
	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
	    require IO::Compress::Gzip;
	    my $output;
	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
	    $content = $output;
	}
	elsif ($encoding eq "deflate") {
	    require IO::Compress::Deflate;
	    my $output;
	    IO::Compress::Deflate::deflate(\$content, \$output)
		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
	    $content = $output;
	}
	elsif ($encoding eq "x-bzip2") {
	    require IO::Compress::Bzip2;
	    my $output;
	    IO::Compress::Bzip2::bzip2(\$content, \$output)
		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
	    $content = $output;
	}
	elsif ($encoding eq "rot13") {  # for the fun of it
	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
	}
	else {
	    return 0;
	}
    }
    my $h = $self->header("Content-Encoding");
    unshift(@enc, $h) if $h;
    $self->header("Content-Encoding", join(", ", @enc));
    $self->remove_header("Content-Length", "Content-MD5");
    $self->content($content);
    return 1;
}


sub as_string
{
    my($self, $eol) = @_;
    $eol = "\n" unless defined $eol;

    my $content = $self->content;

    return join("", $self->{'_headers'}->as_string($eol),
		    $eol,
		    $content,
		    (@_ == 1 && length($content) &&
		     $content !~ /\n\z/) ? "\n" : "",
		);
}


sub dump
{
    my($self, %opt) = @_;
    my $content = $self->content;
    my $chopped = 0;
    if (!ref($content)) {
	my $maxlen = $opt{maxlength};
	$maxlen = 512 unless defined($maxlen);
	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
	    $chopped = length($content) - $maxlen;
	    $content = substr($content, 0, $maxlen) . "...";
	}

	$content =~ s/\\/\\\\/g;
	$content =~ s/\t/\\t/g;
	$content =~ s/\r/\\r/g;

	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;

	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;

	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
	$content =~ s/\n\z/\\n/;

	my $no_content = "(no content)";
	if ($content eq $no_content) {
	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
	}
	elsif ($content eq "") {
	    $content = "(no content)";
	}
    }

    my @dump;
    push(@dump, $opt{preheader}) if $opt{preheader};
    push(@dump, $self->{_headers}->as_string, $content);
    push(@dump, "(+ $chopped more bytes not shown)") if $chopped;

    my $dump = join("\n", @dump, "");
    $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};

    print $dump unless defined wantarray;
    return $dump;
}


sub parts {
    my $self = shift;
    if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
	$self->_parts;
    }
    my $old = $self->{_parts};
    if (@_) {
	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
	my $ct = $self->content_type || "";
	if ($ct =~ m,^message/,) {
	    Carp::croak("Only one part allowed for $ct content")
		if @parts > 1;
	}
	elsif ($ct !~ m,^multipart/,) {
	    $self->remove_content_headers;
	    $self->content_type("multipart/mixed");
	}
	$self->{_parts} = \@parts;
	_stale_content($self);
    }
    return @$old if wantarray;
    return $old->[0];
}

sub add_part {
    my $self = shift;
    if (($self->content_type || "") !~ m,^multipart/,) {
	my $p = HTTP::Message->new($self->remove_content_headers,
				   $self->content(""));
	$self->content_type("multipart/mixed");
	$self->{_parts} = [];
        if ($p->headers->header_field_names || $p->content ne "") {
            push(@{$self->{_parts}}, $p);
        }
    }
    elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
	$self->_parts;
    }

    push(@{$self->{_parts}}, @_);
    _stale_content($self);
    return;
}

sub _stale_content {
    my $self = shift;
    if (ref($self->{_content}) eq "SCALAR") {
	$self->_content;
    }
    else {
	delete $self->{_content};
	delete $self->{_content_ref};
    }
}


sub AUTOLOAD
{
    my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);

    no strict 'refs';
    *$method = sub { shift->headers->$method(@_) };
    goto &$method;
}


sub DESTROY {}  # avoid AUTOLOADing it


sub _elem
{
    my $self = shift;
    my $elem = shift;
    my $old = $self->{$elem};
    $self->{$elem} = $_[0] if @_;
    return $old;
}


sub _parts {
    my $self = shift;
    my $ct = $self->content_type;
    if ($ct =~ m,^multipart/,) {
	require HTTP::Headers::Util;
	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
	die "Assert" unless @h;
	my %h = @{$h[0]};
	if (defined(my $b = $h{boundary})) {
	    my $str = $self->content;
	    $str =~ s/\r?\n--\Q$b\E--\r?\n.*//s;
	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
		$self->{_parts} = [map HTTP::Message->parse($_),
				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
	    }
	}
    }
    elsif ($ct eq "message/http") {
	require HTTP::Request;
	require HTTP::Response;
	my $content = $self->content;
	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
	    "HTTP::Response" : "HTTP::Request";
	$self->{_parts} = [$class->parse($content)];
    }
    elsif ($ct =~ m,^message/,) {
	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
    }

    $self->{_parts} ||= [];
}


sub _content {
    my $self = shift;
    my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
    if ($ct =~ m,^\s*message/,i) {
	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
	return;
    }

    require HTTP::Headers::Util;
    my @v = HTTP::Headers::Util::split_header_words($ct);
    Carp::carp("Multiple Content-Type headers") if @v > 1;
    @v = @{$v[0]};

    my $boundary;
    my $boundary_index;
    for (my @tmp = @v; @tmp;) {
	my($k, $v) = splice(@tmp, 0, 2);
	if ($k eq "boundary") {
	    $boundary = $v;
	    $boundary_index = @v - @tmp - 1;
	    last;
	}
    }

    my @parts = map $_->as_string($CRLF), @{$self->{_parts}};

    my $bno = 0;
    $boundary = _boundary() unless defined $boundary;
 CHECK_BOUNDARY:
    {
	for (@parts) {
	    if (index($_, $boundary) >= 0) {
		$boundary = _boundary(++$bno);
		redo CHECK_BOUNDARY;
	    }
	}
    }

    if ($boundary_index) {
	$v[$boundary_index] = $boundary;
    }
    else {
	push(@v, boundary => $boundary);
    }

    $ct = HTTP::Headers::Util::join_header_words(@v);
    $self->{_headers}->header("Content-Type", $ct);

    _set_content($self, "--$boundary$CRLF" .
	                join("$CRLF--$boundary$CRLF", @parts) .
			"$CRLF--$boundary--$CRLF",
                        1);
}


sub _boundary
{
    my $size = shift || return "xYzZY";
    require MIME::Base64;
    my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
    $b =~ s/[\W]/X/g;  # ensure alnum only
    $b;
}


1;


}
##} /usr/local/libdata/perl5/site_perl/HTTP/Message.pm
##{ /usr/local/libdata/perl5/site_perl/HTTP/Request.pm
{
package HTTP::Request;

@ISA = qw(HTTP::Message);
$VERSION = "5.827";

use strict;



sub new
{
    my($class, $method, $uri, $header, $content) = @_;
    my $self = $class->SUPER::new($header, $content);
    $self->method($method);
    $self->uri($uri);
    $self;
}


sub parse
{
    my($class, $str) = @_;
    my $request_line;
    if ($str =~ s/^(.*)\n//) {
	$request_line = $1;
    }
    else {
	$request_line = $str;
	$str = "";
    }

    my $self = $class->SUPER::parse($str);
    my($method, $uri, $protocol) = split(' ', $request_line);
    $self->method($method) if defined($method);
    $self->uri($uri) if defined($uri);
    $self->protocol($protocol) if $protocol;
    $self;
}


sub clone
{
    my $self = shift;
    my $clone = bless $self->SUPER::clone, ref($self);
    $clone->method($self->method);
    $clone->uri($self->uri);
    $clone;
}


sub method
{
    shift->_elem('_method', @_);
}


sub uri
{
    my $self = shift;
    my $old = $self->{'_uri'};
    if (@_) {
	my $uri = shift;
	if (!defined $uri) {
	}
	elsif (ref $uri) {
	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
		unless $uri->can('scheme');
	    $uri = $uri->clone;
	    unless ($HTTP::URI_CLASS eq "URI") {
		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
		die $@ if $@ && $@ !~ /Missing base argument/;
	    }
	}
	else {
	    $uri = $HTTP::URI_CLASS->new($uri);
	}
	$self->{'_uri'} = $uri;
        delete $self->{'_uri_canonical'};
    }
    $old;
}

*url = \&uri;  # legacy

sub uri_canonical
{
    my $self = shift;
    return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
}


sub accept_decodable
{
    my $self = shift;
    $self->header("Accept-Encoding", scalar($self->decodable));
}

sub as_string
{
    my $self = shift;
    my($eol) = @_;
    $eol = "\n" unless defined $eol;

    my $req_line = $self->method || "-";
    my $uri = $self->uri;
    $uri = (defined $uri) ? $uri->as_string : "-";
    $req_line .= " $uri";
    my $proto = $self->protocol;
    $req_line .= " $proto" if $proto;

    return join($eol, $req_line, $self->SUPER::as_string(@_));
}

sub dump
{
    my $self = shift;
    my @pre = ($self->method || "-", $self->uri || "-");
    if (my $prot = $self->protocol) {
	push(@pre, $prot);
    }

    return $self->SUPER::dump(
        preheader => join(" ", @pre),
	@_,
    );
}


1;

}
##} /usr/local/libdata/perl5/site_perl/HTTP/Request.pm
##{ /usr/local/libdata/perl5/site_perl/HTTP/Request/Common.pm
{
package HTTP::Request::Common;

use strict;
use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);

$DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)

require Exporter;
*import = \&Exporter::import;
@EXPORT =qw(GET HEAD PUT POST);
@EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);

use Carp();

$VERSION = "5.824";

my $CRLF = "\015\012";   # "\r\n" is not portable

sub GET  { _simple_req('GET',  @_); }
sub HEAD { _simple_req('HEAD', @_); }
sub PUT  { _simple_req('PUT' , @_); }
sub DELETE { _simple_req('DELETE', @_); }

sub POST
{
    my $url = shift;
    my $req = HTTP::Request->new(POST => $url);
    my $content;
    $content = shift if @_ and ref $_[0];
    my($k, $v);
    while (($k,$v) = splice(@_, 0, 2)) {
	if (lc($k) eq 'content') {
	    $content = $v;
	}
	else {
	    $req->push_header($k, $v);
	}
    }
    my $ct = $req->header('Content-Type');
    unless ($ct) {
	$ct = 'application/x-www-form-urlencoded';
    }
    elsif ($ct eq 'form-data') {
	$ct = 'multipart/form-data';
    }

    if (ref $content) {
	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
	    require HTTP::Headers::Util;
	    my @v = HTTP::Headers::Util::split_header_words($ct);
	    Carp::carp("Multiple Content-Type headers") if @v > 1;
	    @v = @{$v[0]};

	    my $boundary;
	    my $boundary_index;
	    for (my @tmp = @v; @tmp;) {
		my($k, $v) = splice(@tmp, 0, 2);
		if ($k eq "boundary") {
		    $boundary = $v;
		    $boundary_index = @v - @tmp - 1;
		    last;
		}
	    }

	    ($content, $boundary) = form_data($content, $boundary, $req);

	    if ($boundary_index) {
		$v[$boundary_index] = $boundary;
	    }
	    else {
		push(@v, boundary => $boundary);
	    }

	    $ct = HTTP::Headers::Util::join_header_words(@v);
	}
	else {
	    require URI;
	    my $url = URI->new('http:');
	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
	    $content = $url->query;
	}
    }

    $req->header('Content-Type' => $ct);  # might be redundant
    if (defined($content)) {
	$req->header('Content-Length' =>
		     length($content)) unless ref($content);
	$req->content($content);
    }
    else {
        $req->header('Content-Length' => 0);
    }
    $req;
}


sub _simple_req
{
    my($method, $url) = splice(@_, 0, 2);
    my $req = HTTP::Request->new($method => $url);
    my($k, $v);
    my $content;
    while (($k,$v) = splice(@_, 0, 2)) {
	if (lc($k) eq 'content') {
	    $req->add_content($v);
            $content++;
	}
	else {
	    $req->push_header($k, $v);
	}
    }
    if ($content && !defined($req->header("Content-Length"))) {
        $req->header("Content-Length", length(${$req->content_ref}));
    }
    $req;
}


sub form_data   # RFC1867
{
    my($data, $boundary, $req) = @_;
    my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
    my $fhparts;
    my @parts;
    my($k,$v);
    while (($k,$v) = splice(@data, 0, 2)) {
	if (!ref($v)) {
	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
	    push(@parts,
		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
	}
	else {
	    my($file, $usename, @headers) = @$v;
	    unless (defined $usename) {
		$usename = $file;
		$usename =~ s,.*/,, if defined($usename);
	    }
            $k =~ s/([\\\"])/\\$1/g;
	    my $disp = qq(form-data; name="$k");
            if (defined($usename) and length($usename)) {
                $usename =~ s/([\\\"])/\\$1/g;
                $disp .= qq(; filename="$usename");
            }
	    my $content = "";
	    my $h = HTTP::Headers->new(@headers);
	    if ($file) {
		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
		binmode($fh);
		if ($DYNAMIC_FILE_UPLOAD) {
                    close($fh);
		    $content = \$file;
		}
		else {
		    local($/) = undef; # slurp files
		    $content = <$fh>;
		    close($fh);
		}
		unless ($h->header("Content-Type")) {
		    require LWP::MediaTypes;
		    LWP::MediaTypes::guess_media_type($file, $h);
		}
	    }
	    if ($h->header("Content-Disposition")) {
		$disp = $h->header("Content-Disposition");
		$h->remove_header("Content-Disposition");
	    }
	    if ($h->header("Content")) {
		$content = $h->header("Content");
		$h->remove_header("Content");
	    }
	    my $head = join($CRLF, "Content-Disposition: $disp",
			           $h->as_string($CRLF),
			           "");
	    if (ref $content) {
		push(@parts, [$head, $$content]);
		$fhparts++;
	    }
	    else {
		push(@parts, $head . $content);
	    }
	}
    }
    return ("", "none") unless @parts;

    my $content;
    if ($fhparts) {
	$boundary = boundary(10) # hopefully enough randomness
	    unless $boundary;

	for (1..@parts-1) {
	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
	}
	unshift(@parts, "--$boundary$CRLF");
	push(@parts, "$CRLF--$boundary--$CRLF");

	my $length = 0;
	for (@parts) {
	    if (ref $_) {
	 	my ($head, $f) = @$_;
		my $file_size;
		unless ( -f $f && ($file_size = -s _) ) {
		    undef $length;
		    last;
		}
	    	$length += $file_size + length $head;
	    }
	    else {
		$length += length;
	    }
        }
        $length && $req->header('Content-Length' => $length);

	$content = sub {
	    for (;;) {
		unless (@parts) {
		    defined $length && $length != 0 &&
		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
		    return;
		}
		my $p = shift @parts;
		unless (ref $p) {
		    $p .= shift @parts while @parts && !ref($parts[0]);
		    defined $length && ($length -= length $p);
		    return $p;
		}
		my($buf, $fh) = @$p;
                unless (ref($fh)) {
                    my $file = $fh;
                    undef($fh);
                    open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                    binmode($fh);
                }
		my $buflength = length $buf;
		my $n = read($fh, $buf, 2048, $buflength);
		if ($n) {
		    $buflength += $n;
		    unshift(@parts, ["", $fh]);
		}
		else {
		    close($fh);
		}
		if ($buflength) {
		    defined $length && ($length -= $buflength);
		    return $buf 
	    	}
	    }
	};

    }
    else {
	$boundary = boundary() unless $boundary;

	my $bno = 0;
      CHECK_BOUNDARY:
	{
	    for (@parts) {
		if (index($_, $boundary) >= 0) {
		    $boundary = boundary(++$bno);
		    redo CHECK_BOUNDARY;
		}
	    }
	    last;
	}
	$content = "--$boundary$CRLF" .
	           join("$CRLF--$boundary$CRLF", @parts) .
		   "$CRLF--$boundary--$CRLF";
    }

    wantarray ? ($content, $boundary) : $content;
}


sub boundary
{
    my $size = shift || return "xYzZY";
    require MIME::Base64;
    my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
    $b =~ s/[\W]/X/g;  # ensure alnum only
    $b;
}

1;

}
##} /usr/local/libdata/perl5/site_perl/HTTP/Request/Common.pm
BEGIN { $INC{'LWP/Protocol/http.pm'}++; }
BEGIN { $INC{'HTTP/Response.pm'}++; }
BEGIN { $INC{'HTTP/Status.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTTP/Status.pm
{
package HTTP::Status;

use strict;
require 5.002;   # because we use prototypes

use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);

require Exporter;
@ISA = qw(Exporter);
@EXPORT = qw(is_info is_success is_redirect is_error status_message);
@EXPORT_OK = qw(is_client_error is_server_error);
$VERSION = "5.817";



my %StatusCode = (
    100 => 'Continue',
    101 => 'Switching Protocols',
    102 => 'Processing',                      # RFC 2518 (WebDAV)
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Timeout',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Large',
    415 => 'Unsupported Media Type',
    416 => 'Request Range Not Satisfiable',
    417 => 'Expectation Failed',
    422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
    423 => 'Locked',                          # RFC 2518 (WebDAV)
    424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
    425 => 'No code',                         # WebDAV Advanced Collections
    426 => 'Upgrade Required',                # RFC 2817
    449 => 'Retry with',                      # unofficial Microsoft
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Timeout',
    505 => 'HTTP Version Not Supported',
    506 => 'Variant Also Negotiates',         # RFC 2295
    507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
    509 => 'Bandwidth Limit Exceeded',        # unofficial
    510 => 'Not Extended',                    # RFC 2774
);

my $mnemonicCode = '';
my ($code, $message);
while (($code, $message) = each %StatusCode) {
    $message =~ tr/a-z \-/A-Z__/;
    $mnemonicCode .= "sub HTTP_$message () { $code }\n";
    $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
    $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
    $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
}
eval $mnemonicCode; # only one eval for speed
die if $@;

*RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
push(@EXPORT, "RC_MOVED_TEMPORARILY");

%EXPORT_TAGS = (
   constants => [grep /^HTTP_/, @EXPORT_OK],
   is => [grep /^is_/, @EXPORT, @EXPORT_OK],
);


sub status_message  ($) { $StatusCode{$_[0]}; }

sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }

1;


}
##} /usr/local/libdata/perl5/site_perl/HTTP/Status.pm
##{ /usr/local/libdata/perl5/site_perl/HTTP/Response.pm
{
package HTTP::Response;

@ISA = qw(HTTP::Message);
$VERSION = "5.836";

use strict;



sub new
{
    my($class, $rc, $msg, $header, $content) = @_;
    my $self = $class->SUPER::new($header, $content);
    $self->code($rc);
    $self->message($msg);
    $self;
}


sub parse
{
    my($class, $str) = @_;
    my $status_line;
    if ($str =~ s/^(.*)\n//) {
	$status_line = $1;
    }
    else {
	$status_line = $str;
	$str = "";
    }

    my $self = $class->SUPER::parse($str);
    my($protocol, $code, $message);
    if ($status_line =~ /^\d{3} /) {
       ($code, $message) = split(' ', $status_line, 2);
    } else {
       ($protocol, $code, $message) = split(' ', $status_line, 3);
    }
    $self->protocol($protocol) if $protocol;
    $self->code($code) if defined($code);
    $self->message($message) if defined($message);
    $self;
}


sub clone
{
    my $self = shift;
    my $clone = bless $self->SUPER::clone, ref($self);
    $clone->code($self->code);
    $clone->message($self->message);
    $clone->request($self->request->clone) if $self->request;
    $clone;
}


sub code      { shift->_elem('_rc',      @_); }
sub message   { shift->_elem('_msg',     @_); }
sub previous  { shift->_elem('_previous',@_); }
sub request   { shift->_elem('_request', @_); }


sub status_line
{
    my $self = shift;
    my $code = $self->{'_rc'}  || "000";
    my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
    return "$code $mess";
}


sub base
{
    my $self = shift;
    my $base = (
	$self->header('Content-Base'),        # used to be HTTP/1.1
	$self->header('Content-Location'),    # HTTP/1.1
	$self->header('Base'),                # HTTP/1.0
    )[0];
    if ($base && $base =~ /^$URI::scheme_re:/o) {
	return $HTTP::URI_CLASS->new($base);
    }

    my $req = $self->request;
    if ($req) {
        return $HTTP::URI_CLASS->new_abs($base, $req->uri);
    }

    return undef;
}


sub redirects {
    my $self = shift;
    my @r;
    my $r = $self;
    while (my $p = $r->previous) {
        push(@r, $p);
        $r = $p;
    }
    return @r unless wantarray;
    return reverse @r;
}


sub filename
{
    my $self = shift;
    my $file;

    my $cd = $self->header('Content-Disposition');
    if ($cd) {
	require HTTP::Headers::Util;
	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
	    $file = $cd_param{filename};

	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
		my $charset = $1;
		my $encoding = uc($2);
		my $encfile = $3;

		if ($encoding eq 'Q' || $encoding eq 'B') {
		    local($SIG{__DIE__});
		    eval {
			if ($encoding eq 'Q') {
			    $encfile =~ s/_/ /g;
			    require MIME::QuotedPrint;
			    $encfile = MIME::QuotedPrint::decode($encfile);
			}
			else { # $encoding eq 'B'
			    require MIME::Base64;
			    $encfile = MIME::Base64::decode($encfile);
			}

			require Encode;
			require encoding;
			my $locale_charset = encoding::_get_locale_encoding();
			Encode::from_to($encfile, $charset, $locale_charset);
		    };

		    $file = $encfile unless $@;
		}
	    }
	}
    }

    unless (defined($file) && length($file)) {
	my $uri;
	if (my $cl = $self->header('Content-Location')) {
	    $uri = URI->new($cl);
	}
	elsif (my $request = $self->request) {
	    $uri = $request->uri;
	}

	if ($uri) {
	    $file = ($uri->path_segments)[-1];
	}
    }

    if ($file) {
	$file =~ s,.*[\\/],,;  # basename
    }

    if ($file && !length($file)) {
	$file = undef;
    }

    $file;
}


sub as_string
{
    require HTTP::Status;
    my $self = shift;
    my($eol) = @_;
    $eol = "\n" unless defined $eol;

    my $status_line = $self->status_line;
    my $proto = $self->protocol;
    $status_line = "$proto $status_line" if $proto;

    return join($eol, $status_line, $self->SUPER::as_string(@_));
}


sub dump
{
    my $self = shift;

    my $status_line = $self->status_line;
    my $proto = $self->protocol;
    $status_line = "$proto $status_line" if $proto;

    return $self->SUPER::dump(
	preheader => $status_line,
        @_,
    );
}


sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }


sub error_as_HTML
{
    require HTML::Entities;
    my $self = shift;
    my $title = 'An Error Occurred';
    my $body  = HTML::Entities::encode($self->status_line);
    return <<EOM;
<html>
<head><title>$title</title></head>
<body>
<h1>$title</h1>
<p>$body</p>
</body>
</html>
EOM
}


sub current_age
{
    my $self = shift;
    my $time = shift;

    my $response_time = $self->client_date;
    my $date = $self->date;

    my $age = 0;
    if ($response_time && $date) {
	$age = $response_time - $date;  # apparent_age
	$age = 0 if $age < 0;
    }

    my $age_v = $self->header('Age');
    if ($age_v && $age_v > $age) {
	$age = $age_v;   # corrected_received_age
    }

    if ($response_time) {
	my $request = $self->request;
	if ($request) {
	    my $request_time = $request->date;
	    if ($request_time && $request_time < $response_time) {
		$age += $response_time - $request_time;
	    }
	}
	$age += ($time || time) - $response_time;
    }
    return $age;
}


sub freshness_lifetime
{
    my($self, %opt) = @_;

    for my $cc ($self->header('Cache-Control')) {
	for my $cc_dir (split(/\s*,\s*/, $cc)) {
	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
	}
    }

    my $date = $self->date || $self->client_date || $opt{time} || time;
    if (my $expires = $self->expires) {
	return $expires - $date;
    }

    return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};

    $opt{h_min} ||= 60;
    $opt{h_max} ||= 24 * 3600;
    $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
    $opt{h_default} ||= 3600;


    if (my $last_modified = $self->last_modified) {
	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
	return $opt{h_min} if $h_exp < $opt{h_min};
	return $opt{h_max} if $h_exp > $opt{h_max};
	return $h_exp;
    }

    return $opt{h_min} if $opt{h_min} > $opt{h_default};
    return $opt{h_default};
}


sub is_fresh
{
    my($self, %opt) = @_;
    $opt{time} ||= time;
    my $f = $self->freshness_lifetime(%opt);
    return undef unless defined($f);
    return $f > $self->current_age($opt{time});
}


sub fresh_until
{
    my($self, %opt) = @_;
    $opt{time} ||= time;
    my $f = $self->freshness_lifetime(%opt);
    return undef unless defined($f);
    return $f - $self->current_age($opt{time}) + $opt{time};
}

1;


}
##} /usr/local/libdata/perl5/site_perl/HTTP/Response.pm
BEGIN { $INC{'Net/HTTP.pm'}++; }
BEGIN { $INC{'Net/HTTP/Methods.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/Net/HTTP/Methods.pm
{
package Net::HTTP::Methods;

require 5.005;  # 4-arg substr

use strict;
use vars qw($VERSION);

$VERSION = "5.834";

my $CRLF = "\015\012";   # "\r\n" is not portable

*_bytes = defined(&utf8::downgrade) ?
    sub {
        unless (utf8::downgrade($_[0], 1)) {
            require Carp;
            Carp::croak("Wide character in HTTP request (bytes required)");
        }
        return $_[0];
    }
    :
    sub {
        return $_[0];
    };


sub new {
    my $class = shift;
    unshift(@_, "Host") if @_ == 1;
    my %cnf = @_;
    require Symbol;
    my $self = bless Symbol::gensym(), $class;
    return $self->http_configure(\%cnf);
}

sub http_configure {
    my($self, $cnf) = @_;

    die "Listen option not allowed" if $cnf->{Listen};
    my $explict_host = (exists $cnf->{Host});
    my $host = delete $cnf->{Host};
    my $peer = $cnf->{PeerAddr} || $cnf->{PeerHost};
    if (!$peer) {
	die "No Host option provided" unless $host;
	$cnf->{PeerAddr} = $peer = $host;
    }

    if ($peer =~ s,:(\d+)$,,) {
	$cnf->{PeerPort} = int($1);  # always override
    }
    if (!$cnf->{PeerPort}) {
	$cnf->{PeerPort} = $self->http_default_port;
    }

    if (!$explict_host) {
	$host = $peer;
	$host =~ s/:.*//;
    }
    if ($host && $host !~ /:/) {
	my $p = $cnf->{PeerPort};
	$host .= ":$p" if $p != $self->http_default_port;
    }

    $cnf->{Proto} = 'tcp';

    my $keep_alive = delete $cnf->{KeepAlive};
    my $http_version = delete $cnf->{HTTPVersion};
    $http_version = "1.1" unless defined $http_version;
    my $peer_http_version = delete $cnf->{PeerHTTPVersion};
    $peer_http_version = "1.0" unless defined $peer_http_version;
    my $send_te = delete $cnf->{SendTE};
    my $max_line_length = delete $cnf->{MaxLineLength};
    $max_line_length = 8*1024 unless defined $max_line_length;
    my $max_header_lines = delete $cnf->{MaxHeaderLines};
    $max_header_lines = 128 unless defined $max_header_lines;

    return undef unless $self->http_connect($cnf);

    $self->host($host);
    $self->keep_alive($keep_alive);
    $self->send_te($send_te);
    $self->http_version($http_version);
    $self->peer_http_version($peer_http_version);
    $self->max_line_length($max_line_length);
    $self->max_header_lines($max_header_lines);

    ${*$self}{'http_buf'} = "";

    return $self;
}

sub http_default_port {
    80;
}

for my $method (qw(host keep_alive send_te max_line_length max_header_lines peer_http_version)) {
    my $prop_name = "http_" . $method;
    no strict 'refs';
    *$method = sub {
	my $self = shift;
	my $old = ${*$self}{$prop_name};
	${*$self}{$prop_name} = shift if @_;
	return $old;
    };
}

sub http_version {
    my $self = shift;
    my $old = ${*$self}{'http_version'};
    if (@_) {
	my $v = shift;
	$v = "1.0" if $v eq "1";  # float
	unless ($v eq "1.0" or $v eq "1.1") {
	    require Carp;
	    Carp::croak("Unsupported HTTP version '$v'");
	}
	${*$self}{'http_version'} = $v;
    }
    $old;
}

sub format_request {
    my $self = shift;
    my $method = shift;
    my $uri = shift;

    my $content = (@_ % 2) ? pop : "";

    for ($method, $uri) {
	require Carp;
	Carp::croak("Bad method or uri") if /\s/ || !length;
    }

    push(@{${*$self}{'http_request_method'}}, $method);
    my $ver = ${*$self}{'http_version'};
    my $peer_ver = ${*$self}{'http_peer_http_version'} || "1.0";

    my @h;
    my @connection;
    my %given = (host => 0, "content-length" => 0, "te" => 0);
    while (@_) {
	my($k, $v) = splice(@_, 0, 2);
	my $lc_k = lc($k);
	if ($lc_k eq "connection") {
	    $v =~ s/^\s+//;
	    $v =~ s/\s+$//;
	    push(@connection, split(/\s*,\s*/, $v));
	    next;
	}
	if (exists $given{$lc_k}) {
	    $given{$lc_k}++;
	}
	push(@h, "$k: $v");
    }

    if (length($content) && !$given{'content-length'}) {
	push(@h, "Content-Length: " . length($content));
    }

    my @h2;
    if ($given{te}) {
	push(@connection, "TE") unless grep lc($_) eq "te", @connection;
    }
    elsif ($self->send_te && gunzip_ok()) {
	push(@h2, "TE: deflate,gzip;q=0.3");
	push(@connection, "TE");
    }

    unless (grep lc($_) eq "close", @connection) {
	if ($self->keep_alive) {
	    if ($peer_ver eq "1.0") {
		push(@h2, "Keep-Alive: 300");
		unshift(@connection, "Keep-Alive");
	    }
	}
	else {
	    push(@connection, "close") if $ver ge "1.1";
	}
    }
    push(@h2, "Connection: " . join(", ", @connection)) if @connection;
    unless ($given{host}) {
	my $h = ${*$self}{'http_host'};
	push(@h2, "Host: $h") if $h;
    }

    return _bytes(join($CRLF, "$method $uri HTTP/$ver", @h2, @h, "", $content));
}


sub write_request {
    my $self = shift;
    $self->print($self->format_request(@_));
}

sub format_chunk {
    my $self = shift;
    return $_[0] unless defined($_[0]) && length($_[0]);
    return _bytes(sprintf("%x", length($_[0])) . $CRLF . $_[0] . $CRLF);
}

sub write_chunk {
    my $self = shift;
    return 1 unless defined($_[0]) && length($_[0]);
    $self->print(_bytes(sprintf("%x", length($_[0])) . $CRLF . $_[0] . $CRLF));
}

sub format_chunk_eof {
    my $self = shift;
    my @h;
    while (@_) {
	push(@h, sprintf "%s: %s$CRLF", splice(@_, 0, 2));
    }
    return _bytes(join("", "0$CRLF", @h, $CRLF));
}

sub write_chunk_eof {
    my $self = shift;
    $self->print($self->format_chunk_eof(@_));
}


sub my_read {
    die if @_ > 3;
    my $self = shift;
    my $len = $_[1];
    for (${*$self}{'http_buf'}) {
	if (length) {
	    $_[0] = substr($_, 0, $len, "");
	    return length($_[0]);
	}
	else {
	    return $self->sysread($_[0], $len);
	}
    }
}


sub my_readline {
    my $self = shift;
    my $what = shift;
    for (${*$self}{'http_buf'}) {
	my $max_line_length = ${*$self}{'http_max_line_length'};
	my $pos;
	while (1) {
	    $pos = index($_, "\012");
	    last if $pos >= 0;
	    die "$what line too long (limit is $max_line_length)"
		if $max_line_length && length($_) > $max_line_length;

          READ:
            {
                my $n = $self->sysread($_, 1024, length);
                unless (defined $n) {
                    redo READ if $!{EINTR};
                    if ($!{EAGAIN}) {
                        select(undef, undef, undef, 0.1);  # but this will do for now
                        redo READ;
                    }
                    die "$what read failed: $!" unless length;
                }
                unless ($n) {
                    return undef unless length;
                    return substr($_, 0, length, "");
                }
            }
	}
	die "$what line too long ($pos; limit is $max_line_length)"
	    if $max_line_length && $pos > $max_line_length;

	my $line = substr($_, 0, $pos+1, "");
	$line =~ s/(\015?\012)\z// || die "Assert";
	return wantarray ? ($line, $1) : $line;
    }
}


sub _rbuf {
    my $self = shift;
    if (@_) {
	for (${*$self}{'http_buf'}) {
	    my $old;
	    $old = $_ if defined wantarray;
	    $_ = shift;
	    return $old;
	}
    }
    else {
	return ${*$self}{'http_buf'};
    }
}

sub _rbuf_length {
    my $self = shift;
    return length ${*$self}{'http_buf'};
}


sub _read_header_lines {
    my $self = shift;
    my $junk_out = shift;

    my @headers;
    my $line_count = 0;
    my $max_header_lines = ${*$self}{'http_max_header_lines'};
    while (my $line = my_readline($self, 'Header')) {
	if ($line =~ /^(\S+?)\s*:\s*(.*)/s) {
	    push(@headers, $1, $2);
	}
	elsif (@headers && $line =~ s/^\s+//) {
	    $headers[-1] .= " " . $line;
	}
	elsif ($junk_out) {
	    push(@$junk_out, $line);
	}
	else {
	    die "Bad header: '$line'\n";
	}
	if ($max_header_lines) {
	    $line_count++;
	    if ($line_count >= $max_header_lines) {
		die "Too many header lines (limit is $max_header_lines)";
	    }
	}
    }
    return @headers;
}


sub read_response_headers {
    my($self, %opt) = @_;
    my $laxed = $opt{laxed};

    my($status, $eol) = my_readline($self, 'Status');
    unless (defined $status) {
	die "Server closed connection without sending any data back";
    }

    my($peer_ver, $code, $message) = split(/\s+/, $status, 3);
    if (!$peer_ver || $peer_ver !~ s,^HTTP/,, || $code !~ /^[1-5]\d\d$/) {
	die "Bad response status line: '$status'" unless $laxed;
	${*$self}{'http_peer_http_version'} = "0.9";
	${*$self}{'http_status'} = "200";
	substr(${*$self}{'http_buf'}, 0, 0) = $status . ($eol || "");
	return 200 unless wantarray;
	return (200, "Assumed OK");
    };

    ${*$self}{'http_peer_http_version'} = $peer_ver;
    ${*$self}{'http_status'} = $code;

    my $junk_out;
    if ($laxed) {
	$junk_out = $opt{junk_out} || [];
    }
    my @headers = $self->_read_header_lines($junk_out);

    my @te;
    my $content_length;
    for (my $i = 0; $i < @headers; $i += 2) {
	my $h = lc($headers[$i]);
	if ($h eq 'transfer-encoding') {
	    my $te = $headers[$i+1];
	    $te =~ s/^\s+//;
	    $te =~ s/\s+$//;
	    push(@te, $te) if length($te);
	}
	elsif ($h eq 'content-length') {
	    if ($headers[$i+1] =~ /^\s*(\d{1,15})(?:\s|$)/) {
		$content_length = $1;
	    }
	}
    }
    ${*$self}{'http_te'} = join(",", @te);
    ${*$self}{'http_content_length'} = $content_length;
    ${*$self}{'http_first_body'}++;
    delete ${*$self}{'http_trailers'};
    return $code unless wantarray;
    return ($code, $message, @headers);
}


sub read_entity_body {
    my $self = shift;
    my $buf_ref = \$_[0];
    my $size = $_[1];
    die "Offset not supported yet" if $_[2];

    my $chunked;
    my $bytes;

    if (${*$self}{'http_first_body'}) {
	${*$self}{'http_first_body'} = 0;
	delete ${*$self}{'http_chunked'};
	delete ${*$self}{'http_bytes'};
	my $method = shift(@{${*$self}{'http_request_method'}});
	my $status = ${*$self}{'http_status'};
	if ($method eq "HEAD") {
	    $bytes = 0;
	}
	elsif (my $te = ${*$self}{'http_te'}) {
	    my @te = split(/\s*,\s*/, lc($te));
	    die "Chunked must be last Transfer-Encoding '$te'"
		unless pop(@te) eq "chunked";

	    for (@te) {
		if ($_ eq "deflate" && inflate_ok()) {
		    my ($i, $status) = Compress::Raw::Zlib::Inflate->new();
		    die "Can't make inflator: $status" unless $i;
		    $_ = sub { my $out; $i->inflate($_[0], \$out); $out }
		}
		elsif ($_ eq "gzip" && gunzip_ok()) {
		    my @buf;
		    $_ = sub {
			push(@buf, $_[0]);
			return "" unless $_[1];
			my $input = join("", @buf);
			my $output;
			IO::Uncompress::Gunzip::gunzip(\$input, \$output, Transparent => 0)
			    or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
			return \$output;
		    };
		}
		elsif ($_ eq "identity") {
		    $_ = sub { $_[0] };
		}
		else {
		    die "Can't handle transfer encoding '$te'";
		}
	    }

	    @te = reverse(@te);

	    ${*$self}{'http_te2'} = @te ? \@te : "";
	    $chunked = -1;
	}
	elsif (defined(my $content_length = ${*$self}{'http_content_length'})) {
	    $bytes = $content_length;
	}
        elsif ($status =~ /^(?:1|[23]04)/) {
            $bytes = 0;
        }
	else {

	}
    }
    else {
	$chunked = ${*$self}{'http_chunked'};
	$bytes   = ${*$self}{'http_bytes'};
    }

    if (defined $chunked) {

	if ($chunked <= 0) {
	    my $line = my_readline($self, 'Entity body');
	    if ($chunked == 0) {
		die "Missing newline after chunk data: '$line'"
		    if !defined($line) || $line ne "";
		$line = my_readline($self, 'Entity body');
	    }
	    die "EOF when chunk header expected" unless defined($line);
	    my $chunk_len = $line;
	    $chunk_len =~ s/;.*//;  # ignore potential chunk parameters
	    unless ($chunk_len =~ /^([\da-fA-F]+)\s*$/) {
		die "Bad chunk-size in HTTP response: $line";
	    }
	    $chunked = hex($1);
	    if ($chunked == 0) {
		${*$self}{'http_trailers'} = [$self->_read_header_lines];
		$$buf_ref = "";

		my $n = 0;
		if (my $transforms = delete ${*$self}{'http_te2'}) {
		    for (@$transforms) {
			$$buf_ref = &$_($$buf_ref, 1);
		    }
		    $n = length($$buf_ref);
		}

		delete ${*$self}{'http_chunked'};
		${*$self}{'http_bytes'} = 0;

		return $n;
	    }
	}

	my $n = $chunked;
	$n = $size if $size && $size < $n;
	$n = my_read($self, $$buf_ref, $n);
	return undef unless defined $n;

	${*$self}{'http_chunked'} = $chunked - $n;

	if ($n > 0) {
	    if (my $transforms = ${*$self}{'http_te2'}) {
		for (@$transforms) {
		    $$buf_ref = &$_($$buf_ref, 0);
		}
		$n = length($$buf_ref);
		$n = -1 if $n == 0;
	    }
	}
	return $n;
    }
    elsif (defined $bytes) {
	unless ($bytes) {
	    $$buf_ref = "";
	    return 0;
	}
	my $n = $bytes;
	$n = $size if $size && $size < $n;
	$n = my_read($self, $$buf_ref, $n);
	return undef unless defined $n;
	${*$self}{'http_bytes'} = $bytes - $n;
	return $n;
    }
    else {
	$size ||= 8*1024;
	return my_read($self, $$buf_ref, $size);
    }
}

sub get_trailers {
    my $self = shift;
    @{${*$self}{'http_trailers'} || []};
}

BEGIN {
my $gunzip_ok;
my $inflate_ok;

sub gunzip_ok {
    return $gunzip_ok if defined $gunzip_ok;

    local $@;
    local $SIG{__DIE__};
    $gunzip_ok = 0;

    eval {
	require IO::Uncompress::Gunzip;
	$gunzip_ok++;
    };

    return $gunzip_ok;
}

sub inflate_ok {
    return $inflate_ok if defined $inflate_ok;

    local $@;
    local $SIG{__DIE__};
    $inflate_ok = 0;

    eval {
	require Compress::Raw::Zlib;
	$inflate_ok++;
    };

    return $inflate_ok;
}

} # BEGIN

1;
}
##} /usr/local/libdata/perl5/site_perl/Net/HTTP/Methods.pm
##{ /usr/local/libdata/perl5/site_perl/Net/HTTP.pm
{
package Net::HTTP;

use strict;
use vars qw($VERSION @ISA $SOCKET_CLASS);

$VERSION = "5.834";
unless ($SOCKET_CLASS) {
    eval { require IO::Socket::INET } || require IO::Socket;
    $SOCKET_CLASS = "IO::Socket::INET";
}
require Carp;

@ISA = ($SOCKET_CLASS, 'Net::HTTP::Methods');

sub new {
    my $class = shift;
    Carp::croak("No Host option provided") unless @_;
    $class->SUPER::new(@_);
}

sub configure {
    my($self, $cnf) = @_;
    $self->http_configure($cnf);
}

sub http_connect {
    my($self, $cnf) = @_;
    $self->SUPER::configure($cnf);
}

1;

}
##} /usr/local/libdata/perl5/site_perl/Net/HTTP.pm
BEGIN { $INC{'LWP/Protocol.pm'}++; }
BEGIN { $INC{'LWP/MemberMixin.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/LWP/MemberMixin.pm
{
package LWP::MemberMixin;

sub _elem
{
    my $self = shift;
    my $elem = shift;
    my $old = $self->{$elem};
    $self->{$elem} = shift if @_;
    return $old;
}

1;

}
##} /usr/local/libdata/perl5/site_perl/LWP/MemberMixin.pm
##{ /usr/local/libdata/perl5/site_perl/LWP/Protocol.pm
{
package LWP::Protocol;

@ISA = qw(LWP::MemberMixin);
$VERSION = "5.829";

use strict;
use Carp ();
BEGIN { HTTP::Response->import(); } # (added by utils/combine-perl.pl)

my %ImplementedBy = (); # scheme => classname



sub new
{
    my($class, $scheme, $ua) = @_;

    my $self = bless {
	scheme => $scheme,
	ua => $ua,

        max_size => $ua->{max_size},
    }, $class;

    $self;
}


sub create
{
    my($scheme, $ua) = @_;
    my $impclass = LWP::Protocol::implementor($scheme) or
	Carp::croak("Protocol scheme '$scheme' is not supported");

    my $protocol = $impclass->new($scheme, $ua);

    return $protocol;
}


sub implementor
{
    my($scheme, $impclass) = @_;

    if ($impclass) {
	$ImplementedBy{$scheme} = $impclass;
    }
    my $ic = $ImplementedBy{$scheme};
    return $ic if $ic;

    return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
    $scheme = $1; # untaint
    $scheme =~ s/[.+\-]/_/g;  # make it a legal module name

    $ic = "LWP::Protocol::$scheme";  # default location
    $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
    no strict 'refs';
    unless (@{"${ic}::ISA"}) {
	eval "require $ic";
	if ($@) {
	    if ($@ =~ /Can't locate/) { #' #emacs get confused by '
		$ic = '';
	    }
	    else {
		die "$@\n";
	    }
	}
    }
    $ImplementedBy{$scheme} = $ic if $ic;
    $ic;
}


sub request
{
    my($self, $request, $proxy, $arg, $size, $timeout) = @_;
    Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
}


sub timeout    { shift->_elem('timeout',    @_); }
sub max_size   { shift->_elem('max_size',   @_); }


sub collect
{
    my ($self, $arg, $response, $collector) = @_;
    my $content;
    my($ua, $max_size) = @{$self}{qw(ua max_size)};

    eval {
	local $\; # protect the print below from surprises
        if (!defined($arg) || !$response->is_success) {
            $response->{default_add_content} = 1;
        }
        elsif (!ref($arg) && length($arg)) {
            open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
	    binmode($fh);
            push(@{$response->{handlers}{response_data}}, {
                callback => sub {
                    print $fh $_[3] or die "Can't write to '$arg': $!";
                    1;
                },
            });
            push(@{$response->{handlers}{response_done}}, {
                callback => sub {
		    close($fh) or die "Can't write to '$arg': $!";
		    undef($fh);
		},
	    });
        }
        elsif (ref($arg) eq 'CODE') {
            push(@{$response->{handlers}{response_data}}, {
                callback => sub {
		    &$arg($_[3], $_[0], $self);
		    1;
                },
            });
        }
        else {
            die "Unexpected collect argument '$arg'";
        }

        $ua->run_handlers("response_header", $response);

        if (delete $response->{default_add_content}) {
            push(@{$response->{handlers}{response_data}}, {
		callback => sub {
		    $_[0]->add_content($_[3]);
		    1;
		},
	    });
        }


        my $content_size = 0;
        my $length = $response->content_length;
        my %skip_h;

        while ($content = &$collector, length $$content) {
            for my $h ($ua->handlers("response_data", $response)) {
                next if $skip_h{$h};
                unless ($h->{callback}->($response, $ua, $h, $$content)) {
                    $skip_h{$h}++;
                }
            }
            $content_size += length($$content);
            $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
            if (defined($max_size) && $content_size > $max_size) {
                $response->push_header("Client-Aborted", "max_size");
                last;
            }
        }
    };
    my $err = $@;
    delete $response->{handlers}{response_data};
    delete $response->{handlers} unless %{$response->{handlers}};
    if ($err) {
        chomp($err);
        $response->push_header('X-Died' => $err);
        $response->push_header("Client-Aborted", "die");
        return $response;
    }

    return $response;
}


sub collect_once
{
    my($self, $arg, $response) = @_;
    my $content = \ $_[3];
    my $first = 1;
    $self->collect($arg, $response, sub {
	return $content if $first--;
	return \ "";
    });
}

1;


}
##} /usr/local/libdata/perl5/site_perl/LWP/Protocol.pm
##{ /usr/local/libdata/perl5/site_perl/LWP/Protocol/http.pm
{
package LWP::Protocol::http;

use strict;


use vars qw(@ISA @EXTRA_SOCK_OPTS);

@ISA = qw(LWP::Protocol);

my $CRLF = "\015\012";

sub _new_socket
{
    my($self, $host, $port, $timeout) = @_;
    my $conn_cache = $self->{ua}{conn_cache};
    if ($conn_cache) {
	if (my $sock = $conn_cache->withdraw($self->socket_type, "$host:$port")) {
	    return $sock if $sock && !$sock->can_read(0);
	    $sock->close;
	}
    }

    local($^W) = 0;  # IO::Socket::INET can be noisy
    my $sock = $self->socket_class->new(PeerAddr => $host,
					PeerPort => $port,
					LocalAddr => $self->{ua}{local_address},
					Proto    => 'tcp',
					Timeout  => $timeout,
					KeepAlive => !!$conn_cache,
					SendTE    => 1,
					$self->_extra_sock_opts($host, $port),
				       );

    unless ($sock) {
	$@ =~ s/^.*?: //;
	die "Can't connect to $host:$port ($@)";
    }

    eval { $sock->blocking(0); };

    $sock;
}

sub socket_type
{
    return "http";
}

sub socket_class
{
    my $self = shift;
    (ref($self) || $self) . "::Socket";
}

sub _extra_sock_opts  # to be overridden by subclass
{
    return @EXTRA_SOCK_OPTS;
}

sub _check_sock
{
}

sub _get_sock_info
{
    my($self, $res, $sock) = @_;
    if (defined(my $peerhost = $sock->peerhost)) {
        $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
    }
}

sub _fixup_header
{
    my($self, $h, $url, $proxy) = @_;

    my $hhost = $url->authority;
    if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
	if (defined($1) && not $h->header('Authorization')) {
	    require URI::Escape;
	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
				    split(":", $1, 2));
	}
    }
    $h->init_header('Host' => $hhost);

    if ($proxy) {
	my $p_auth = $proxy->userinfo();
	if(defined $p_auth) {
	    require URI::Escape;
	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
					  split(":", $p_auth, 2))
	}
    }
}

sub hlist_remove {
    my($hlist, $k) = @_;
    $k = lc $k;
    for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
	next unless lc($hlist->[$i]) eq $k;
	splice(@$hlist, $i, 2);
    }
}

sub request
{
    my($self, $request, $proxy, $arg, $size, $timeout) = @_;

    $size ||= 4096;

    my $method = $request->method;
    unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
				  'Library does not allow method ' .
				  "$method for 'http:' URLs");
    }

    my $url = $request->uri;
    my($host, $port, $fullpath);

    if (defined $proxy) {
	$host = $proxy->host;
	$port = $proxy->port;
	$fullpath = $method eq "CONNECT" ?
                       ($url->host . ":" . $url->port) :
                       $url->as_string;
    }
    else {
	$host = $url->host;
	$port = $url->port;
	$fullpath = $url->path_query;
	$fullpath = "/$fullpath" unless $fullpath =~ m,^/,;
    }

    my $socket = $self->_new_socket($host, $port, $timeout);
    $self->_check_sock($request, $socket);

    my @h;
    my $request_headers = $request->headers->clone;
    $self->_fixup_header($request_headers, $url, $proxy);

    $request_headers->scan(sub {
			       my($k, $v) = @_;
			       $k =~ s/^://;
			       $v =~ s/\n/ /g;
			       push(@h, $k, $v);
			   });

    my $content_ref = $request->content_ref;
    $content_ref = $$content_ref if ref($$content_ref);
    my $chunked;
    my $has_content;

    if (ref($content_ref) eq 'CODE') {
	my $clen = $request_headers->header('Content-Length');
	$has_content++ if $clen;
	unless (defined $clen) {
	    push(@h, "Transfer-Encoding" => "chunked");
	    $has_content++;
	    $chunked++;
	}
    }
    else {
	my $clen = $request_headers->header('Content-Length');
	if (defined($$content_ref) && length($$content_ref)) {
	    $has_content = length($$content_ref);
	    if (!defined($clen) || $clen ne $has_content) {
		if (defined $clen) {
		    warn "Content-Length header value was wrong, fixed";
		    hlist_remove(\@h, 'Content-Length');
		}
		push(@h, 'Content-Length' => $has_content);
	    }
	}
	elsif ($clen) {
	    warn "Content-Length set when there is no content, fixed";
	    hlist_remove(\@h, 'Content-Length');
	}
    }

    my $write_wait = 0;
    $write_wait = 2
	if ($request_headers->header("Expect") || "") =~ /100-continue/;

    my $req_buf = $socket->format_request($method, $fullpath, @h);

    if (!$has_content || $write_wait || $has_content > 8*1024) {
      WRITE:
        {
            my $n = $socket->syswrite($req_buf, length($req_buf));
            unless (defined $n) {
                redo WRITE if $!{EINTR};
                if ($!{EAGAIN}) {
                    select(undef, undef, undef, 0.1);
                    redo WRITE;
                }
                die "write failed: $!";
            }
            if ($n) {
                substr($req_buf, 0, $n, "");
            }
            else {
                select(undef, undef, undef, 0.5);
            }
            redo WRITE if length $req_buf;
        }
    }

    my($code, $mess, @junk);
    my $drop_connection;

    if ($has_content) {
	my $eof;
	my $wbuf;
	my $woffset = 0;
	if (ref($content_ref) eq 'CODE') {
	    my $buf = &$content_ref();
	    $buf = "" unless defined($buf);
	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
		if $chunked;
	    substr($buf, 0, 0) = $req_buf if $req_buf;
	    $wbuf = \$buf;
	}
	else {
	    if ($req_buf) {
		my $buf = $req_buf . $$content_ref;
		$wbuf = \$buf;
	    }
	    else {
		$wbuf = $content_ref;
	    }
	    $eof = 1;
	}

	my $fbits = '';
	vec($fbits, fileno($socket), 1) = 1;

      WRITE:
	while ($woffset < length($$wbuf)) {

	    my $sel_timeout = $timeout;
	    if ($write_wait) {
		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
	    }
	    my $time_before;
            $time_before = time if $sel_timeout;

	    my $rbits = $fbits;
	    my $wbits = $write_wait ? undef : $fbits;
            my $sel_timeout_before = $sel_timeout;
          SELECT:
            {
                my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                if ($nfound < 0) {
                    if ($!{EINTR} || $!{EAGAIN}) {
                        if ($time_before) {
                            $sel_timeout = $sel_timeout_before - (time - $time_before);
                            $sel_timeout = 0 if $sel_timeout < 0;
                        }
                        redo SELECT;
                    }
                    die "select failed: $!";
                }
	    }

	    if ($write_wait) {
		$write_wait -= time - $time_before;
		$write_wait = 0 if $write_wait < 0;
	    }

	    if (defined($rbits) && $rbits =~ /[^\0]/) {
		my $buf = $socket->_rbuf;
		my $n = $socket->sysread($buf, 1024, length($buf));
                unless (defined $n) {
                    die "read failed: $!" unless  $!{EINTR} || $!{EAGAIN};
                }
		elsif ($n == 0) {
                    $drop_connection++;
                    last WRITE;
		}
		$socket->_rbuf($buf);
		if (!$code && $buf =~ /\015?\012\015?\012/) {
		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
									junk_out => \@junk,
								       );
		    if ($code eq "100") {
			$write_wait = 0;
			undef($code);
		    }
		    else {
			$drop_connection++;
			last WRITE;
		    }
		}
	    }
	    if (defined($wbits) && $wbits =~ /[^\0]/) {
		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                unless (defined $n) {
                    die "write failed: $!" unless $!{EINTR} || $!{EAGAIN};
                    $n = 0;  # will retry write on the next round
                }
                elsif ($n == 0) {
		    die "write failed: no bytes written";
		}
		$woffset += $n;

		if (!$eof && $woffset >= length($$wbuf)) {
		    my $buf = &$content_ref();
		    $buf = "" unless defined($buf);
		    $eof++ unless length($buf);
		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
			if $chunked;
		    $wbuf = \$buf;
		    $woffset = 0;
		}
	    }
	} # WRITE
    }

    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
	unless $code;
    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
	if $code eq "100";

    my $response = HTTP::Response->new($code, $mess);
    my $peer_http_version = $socket->peer_http_version;
    $response->protocol("HTTP/$peer_http_version");
    {
	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
	$response->push_header(@h);
    }
    $response->push_header("Client-Junk" => \@junk) if @junk;

    $response->request($request);
    $self->_get_sock_info($response, $socket);

    if ($method eq "CONNECT") {
	$response->{client_socket} = $socket;  # so it can be picked up
	return $response;
    }

    if (my @te = $response->remove_header('Transfer-Encoding')) {
	$response->push_header('Client-Transfer-Encoding', \@te);
    }
    $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);

    my $complete;
    $response = $self->collect($arg, $response, sub {
	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
	my $n;
      READ:
	{
	    $n = $socket->read_entity_body($buf, $size);
            unless (defined $n) {
                redo READ if $!{EINTR} || $!{EAGAIN};
                die "read failed: $!";
            }
	    redo READ if $n == -1;
	}
	$complete++ if !$n;
        return \$buf;
    } );
    $drop_connection++ unless $complete;

    @h = $socket->get_trailers;
    if (@h) {
	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
	$response->push_header(@h);
    }

    unless ($drop_connection) {
	if (my $conn_cache = $self->{ua}{conn_cache}) {
	    my %connection = map { (lc($_) => 1) }
		             split(/\s*,\s*/, ($response->header("Connection") || ""));
	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
		$connection{"keep-alive"})
	    {
		$conn_cache->deposit($self->socket_type, "$host:$port", $socket);
	    }
	}
    }

    $response;
}


package LWP::Protocol::http::SocketMethods;

sub sysread {
    my $self = shift;
    if (my $timeout = ${*$self}{io_socket_timeout}) {
	die "read timeout" unless $self->can_read($timeout);
    }
    else {
	$self->can_read(undef) || die "Assert";
    }
    sysread($self, $_[0], $_[1], $_[2] || 0);
}

sub can_read {
    my($self, $timeout) = @_;
    my $fbits = '';
    vec($fbits, fileno($self), 1) = 1;
  SELECT:
    {
        my $before;
        $before = time if $timeout;
        my $nfound = select($fbits, undef, undef, $timeout);
        if ($nfound < 0) {
            if ($!{EINTR} || $!{EAGAIN}) {
                if ($timeout) {
                    $timeout -= time - $before;
                    $timeout = 0 if $timeout < 0;
                }
                redo SELECT;
            }
            die "select failed: $!";
        }
        return $nfound > 0;
    }
}

sub ping {
    my $self = shift;
    !$self->can_read(0);
}

sub increment_response_count {
    my $self = shift;
    return ++${*$self}{'myhttp_response_count'};
}

package LWP::Protocol::http::Socket;
use vars qw(@ISA);
@ISA = qw(LWP::Protocol::http::SocketMethods Net::HTTP);

1;
}
##} /usr/local/libdata/perl5/site_perl/LWP/Protocol/http.pm
BEGIN { $INC{'XML/Simple.pm'}++; }
# $Id: Simple.pm,v 1.40 2007/08/15 10:36:48 grantm Exp $
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################

##{ /usr/local/libdata/perl5/site_perl/XML/Simple.pm
{
package XML::Simple;





use strict;
use Carp;
require Exporter;



use vars qw($VERSION @ISA @EXPORT @EXPORT_OK $PREFERRED_PARSER);

@ISA               = qw(Exporter);
@EXPORT            = qw(XMLin XMLout);
@EXPORT_OK         = qw(xml_in xml_out);
$VERSION           = '2.18';
$PREFERRED_PARSER  = undef;

my $StrictMode     = 0;

my @KnownOptIn     = qw(keyattr keeproot forcecontent contentkey noattr
                        searchpath forcearray cache suppressempty parseropts
                        grouptags nsexpand datahandler varattr variables
                        normalisespace normalizespace valueattr);

my @KnownOptOut    = qw(keyattr keeproot contentkey noattr
                        rootname xmldecl outputfile noescape suppressempty
                        grouptags nsexpand handler noindent attrindent nosort
                        valueattr numericescape);

my @DefKeyAttr     = qw(name key id);
my $DefRootName    = qq(opt);
my $DefContentKey  = qq(content);
my $DefXmlDecl     = qq(<?xml version='1.0' standalone='yes'?>);

my $xmlns_ns       = 'http://www.w3.org/2000/xmlns/';
my $bad_def_ns_jcn = '{' . $xmlns_ns . '}';     # LibXML::SAX workaround



my %MemShareCache  = ();
my %MemCopyCache   = ();



sub import {
  
  $StrictMode = 1 if grep(/^:strict$/, @_);


  @_ = grep(!/^:strict$/, @_);
  goto &Exporter::import;
}



sub new {
  my $class = shift;

  if(@_ % 2) {
    croak "Default options must be name=>value pairs (odd number supplied)";
  }

  my %known_opt;
  @known_opt{@KnownOptIn, @KnownOptOut} = (undef) x 100;

  my %raw_opt = @_;
  my %def_opt;
  while(my($key, $val) = each %raw_opt) {
    my $lkey = lc($key);
    $lkey =~ s/_//g;
    croak "Unrecognised option: $key" unless(exists($known_opt{$lkey}));
    $def_opt{$lkey} = $val;
  }
  my $self = { def_opt => \%def_opt };

  return(bless($self, $class));
}



sub _get_object {
  my $self;
  if($_[0]  and  UNIVERSAL::isa($_[0], 'XML::Simple')) {
    $self = shift;
  }
  else {
    $self = XML::Simple->new();
  }
  
  return $self;
}



sub XMLin {
  my $self = &_get_object;      # note, @_ is passed implicitly

  my $target = shift;



  if(not defined $target) {
    return $self->parse_file(undef, @_);
  }

  elsif($target eq '-') {
    local($/) = undef;
    $target = <STDIN>;
    return $self->parse_string(\$target, @_);
  }

  elsif(my $type = ref($target)) {
    if($type eq 'SCALAR') {
      return $self->parse_string($target, @_);
    }
    else {
      return $self->parse_fh($target, @_);
    }
  }

  elsif($target =~ m{<.*?>}s) {
    return $self->parse_string(\$target, @_);
  }

  else {
    return $self->parse_file($target, @_);
  }
}



sub parse_file {
  my $self = &_get_object;      # note, @_ is passed implicitly

  my $filename = shift;

  $self->handle_options('in', @_);

  $filename = $self->default_config_file if not defined $filename;

  $filename = $self->find_xml_file($filename, @{$self->{opt}->{searchpath}});


  if($self->{opt}->{cache}) {
    foreach my $scheme (@{$self->{opt}->{cache}}) {
      my $method = 'cache_read_' . $scheme;
      my $opt = $self->$method($filename);
      return($opt) if($opt);
    }
  }

  my $ref = $self->build_simple_tree($filename, undef);

  if($self->{opt}->{cache}) {
    my $method = 'cache_write_' . $self->{opt}->{cache}->[0];
    $self->$method($ref, $filename);
  }

  return $ref;
}



sub parse_fh {
  my $self = &_get_object;      # note, @_ is passed implicitly

  my $fh = shift;
  croak "Can't use " . (defined $fh ? qq{string ("$fh")} : 'undef') .
        " as a filehandle" unless ref $fh;

  $self->handle_options('in', @_);

  return $self->build_simple_tree(undef, $fh);
}



sub parse_string {
  my $self = &_get_object;      # note, @_ is passed implicitly

  my $string = shift;

  $self->handle_options('in', @_);

  return $self->build_simple_tree(undef, ref $string ? $string : \$string);
}



sub default_config_file {
  my $self = shift;

  require File::Basename;

  my($basename, $script_dir, $ext) = File::Basename::fileparse($0, '\.[^\.]+');

  
  if($script_dir) {
    unshift(@{$self->{opt}->{searchpath}}, $script_dir);
  }

  return $basename . '.xml';
}



sub build_simple_tree {
  my $self = shift;

  my $tree = $self->build_tree(@_);

  return $self->{opt}->{keeproot}
         ? $self->collapse({}, @$tree)
         : $self->collapse(@{$tree->[1]});
}



sub build_tree {
  my $self     = shift;
  my $filename = shift;
  my $string   = shift;


  my $preferred_parser = $PREFERRED_PARSER;
  unless(defined($preferred_parser)) {
    $preferred_parser = $ENV{XML_SIMPLE_PREFERRED_PARSER} || '';
  }
  if($preferred_parser eq 'XML::Parser') {
    return($self->build_tree_xml_parser($filename, $string));
  }

  eval { require XML::SAX; };      # We didn't need it until now
  if($@) {                         # No XML::SAX - fall back to XML::Parser
    if($preferred_parser) {        # unless a SAX parser was expressly requested
      croak "XMLin() could not load XML::SAX";
    }
    return($self->build_tree_xml_parser($filename, $string));
  }

  $XML::SAX::ParserPackage = $preferred_parser if($preferred_parser);

  my $sp = XML::SAX::ParserFactory->parser(Handler => $self);
  
  $self->{nocollapse} = 1;
  my($tree);
  if($filename) {
    $tree = $sp->parse_uri($filename);
  }
  else {
    if(ref($string) && ref($string) ne 'SCALAR') {
      $tree = $sp->parse_file($string);
    }
    else {
      $tree = $sp->parse_string($$string);
    }
  }

  return($tree);
}



sub build_tree_xml_parser {
  my $self     = shift;
  my $filename = shift;
  my $string   = shift;


  eval {
    local($^W) = 0;      # Suppress warning from Expat.pm re File::Spec::load()
    require XML::Parser; # We didn't need it until now
  };
  if($@) {
    croak "XMLin() requires either XML::SAX or XML::Parser";
  }

  if($self->{opt}->{nsexpand}) {
    carp "'nsexpand' option requires XML::SAX";
  }

  my $xp = XML::Parser->new(Style => 'Tree', @{$self->{opt}->{parseropts}});
  my($tree);
  if($filename) {
    local(*XML_FILE);
    open(XML_FILE, '<', $filename) || croak qq($filename - $!);
    $tree = $xp->parse(*XML_FILE);
    close(XML_FILE);
  }
  else {
    $tree = $xp->parse($$string);
  }

  return($tree);
}



sub cache_write_storable {
  my($self, $data, $filename) = @_;

  my $cachefile = $self->storable_filename($filename);

  require Storable;           # We didn't need it until now

  if ('VMS' eq $^O) {
    Storable::nstore($data, $cachefile);
  }
  else {
    Storable::lock_nstore($data, $cachefile);
  }
  
}



sub cache_read_storable {
  my($self, $filename) = @_;
  
  my $cachefile = $self->storable_filename($filename);

  return unless(-r $cachefile);
  return unless((stat($cachefile))[9] > (stat($filename))[9]);

  require Storable;           # We didn't need it until now
  
  if ('VMS' eq $^O) {
    return(Storable::retrieve($cachefile));
  }
  else {
    return(Storable::lock_retrieve($cachefile));
  }
  
}



sub storable_filename {
  my($self, $cachefile) = @_;

  $cachefile =~ s{(\.xml)?$}{.stor};
  return $cachefile;
}



sub cache_write_memshare {
  my($self, $data, $filename) = @_;

  $MemShareCache{$filename} = [time(), $data];
}



sub cache_read_memshare {
  my($self, $filename) = @_;
  
  return unless($MemShareCache{$filename});
  return unless($MemShareCache{$filename}->[0] > (stat($filename))[9]);

  return($MemShareCache{$filename}->[1]);
  
}



sub cache_write_memcopy {
  my($self, $data, $filename) = @_;

  require Storable;           # We didn't need it until now
  
  $MemCopyCache{$filename} = [time(), Storable::dclone($data)];
}



sub cache_read_memcopy {
  my($self, $filename) = @_;
  
  return unless($MemCopyCache{$filename});
  return unless($MemCopyCache{$filename}->[0] > (stat($filename))[9]);

  return(Storable::dclone($MemCopyCache{$filename}->[1]));
  
}



sub XMLout {
  my $self = &_get_object;      # note, @_ is passed implicitly

  croak "XMLout() requires at least one argument" unless(@_);
  my $ref = shift;

  $self->handle_options('out', @_);



  if($self->{opt}->{nsexpand}) {
    require XML::NamespaceSupport;
    $self->{nsup} = XML::NamespaceSupport->new();
    $self->{ns_prefix} = 'aaa';
  }



  if(UNIVERSAL::isa($ref, 'ARRAY')) {
    $ref = { anon => $ref };
  }



  if($self->{opt}->{keeproot}) {
    my(@keys) = keys(%$ref);
    if(@keys == 1) {
      $ref = $ref->{$keys[0]};
      $self->{opt}->{rootname} = $keys[0];
    }
  }
  

  elsif($self->{opt}->{rootname} eq '') {
    if(UNIVERSAL::isa($ref, 'HASH')) {
      my $refsave = $ref;
      $ref = {};
      foreach (keys(%$refsave)) {
        if(ref($refsave->{$_})) {
          $ref->{$_} = $refsave->{$_};
        }
        else {
          $ref->{$_} = [ $refsave->{$_} ];
        }
      }
    }
  }



  $self->{_ancestors} = [];
  my $xml = $self->value_to_xml($ref, $self->{opt}->{rootname}, '');
  delete $self->{_ancestors};

  if($self->{opt}->{xmldecl}) {
    $xml = $self->{opt}->{xmldecl} . "\n" . $xml;
  }

  if($self->{opt}->{outputfile}) {
    if(ref($self->{opt}->{outputfile})) {
      my $fh = $self->{opt}->{outputfile};
      if(UNIVERSAL::isa($fh, 'GLOB') and !UNIVERSAL::can($fh, 'print')) {
        eval { require IO::Handle; };
        croak $@ if $@;
      }
      return($fh->print($xml));
    }
    else {
      local(*OUT);
      open(OUT, '>', "$self->{opt}->{outputfile}") ||
        croak "open($self->{opt}->{outputfile}): $!";
      binmode(OUT, ':utf8') if($] >= 5.008);
      print OUT $xml || croak "print: $!";
      close(OUT);
    }
  }
  elsif($self->{opt}->{handler}) {
    require XML::SAX;
    my $sp = XML::SAX::ParserFactory->parser(
               Handler => $self->{opt}->{handler}
             );
    return($sp->parse_string($xml));
  }
  else {
    return($xml);
  }
}



sub handle_options  {
  my $self = shift;
  my $dirn = shift;



  my %known_opt; 
  if($dirn eq 'in') {
    @known_opt{@KnownOptIn} = @KnownOptIn;
  }
  else {
    @known_opt{@KnownOptOut} = @KnownOptOut;
  }



  if(@_ % 2) {
    croak "Options must be name=>value pairs (odd number supplied)";
  }
  my %raw_opt  = @_;
  my $opt      = {};
  $self->{opt} = $opt;

  while(my($key, $val) = each %raw_opt) {
    my $lkey = lc($key);
    $lkey =~ s/_//g;
    croak "Unrecognised option: $key" unless($known_opt{$lkey});
    $opt->{$lkey} = $val;
  }



  foreach (keys(%known_opt)) {
    unless(exists($opt->{$_})) {
      if(exists($self->{def_opt}->{$_})) {
        $opt->{$_} = $self->{def_opt}->{$_};
      }
    }
  }


  
  if(exists($opt->{rootname})) {
    unless(defined($opt->{rootname})) {
      $opt->{rootname} = '';
    }
  }
  else {
    $opt->{rootname} = $DefRootName;
  }
  
  if($opt->{xmldecl}  and  $opt->{xmldecl} eq '1') {
    $opt->{xmldecl} = $DefXmlDecl;
  }

  if(exists($opt->{contentkey})) {
    if($opt->{contentkey} =~ m{^-(.*)$}) {
      $opt->{contentkey} = $1;
      $opt->{collapseagain} = 1;
    }
  }
  else {
    $opt->{contentkey} = $DefContentKey;
  }

  unless(exists($opt->{normalisespace})) {
    $opt->{normalisespace} = $opt->{normalizespace};
  }
  $opt->{normalisespace} = 0 unless(defined($opt->{normalisespace}));


  if($opt->{searchpath}) {
    unless(ref($opt->{searchpath})) {
      $opt->{searchpath} = [ $opt->{searchpath} ];
    }
  }
  else  {
    $opt->{searchpath} = [ ];
  }

  if($opt->{cache}  and !ref($opt->{cache})) {
    $opt->{cache} = [ $opt->{cache} ];
  }
  if($opt->{cache}) {
    $_ = lc($_) foreach (@{$opt->{cache}});
    foreach my $scheme (@{$opt->{cache}}) {
      my $method = 'cache_read_' . $scheme;
      croak "Unsupported caching scheme: $scheme"
        unless($self->can($method));
    }
  }
  
  if(exists($opt->{parseropts})) {
    if($^W) {
      carp "Warning: " .
           "'ParserOpts' is deprecated, contact the author if you need it";
    }
  }
  else {
    $opt->{parseropts} = [ ];
  }

  

  if(exists($opt->{forcearray})) {
    if(ref($opt->{forcearray}) eq 'Regexp') {
      $opt->{forcearray} = [ $opt->{forcearray} ];
    }

    if(ref($opt->{forcearray}) eq 'ARRAY') {
      my @force_list = @{$opt->{forcearray}};
      if(@force_list) {
        $opt->{forcearray} = {};
        foreach my $tag (@force_list) {
          if(ref($tag) eq 'Regexp') {
            push @{$opt->{forcearray}->{_regex}}, $tag;
          }
          else {
            $opt->{forcearray}->{$tag} = 1;
          }
        }
      }
      else {
        $opt->{forcearray} = 0;
      }
    }
    else {
      $opt->{forcearray} = ( $opt->{forcearray} ? 1 : 0 );
    }
  }
  else {
    if($StrictMode  and  $dirn eq 'in') {
      croak "No value specified for 'ForceArray' option in call to XML$dirn()";
    }
    $opt->{forcearray} = 0;
  }



  if(exists($opt->{keyattr}))  {
    if(ref($opt->{keyattr})) {
      if(ref($opt->{keyattr}) eq 'HASH') {


        $opt->{keyattr} = { %{$opt->{keyattr}} };

        

        foreach my $el (keys(%{$opt->{keyattr}})) {
          if($opt->{keyattr}->{$el} =~ /^(\+|-)?(.*)$/) {
            $opt->{keyattr}->{$el} = [ $2, ($1 ? $1 : '') ];
            if($StrictMode  and  $dirn eq 'in') {
              next if($opt->{forcearray} == 1);
              next if(ref($opt->{forcearray}) eq 'HASH'
                      and $opt->{forcearray}->{$el});
              croak "<$el> set in KeyAttr but not in ForceArray";
            }
          }
          else {
            delete($opt->{keyattr}->{$el}); # Never reached (famous last words?)
          }
        }
      }
      else {
        if(@{$opt->{keyattr}} == 0) {
          delete($opt->{keyattr});
        }
      }
    }
    else {
      $opt->{keyattr} = [ $opt->{keyattr} ];
    }
  }
  else  {
    if($StrictMode) {
      croak "No value specified for 'KeyAttr' option in call to XML$dirn()";
    }
    $opt->{keyattr} = [ @DefKeyAttr ];
  }



  if(exists($opt->{valueattr})) {
    if(ref($opt->{valueattr}) eq 'ARRAY') {
      $opt->{valueattrlist} = {};
      $opt->{valueattrlist}->{$_} = 1 foreach(@{ delete $opt->{valueattr} });
    }
  }


  if($opt->{grouptags}) {
    croak "Illegal value for 'GroupTags' option - expected a hashref"
      unless UNIVERSAL::isa($opt->{grouptags}, 'HASH');

    while(my($key, $val) = each %{$opt->{grouptags}}) {
      next if $key ne $val;
      croak "Bad value in GroupTags: '$key' => '$val'";
    }
  }



  if($opt->{variables} and !UNIVERSAL::isa($opt->{variables}, 'HASH')) {
    croak "Illegal value for 'Variables' option - expected a hashref";
  }

  if($opt->{variables}) { 
    $self->{_var_values} = { %{$opt->{variables}} };
  }
  elsif($opt->{varattr}) { 
    $self->{_var_values} = {};
  }

}



sub find_xml_file  {
  my $self = shift;
  my $file = shift;
  my @search_path = @_;


  require File::Basename;
  require File::Spec;

  my($filename, $filedir) = File::Basename::fileparse($file);

  if($filename ne $file) {        # Ignore searchpath if dir component
    return($file) if(-e $file);
  }
  else {
    my($path);
    foreach $path (@search_path)  {
      my $fullpath = File::Spec->catfile($path, $file);
      return($fullpath) if(-e $fullpath);
    }
  }


  if(!@search_path) {
    return($file) if(-e $file);
    croak "File does not exist: $file";
  }

  croak "Could not find $file in ", join(':', @search_path);
}



sub collapse {
  my $self = shift;


  
  my $attr  = shift;
  if($self->{opt}->{noattr}) {                    # Discard if 'noattr' set
    $attr = {};
  }
  elsif($self->{opt}->{normalisespace} == 2) {
    while(my($key, $value) = each %$attr) {
      $attr->{$key} = $self->normalise_space($value)
    }
  }



  if(my $var = $self->{_var_values}) {
    while(my($key, $val) = each(%$attr)) {
      $val =~ s{\$\{([\w.]+)\}}{ $self->get_var($1) }ge;
      $attr->{$key} = $val;
    }
  }



  if(!@_  and  keys %$attr == 1) {
    my($k) = keys %$attr;
    if($self->{opt}->{valueattrlist}  and $self->{opt}->{valueattrlist}->{$k}) {
      return $attr->{$k};
    }
  }



  my($key, $val);
  while(@_) {
    $key = shift;
    $val = shift;

    if(ref($val)) {
      $val = $self->collapse(@$val);
      next if(!defined($val)  and  $self->{opt}->{suppressempty});
    }
    elsif($key eq '0') {
      next if($val =~ m{^\s*$}s);  # Skip all whitespace content

      $val = $self->normalise_space($val)
        if($self->{opt}->{normalisespace} == 2);


      if(my $var = $self->{_var_values}) { 
        $val =~ s{\$\{(\w+)\}}{ $self->get_var($1) }ge;
      }

      

      if(my $var = $self->{opt}->{varattr}) { 
        if(exists $attr->{$var}) {
          $self->set_var($attr->{$var}, $val);
        }
      }



      if(!%$attr  and  !@_) {
        return($self->{opt}->{forcecontent} ? 
          { $self->{opt}->{contentkey} => $val } : $val
        );
      }
      $key = $self->{opt}->{contentkey};
    }



    if(exists($attr->{$key})) {
      if(UNIVERSAL::isa($attr->{$key}, 'ARRAY')) {
        push(@{$attr->{$key}}, $val);
      }
      else {
        $attr->{$key} = [ $attr->{$key}, $val ];
      }
    }
    elsif(defined($val)  and  UNIVERSAL::isa($val, 'ARRAY')) {
      $attr->{$key} = [ $val ];
    }
    else {
      if( $key ne $self->{opt}->{contentkey} 
          and (
            ($self->{opt}->{forcearray} == 1)
            or ( 
              (ref($self->{opt}->{forcearray}) eq 'HASH')
              and (
                $self->{opt}->{forcearray}->{$key}
                or (grep $key =~ $_, @{$self->{opt}->{forcearray}->{_regex}})
              )
            )
          )
        ) {
        $attr->{$key} = [ $val ];
      }
      else {
        $attr->{$key} = $val;
      }
    }

  }



  if($self->{opt}->{keyattr}) {
    while(($key,$val) = each %$attr) {
      if(defined($val)  and  UNIVERSAL::isa($val, 'ARRAY')) {
        $attr->{$key} = $self->array_to_hash($key, $val);
      }
    }
  }



  if($self->{opt}->{grouptags}) {
    while(my($key, $val) = each(%$attr)) {
      next unless(UNIVERSAL::isa($val, 'HASH') and (keys %$val == 1));
      next unless(exists($self->{opt}->{grouptags}->{$key}));

      my($child_key, $child_val) =  %$val;

      if($self->{opt}->{grouptags}->{$key} eq $child_key) {
        $attr->{$key}= $child_val;
      }
    }
  }



  my $count = scalar keys %$attr;
  if($count == 1 
     and  exists $attr->{anon}  
     and  UNIVERSAL::isa($attr->{anon}, 'ARRAY')
  ) {
    return($attr->{anon});
  }



  if(!%$attr  and  exists($self->{opt}->{suppressempty})) {
    if(defined($self->{opt}->{suppressempty})  and
       $self->{opt}->{suppressempty} eq '') {
      return('');
    }
    return(undef);
  }



  if($self->{opt}->{valueattr}) {
    while(my($key, $val) = each(%$attr)) {
      next unless($self->{opt}->{valueattr}->{$key});
      next unless(UNIVERSAL::isa($val, 'HASH') and (keys %$val == 1));
      my($k) = keys %$val;
      next unless($k eq $self->{opt}->{valueattr}->{$key});
      $attr->{$key} = $val->{$k};
    }
  }

  return($attr)

}



sub set_var {
  my($self, $name, $value) = @_;

  $self->{_var_values}->{$name} = $value;
}



sub get_var {
  my($self, $name) = @_;

  my $value = $self->{_var_values}->{$name};
  return $value if(defined($value));

  return '${' . $name . '}';
}



sub normalise_space {
  my($self, $text) = @_;

  $text =~ s/^\s+//s;
  $text =~ s/\s+$//s;
  $text =~ s/\s\s+/ /sg;

  return $text;
}



sub array_to_hash {
  my $self     = shift;
  my $name     = shift;
  my $arrayref = shift;

  my $hashref  = $self->new_hashref;

  my($i, $key, $val, $flag);



  if(ref($self->{opt}->{keyattr}) eq 'HASH') {
    return($arrayref) unless(exists($self->{opt}->{keyattr}->{$name}));
    ($key, $flag) = @{$self->{opt}->{keyattr}->{$name}};
    for($i = 0; $i < @$arrayref; $i++)  {
      if(UNIVERSAL::isa($arrayref->[$i], 'HASH') and
         exists($arrayref->[$i]->{$key})
      ) {
        $val = $arrayref->[$i]->{$key};
        if(ref($val)) {
          $self->die_or_warn("<$name> element has non-scalar '$key' key attribute");
          return($arrayref);
        }
        $val = $self->normalise_space($val)
          if($self->{opt}->{normalisespace} == 1);
        $self->die_or_warn("<$name> element has non-unique value in '$key' key attribute: $val")
          if(exists($hashref->{$val}));
        $hashref->{$val} = { %{$arrayref->[$i]} };
        $hashref->{$val}->{"-$key"} = $hashref->{$val}->{$key} if($flag eq '-');
        delete $hashref->{$val}->{$key} unless($flag eq '+');
      }
      else {
        $self->die_or_warn("<$name> element has no '$key' key attribute");
        return($arrayref);
      }
    }
  }



  else {
    my $default_keys =
      join(',', @DefKeyAttr) eq join(',', @{$self->{opt}->{keyattr}});

    ELEMENT: for($i = 0; $i < @$arrayref; $i++)  {
      return($arrayref) unless(UNIVERSAL::isa($arrayref->[$i], 'HASH'));

      foreach $key (@{$self->{opt}->{keyattr}}) {
        if(defined($arrayref->[$i]->{$key}))  {
          $val = $arrayref->[$i]->{$key};
          if(ref($val)) {
            $self->die_or_warn("<$name> element has non-scalar '$key' key attribute")
              if not $default_keys;
            return($arrayref);
          }
          $val = $self->normalise_space($val)
            if($self->{opt}->{normalisespace} == 1);
          $self->die_or_warn("<$name> element has non-unique value in '$key' key attribute: $val")
            if(exists($hashref->{$val}));
          $hashref->{$val} = { %{$arrayref->[$i]} };
          delete $hashref->{$val}->{$key};
          next ELEMENT;
        }
      }

      return($arrayref);    # No keyfield matched
    }
  }
  

  if($self->{opt}->{collapseagain}) {
    $hashref = $self->collapse_content($hashref);
  }
 
  return($hashref);
}



sub die_or_warn {
  my $self = shift;
  my $msg  = shift;

  croak $msg if($StrictMode);
  carp "Warning: $msg" if($^W);
}



sub new_hashref {
  my $self = shift;

  return { @_ };
}



sub collapse_content {
  my $self       = shift;
  my $hashref    = shift; 

  my $contentkey = $self->{opt}->{contentkey};

  foreach my $val (values %$hashref) {
    return $hashref unless (     (ref($val) eq 'HASH')
                             and (keys %$val == 1)
                             and (exists $val->{$contentkey})
                           );
  }

  foreach my $key (keys %$hashref) {
    $hashref->{$key}=  $hashref->{$key}->{$contentkey};
  }

  return $hashref;
}
  


sub value_to_xml {
  my $self = shift;;



  my($ref, $name, $indent) = @_;

  my $named = (defined($name) and $name ne '' ? 1 : 0);

  my $nl = "\n";

  my $is_root = $indent eq '' ? 1 : 0;   # Warning, dirty hack!
  if($self->{opt}->{noindent}) {
    $indent = '';
    $nl     = '';
  }


  
  if(ref($ref)) {
    croak "circular data structures not supported"
      if(grep($_ == $ref, @{$self->{_ancestors}}));
    push @{$self->{_ancestors}}, $ref;
  }
  else {
    if($named) {
      return(join('',
              $indent, '<', $name, '>',
              ($self->{opt}->{noescape} ? $ref : $self->escape_value($ref)),
              '</', $name, ">", $nl
            ));
    }
    else {
      return("$ref$nl");
    }
  }



  if(UNIVERSAL::isa($ref, 'HASH')      # It is a hash
     and keys %$ref                    # and it's not empty
     and $self->{opt}->{keyattr}       # and folding is enabled
     and !$is_root                     # and its not the root element
  ) {
    $ref = $self->hash_to_array($name, $ref);
  }


  my @result = ();
  my($key, $value);



  if(UNIVERSAL::isa($ref, 'HASH')) {


    if($self->{opt}->{grouptags}) {
      $ref = $self->copy_hash($ref);
      while(my($key, $val) = each %$ref) {
        if($self->{opt}->{grouptags}->{$key}) {
          $ref->{$key} = { $self->{opt}->{grouptags}->{$key} => $val };
        }
      }
    }



    my $nsdecls = '';
    my $default_ns_uri;
    if($self->{nsup}) {
      $ref = $self->copy_hash($ref);
      $self->{nsup}->push_context();


      if(exists($ref->{xmlns})) {
        $self->{nsup}->declare_prefix('', $ref->{xmlns});
        $nsdecls .= qq( xmlns="$ref->{xmlns}"); 
        delete($ref->{xmlns});
      }
      $default_ns_uri = $self->{nsup}->get_uri('');



      foreach my $qname (keys(%$ref)) {
        my($uri, $lname) = $self->{nsup}->parse_jclark_notation($qname);
        if($uri) {
          if($uri eq $xmlns_ns) {
            $self->{nsup}->declare_prefix($lname, $ref->{$qname});
            $nsdecls .= qq( xmlns:$lname="$ref->{$qname}"); 
            delete($ref->{$qname});
          }
        }
      }


      foreach my $qname (keys(%$ref)) {
        my($uri, $lname) = $self->{nsup}->parse_jclark_notation($qname);
        if($uri) {
          if($default_ns_uri  and  $uri eq $default_ns_uri) {
            $ref->{$lname} = $ref->{$qname};
            delete($ref->{$qname});
          }
          else {
            my $prefix = $self->{nsup}->get_prefix($uri);
            unless($prefix) {
              $prefix = $self->{ns_prefix}++;
              $self->{nsup}->declare_prefix($prefix, $uri);
              $nsdecls .= qq( xmlns:$prefix="$uri"); 
            }
            $ref->{"$prefix:$lname"} = $ref->{$qname};
            delete($ref->{$qname});
          }
        }
      }
    }


    my @nested = ();
    my $text_content = undef;
    if($named) {
      push @result, $indent, '<', $name, $nsdecls;
    }

    if(keys %$ref) {
      my $first_arg = 1;
      foreach my $key ($self->sorted_keys($name, $ref)) {
        my $value = $ref->{$key};
        next if(substr($key, 0, 1) eq '-');
        if(!defined($value)) {
          next if $self->{opt}->{suppressempty};
          unless(exists($self->{opt}->{suppressempty})
             and !defined($self->{opt}->{suppressempty})
          ) {
            carp 'Use of uninitialized value' if($^W);
          }
          if($key eq $self->{opt}->{contentkey}) {
            $text_content = '';
          }
          else {
            $value = exists($self->{opt}->{suppressempty}) ? {} : '';
          }
        }

        if(!ref($value)  
           and $self->{opt}->{valueattr}
           and $self->{opt}->{valueattr}->{$key}
        ) {
          $value = { $self->{opt}->{valueattr}->{$key} => $value };
        }

        if(ref($value)  or  $self->{opt}->{noattr}) {
          push @nested,
            $self->value_to_xml($value, $key, "$indent  ");
        }
        else {
          $value = $self->escape_value($value) unless($self->{opt}->{noescape});
          if($key eq $self->{opt}->{contentkey}) {
            $text_content = $value;
          }
          else {
            push @result, "\n$indent " . ' ' x length($name)
              if($self->{opt}->{attrindent}  and  !$first_arg);
            push @result, ' ', $key, '="', $value , '"';
            $first_arg = 0;
          }
        }
      }
    }
    else {
      $text_content = '';
    }

    if(@nested  or  defined($text_content)) {
      if($named) {
        push @result, ">";
        if(defined($text_content)) {
          push @result, $text_content;
          $nested[0] =~ s/^\s+// if(@nested);
        }
        else {
          push @result, $nl;
        }
        if(@nested) {
          push @result, @nested, $indent;
        }
        push @result, '</', $name, ">", $nl;
      }
      else {
        push @result, @nested;             # Special case if no root elements
      }
    }
    else {
      push @result, " />", $nl;
    }
    $self->{nsup}->pop_context() if($self->{nsup});
  }



  elsif(UNIVERSAL::isa($ref, 'ARRAY')) {
    foreach $value (@$ref) {
      next if !defined($value) and $self->{opt}->{suppressempty};
      if(!ref($value)) {
        push @result,
             $indent, '<', $name, '>',
             ($self->{opt}->{noescape} ? $value : $self->escape_value($value)),
             '</', $name, ">$nl";
      }
      elsif(UNIVERSAL::isa($value, 'HASH')) {
        push @result, $self->value_to_xml($value, $name, $indent);
      }
      else {
        push @result,
               $indent, '<', $name, ">$nl",
               $self->value_to_xml($value, 'anon', "$indent  "),
               $indent, '</', $name, ">$nl";
      }
    }
  }

  else {
    croak "Can't encode a value of type: " . ref($ref);
  }


  pop @{$self->{_ancestors}} if(ref($ref));

  return(join('', @result));
}



sub sorted_keys {
  my($self, $name, $ref) = @_;

  return keys %$ref if $self->{opt}->{nosort};

  my %hash = %$ref;
  my $keyattr = $self->{opt}->{keyattr};

  my @key;

  if(ref $keyattr eq 'HASH') {
    if(exists $keyattr->{$name} and exists $hash{$keyattr->{$name}->[0]}) {
      push @key, $keyattr->{$name}->[0];
      delete $hash{$keyattr->{$name}->[0]};
    }
  }
  elsif(ref $keyattr eq 'ARRAY') {
    foreach (@{$keyattr}) {
      if(exists $hash{$_}) {
        push @key, $_;
        delete $hash{$_};
        last;
      }
    }
  }

  return(@key, sort keys %hash);
}


sub escape_value {
  my($self, $data) = @_;

  return '' unless(defined($data));

  $data =~ s/&/&amp;/sg;
  $data =~ s/</&lt;/sg;
  $data =~ s/>/&gt;/sg;
  $data =~ s/"/&quot;/sg;

  my $level = $self->{opt}->{numericescape} or return $data;

  return $self->numeric_escape($data, $level);
}

sub numeric_escape {
  my($self, $data, $level) = @_;

  use utf8; # required for 5.6

  if($self->{opt}->{numericescape} eq '2') {
    $data =~ s/([^\x00-\x7F])/'&#' . ord($1) . ';'/gse;
  }
  else {
    $data =~ s/([^\x00-\xFF])/'&#' . ord($1) . ';'/gse;
  }

  return $data;
}



sub hash_to_array {
  my $self    = shift;
  my $parent  = shift;
  my $hashref = shift;

  my $arrayref = [];

  my($key, $value);

  my @keys = $self->{opt}->{nosort} ? keys %$hashref : sort keys %$hashref;
  foreach $key (@keys) {
    $value = $hashref->{$key};
    return($hashref) unless(UNIVERSAL::isa($value, 'HASH'));

    if(ref($self->{opt}->{keyattr}) eq 'HASH') {
      return($hashref) unless(defined($self->{opt}->{keyattr}->{$parent}));
      push @$arrayref, $self->copy_hash(
        $value, $self->{opt}->{keyattr}->{$parent}->[0] => $key
      );
    }
    else {
      push(@$arrayref, { $self->{opt}->{keyattr}->[0] => $key, %$value });
    }
  }

  return($arrayref);
}



sub copy_hash {
  my($self, $orig, @extra) = @_;

  return { @extra, %$orig };
}


sub start_document {
  my $self = shift;

  $self->handle_options('in') unless($self->{opt});

  $self->{lists} = [];
  $self->{curlist} = $self->{tree} = [];
}


sub start_element {
  my $self    = shift;
  my $element = shift;

  my $name = $element->{Name};
  if($self->{opt}->{nsexpand}) {
    $name = $element->{LocalName} || '';
    if($element->{NamespaceURI}) {
      $name = '{' . $element->{NamespaceURI} . '}' . $name;
    }
  }
  my $attributes = {};
  if($element->{Attributes}) {  # Might be undef
    foreach my $attr (values %{$element->{Attributes}}) {
      if($self->{opt}->{nsexpand}) {
        my $name = $attr->{LocalName} || '';
        if($attr->{NamespaceURI}) {
          $name = '{' . $attr->{NamespaceURI} . '}' . $name
        }
        $name = 'xmlns' if($name eq $bad_def_ns_jcn);
        $attributes->{$name} = $attr->{Value};
      }
      else {
        $attributes->{$attr->{Name}} = $attr->{Value};
      }
    }
  }
  my $newlist = [ $attributes ];
  push @{ $self->{lists} }, $self->{curlist};
  push @{ $self->{curlist} }, $name => $newlist;
  $self->{curlist} = $newlist;
}


sub characters {
  my $self  = shift;
  my $chars = shift;

  my $text  = $chars->{Data};
  my $clist = $self->{curlist};
  my $pos = $#$clist;
  
  if ($pos > 0 and $clist->[$pos - 1] eq '0') {
    $clist->[$pos] .= $text;
  }
  else {
    push @$clist, 0 => $text;
  }
}


sub end_element {
  my $self    = shift;

  $self->{curlist} = pop @{ $self->{lists} };
}


sub end_document {
  my $self = shift;

  delete($self->{curlist});
  delete($self->{lists});

  my $tree = $self->{tree};
  delete($self->{tree});



  return($tree) if($self->{nocollapse});


  
  if($self->{opt}->{keeproot}) {
    $tree = $self->collapse({}, @$tree);
  }
  else {
    $tree = $self->collapse(@{$tree->[1]});
  }

  if($self->{opt}->{datahandler}) {
    return($self->{opt}->{datahandler}->($self, $tree));
  }

  return($tree);
}

*xml_in  = \&XMLin;
*xml_out = \&XMLout;

1;

}
##} /usr/local/libdata/perl5/site_perl/XML/Simple.pm
BEGIN { $INC{'WWW/Mechanize/Link.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/WWW/Mechanize/Link.pm
{
package WWW::Mechanize::Link;

use strict;
use warnings;


sub new {
    my $class = shift;

    my $self;

    if ( ref $_[0] eq 'HASH' ) {
        $self = [ @{$_[0]}{ qw( url text name tag base attrs ) } ];
    }
    else {
        $self = [ @_ ];
    }

    return bless $self, $class;
}


sub url   { return ($_[0])->[0]; }
sub text  { return ($_[0])->[1]; }
sub name  { return ($_[0])->[2]; }
sub tag   { return ($_[0])->[3]; }
sub base  { return ($_[0])->[4]; }
sub attrs { return ($_[0])->[5]; }


sub URI {
    my $self = shift;

    require URI::URL;
    my $URI = URI::URL->new( $self->url, $self->base );

    return $URI;
}


sub url_abs {
    my $self = shift;

    return $self->URI->abs;
}



1;
}
##} /usr/local/libdata/perl5/site_perl/WWW/Mechanize/Link.pm

##{ utils/combine-head
{
package main;
$::SCRIPT_NAME = 'combined-get_flash_videos';
1;
}
##} utils/combine-head
BEGIN { $INC{'FlashVideo/Site/4od.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Utils.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'HTML/TokeParser.pm'}++; }
BEGIN { $INC{'HTML/PullParser.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/amd64-openbsd/HTML/PullParser.pm
{
package HTML::PullParser;

require HTML::Parser;
@ISA=qw(HTML::Parser);
$VERSION = "3.57";

use strict;
use Carp ();

sub new
{
    my($class, %cnf) = @_;

    my %argspec;
    for (qw(start end text declaration comment process default)) {
	my $tmp = delete $cnf{$_};
	next unless defined $tmp;
	$argspec{$_} = $tmp;
    }
    Carp::croak("Info not collected for any events")
	  unless %argspec;

    my $file = delete $cnf{file};
    my $doc  = delete $cnf{doc};
    Carp::croak("Can't parse from both 'doc' and 'file' at the same time")
	  if defined($file) && defined($doc);
    Carp::croak("No 'doc' or 'file' given to parse from")
	  unless defined($file) || defined($doc);

    $cnf{api_version} = 3;
    my $self = $class->SUPER::new(%cnf);

    my $accum = $self->{pullparser_accum} = [];
    while (my($event, $argspec) = each %argspec) {
	$self->SUPER::handler($event => $accum, $argspec);
    }

    if (defined $doc) {
	$self->{pullparser_str_ref} = ref($doc) ? $doc : \$doc;
	$self->{pullparser_str_pos} = 0;
    }
    else {
	if (!ref($file) && ref(\$file) ne "GLOB") {
	    require IO::File;
	    $file = IO::File->new($file, "r") || return;
	}

	$self->{pullparser_file} = $file;
    }
    $self;
}


sub handler
{
    Carp::croak("Can't set handlers for HTML::PullParser");
}


sub get_token
{
    my $self = shift;
    while (!@{$self->{pullparser_accum}} && !$self->{pullparser_eof}) {
	if (my $f = $self->{pullparser_file}) {
	    my $buf;
	    if (read($f, $buf, 512)) {
		$self->parse($buf);
	    } else {
		$self->eof;
		$self->{pullparser_eof}++;
		delete $self->{pullparser_file};
	    }
	}
	elsif (my $sref = $self->{pullparser_str_ref}) {
	    my $pos = $self->{pullparser_str_pos};
	    my $chunk = substr($$sref, $pos, 512);
	    $self->parse($chunk);
	    $pos += length($chunk);
	    if ($pos < length($$sref)) {
		$self->{pullparser_str_pos} = $pos;
	    }
	    else {
		$self->eof;
		$self->{pullparser_eof}++;
		delete $self->{pullparser_str_ref};
		delete $self->{pullparser_str_pos};
	    }
	}
	else {
	    die;
	}
    }
    shift @{$self->{pullparser_accum}};
}


sub unget_token
{
    my $self = shift;
    unshift @{$self->{pullparser_accum}}, @_;
    $self;
}

1;


}
##} /usr/local/libdata/perl5/site_perl/amd64-openbsd/HTML/PullParser.pm
BEGIN { $INC{'HTML/Tagset.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTML/Tagset.pm
{
package HTML::Tagset;

use strict;


use vars qw( $VERSION );

$VERSION = '3.20';


use vars qw(
    $VERSION
    %emptyElement %optionalEndTag %linkElements %boolean_attr
    %isHeadElement %isBodyElement %isPhraseMarkup
    %is_Possible_Strict_P_Content
    %isHeadOrBodyElement
    %isList %isTableElement %isFormElement
    %isKnown %canTighten
    @p_closure_barriers
    %isCDATA_Parent
);


%emptyElement   = map {; $_ => 1 } qw(base link meta isindex
                                     img br hr wbr
                                     input area param
                                     embed bgsound spacer
                                     basefont col frame
                                     ~comment ~literal
                                     ~declaration ~pi
                                    );


%optionalEndTag = map {; $_ => 1 } qw(p li dt dd); # option th tr td);


%linkElements =
(
 'a'       => ['href'],
 'applet'  => ['archive', 'codebase', 'code'],
 'area'    => ['href'],
 'base'    => ['href'],
 'bgsound' => ['src'],
 'blockquote' => ['cite'],
 'body'    => ['background'],
 'del'     => ['cite'],
 'embed'   => ['pluginspage', 'src'],
 'form'    => ['action'],
 'frame'   => ['src', 'longdesc'],
 'iframe'  => ['src', 'longdesc'],
 'ilayer'  => ['background'],
 'img'     => ['src', 'lowsrc', 'longdesc', 'usemap'],
 'input'   => ['src', 'usemap'],
 'ins'     => ['cite'],
 'isindex' => ['action'],
 'head'    => ['profile'],
 'layer'   => ['background', 'src'],
 'link'    => ['href'],
 'object'  => ['classid', 'codebase', 'data', 'archive', 'usemap'],
 'q'       => ['cite'],
 'script'  => ['src', 'for'],
 'table'   => ['background'],
 'td'      => ['background'],
 'th'      => ['background'],
 'tr'      => ['background'],
 'xmp'     => ['href'],
);


%boolean_attr = (
  'area'   => 'nohref',
  'dir'    => 'compact',
  'dl'     => 'compact',
  'hr'     => 'noshade',
  'img'    => 'ismap',
  'input'  => { 'checked' => 1, 'readonly' => 1, 'disabled' => 1 },
  'menu'   => 'compact',
  'ol'     => 'compact',
  'option' => 'selected',
  'select' => 'multiple',
  'td'     => 'nowrap',
  'th'     => 'nowrap',
  'ul'     => 'compact',
);



%isPhraseMarkup = map {; $_ => 1 } qw(
  span abbr acronym q sub sup
  cite code em kbd samp strong var dfn strike
  b i u s tt small big 
  a img br
  wbr nobr blink
  font basefont bdo
  spacer embed noembed
);  # had: center, hr, table



%is_Possible_Strict_P_Content = (
 %isPhraseMarkup,
 %isFormElement,
 map {; $_ => 1} qw( object script map )
);



%isHeadElement = map {; $_ => 1 }
 qw(title base link meta isindex script style object bgsound);


%isList         = map {; $_ => 1 } qw(ul ol dir menu);


%isTableElement = map {; $_ => 1 }
 qw(tr td th thead tbody tfoot caption col colgroup);


%isFormElement  = map {; $_ => 1 }
 qw(input select option optgroup textarea button label);


%isBodyElement = map {; $_ => 1 } qw(
  h1 h2 h3 h4 h5 h6
  p div pre plaintext address blockquote
  xmp listing
  center

  multicol
  iframe ilayer nolayer
  bgsound

  hr
  ol ul dir menu li
  dl dt dd
  ins del
  
  fieldset legend
  
  map area
  applet param object
  isindex script noscript
  table
  center
  form
 ),
 keys %isFormElement,
 keys %isPhraseMarkup,   # And everything phrasal
 keys %isTableElement,
;



%isHeadOrBodyElement = map {; $_ => 1 }
  qw(script isindex style object map area param noscript bgsound);



%isKnown = (%isHeadElement, %isBodyElement,
  map{; $_=>1 }
   qw( head body html
       frame frameset noframes
       ~comment ~pi ~directive ~literal
));



%canTighten = %isKnown;
delete @canTighten{
  keys(%isPhraseMarkup), 'input', 'select',
  'xmp', 'listing', 'plaintext', 'pre',
};
@canTighten{'hr','br'} = (1,1);




@p_closure_barriers = qw(
  li blockquote
  ul ol menu dir
  dl dt dd
  td th tr table caption
  div
 );



%isCDATA_Parent = map {; $_ => 1 }
  qw(script style  xmp listing plaintext);





1;
}
##} /usr/local/libdata/perl5/site_perl/HTML/Tagset.pm
##{ /usr/local/libdata/perl5/site_perl/amd64-openbsd/HTML/TokeParser.pm
{
package HTML::TokeParser;

@ISA=qw(HTML::PullParser);
$VERSION = "3.57";

use strict;
use Carp ();
use HTML::Entities qw(decode_entities);

my %ARGS =
(
 start       => "'S',tagname,attr,attrseq,text",
 end         => "'E',tagname,text",
 text        => "'T',text,is_cdata",
 process     => "'PI',token0,text",
 comment     => "'C',text",
 declaration => "'D',text",

 unbroken_text => 1,
);


sub new
{
    my $class = shift;
    my %cnf;
    if (@_ == 1) {
	my $type = (ref($_[0]) eq "SCALAR") ? "doc" : "file";
	%cnf = ($type => $_[0]);
    }
    else {
	%cnf = @_;
    }

    my $textify = delete $cnf{textify} || {img => "alt", applet => "alt"};

    my $self = $class->SUPER::new(%cnf, %ARGS) || return undef;

    $self->{textify} = $textify;
    $self;
}


sub get_tag
{
    my $self = shift;
    my $token;
    while (1) {
	$token = $self->get_token || return undef;
	my $type = shift @$token;
	next unless $type eq "S" || $type eq "E";
	substr($token->[0], 0, 0) = "/" if $type eq "E";
	return $token unless @_;
	for (@_) {
	    return $token if $token->[0] eq $_;
	}
    }
}


sub _textify {
    my($self, $token) = @_;
    my $tag = $token->[1];
    return undef unless exists $self->{textify}{$tag};

    my $alt = $self->{textify}{$tag};
    my $text;
    if (ref($alt)) {
	$text = &$alt(@$token);
    } else {
	$text = $token->[2]{$alt || "alt"};
	$text = "[\U$tag]" unless defined $text;
    }
    return $text;
}


sub get_text
{
    my $self = shift;
    my @text;
    while (my $token = $self->get_token) {
	my $type = $token->[0];
	if ($type eq "T") {
	    my $text = $token->[1];
	    decode_entities($text) unless $token->[2];
	    push(@text, $text);
	} elsif ($type =~ /^[SE]$/) {
	    my $tag = $token->[1];
	    if ($type eq "S") {
		if (defined(my $text = _textify($self, $token))) {
		    push(@text, $text);
		    next;
		}
	    } else {
		$tag = "/$tag";
	    }
	    if (!@_ || grep $_ eq $tag, @_) {
		 $self->unget_token($token);
		 last;
	    }
	    push(@text, " ")
		if $tag eq "br" || !$HTML::Tagset::isPhraseMarkup{$token->[1]};
	}
    }
    join("", @text);
}


sub get_trimmed_text
{
    my $self = shift;
    my $text = $self->get_text(@_);
    $text =~ s/^\s+//; $text =~ s/\s+$//; $text =~ s/\s+/ /g;
    $text;
}

sub get_phrase {
    my $self = shift;
    my @text;
    while (my $token = $self->get_token) {
	my $type = $token->[0];
	if ($type eq "T") {
	    my $text = $token->[1];
	    decode_entities($text) unless $token->[2];
	    push(@text, $text);
	} elsif ($type =~ /^[SE]$/) {
	    my $tag = $token->[1];
	    if ($type eq "S") {
		if (defined(my $text = _textify($self, $token))) {
		    push(@text, $text);
		    next;
		}
	    }
	    if (!$HTML::Tagset::isPhraseMarkup{$tag}) {
		$self->unget_token($token);
		last;
	    }
	    push(@text, " ") if $tag eq "br";
	}
    }
    my $text = join("", @text);
    $text =~ s/^\s+//; $text =~ s/\s+$//; $text =~ s/\s+/ /g;
    $text;
}

1;


}
##} /usr/local/libdata/perl5/site_perl/amd64-openbsd/HTML/TokeParser.pm
##{ blib/lib/FlashVideo/Utils.pm
{
package FlashVideo::Utils;

use strict;
no warnings 'uninitialized';
use Exporter;use base 'Exporter';
use HTML::Entities;
BEGIN { HTML::TokeParser->import(); } # (added by utils/combine-perl.pl)
use Encode;

use constant FP_KEY => "Genuine Adobe Flash Player 001";
use constant EXTENSIONS => qr/\.(?:flv|mp4|mov|wmv|avi|m4v)/i;
use constant MAX_REDIRECTS => 5;

our @EXPORT = qw(debug info error
  extract_title extract_info title_to_filename get_video_filename url_exists
  swfhash swfhash_data EXTENSIONS get_user_config_dir get_win_codepage
  is_program_on_path get_terminal_width json_unescape
  convert_sami_subtitles_to_srt from_xml);

sub debug(@) {
  my $string = "@_\n";
  $string =~ s/\Q$ENV{HOME}\E/~/g;
  print STDERR $string if $App::get_flash_videos::opt{debug};
}

sub info(@) {
  print STDERR "@_\n" unless $App::get_flash_videos::opt{quiet};
}

sub error(@) {
  print STDERR "@_\n";
}

sub extract_title {
  my($browser) = @_;
  return extract_info($browser)->{title};
}

sub extract_info {
  my($browser) = @_;
  my($title, $meta_title);

  my $p = HTML::TokeParser->new(\$browser->content);
  while(my $token = $p->get_tag("title", "meta")) {
    my($tag, $attr) = @$token;

    if($tag eq 'meta' && $attr->{name} =~ /title/i) {
      $meta_title = $attr->{content};
    } elsif($tag eq 'title') {
      $title = $p->get_trimmed_text;
    }
  }

  return {
    title => $title, 
    meta_title => $meta_title,
  };
}

sub swfhash {
  my($browser, $url) = @_;

  $browser->get($url);

  return swfhash_data($browser->content, $url);
}

sub swfhash_data {
  my ($data, $url) = @_;

  die "Must have Compress::Zlib and Digest::SHA for this RTMP download\n"
      unless eval {
        require Compress::Zlib;
        require Digest::SHA;
      };

  $data = "F" . substr($data, 1, 7)
              . Compress::Zlib::uncompress(substr $data, 8);

  return
    swfsize => length $data,
    swfhash => Digest::SHA::hmac_sha256_hex($data, FP_KEY),
    swfUrl  => $url;
}

sub url_exists {
  my($browser, $url) = @_;

  $browser->head($url);
  my $response = $browser->response;
  debug "Exists on $url: " . $response->code;
  return $url if $response->code == 200;

  my $redirects = 0;
  while ( ($response->code =~ /^30\d/) and ($response->header('Location'))
      and ($redirects < MAX_REDIRECTS) ) {
    $url = URI->new_abs($response->header('Location'), $url);
    $response = $browser->head($url);
    debug "Redirected to $url (" . $response->code . ")";
    if ($response->code == 200) {
      return $url;
    }
    $redirects++;
  }

  return '';
}

sub title_to_filename {
  my($title, $type) = @_;

  if($App::get_flash_videos::opt{filename} ne '') {
    return $App::get_flash_videos::opt{filename};
  }

  if($title =~ s/(@{[EXTENSIONS]})$//) {
    $type = substr $1, 1;
  } elsif ($type && $type !~ /^\w+$/) {
    $type = substr((URI->new($type)->path =~ /(@{[EXTENSIONS]})$/)[0], 1);
  }

  $type ||= "flv";

  utf8::upgrade($title);

  if ($title =~ /&(?:\w+|#(?:\d+|x[A-F0-9]+));/) {
    $title = decode_entities($title);
  }

  $title =~ s/\s+/_/g;
  $title =~ s/[^\w\-,()&]/_/g;
  $title =~ s/^_+|_+$//g;   # underscores at the start and end look bad
 
  return get_video_filename($type) unless $title;

  return "$title.$type";
}

sub get_video_filename {
  my($type) = @_;
  $type ||= "flv";
  return "video" . get_timestamp_in_iso8601_format() . "." . $type; 
}

sub get_timestamp_in_iso8601_format { 
  use Time::localtime; 
  my $time = localtime; 
  return sprintf("%04d%02d%02d%02d%02d%02d", 
                 $time->year + 1900, $time->mon + 1, 
                 $time->mday, $time->hour, $time->min, $time->sec); 
}

sub get_vlc_exe_from_registry {
  if ($^O !~ /MSWin/i) {
    die "Doesn't make sense to call this except on Windows";
  }

  my $HAS_WIN32_REGISTRY = eval { require Win32::Registry };

  die "Win32::Registry required for JustWorks(tm) playing on Windows"
    unless $HAS_WIN32_REGISTRY;

  require Win32::Registry;

  Win32::Registry->import();
  
  my $local_machine;

  {
    no strict 'vars';
    $local_machine = $::HKEY_LOCAL_MACHINE;
  }

  my $key = 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall';

  $local_machine->Open($key, my $reg);

  my @applications;
  $reg->GetKeys(\@applications);

  my $vlc_binary;

  foreach my $application (@applications) {
    next unless $application =~ /VLC Media Player/i;

    $reg->Open($application, my $details);

    my %app_properties;
    $details->GetValues(\%app_properties);

    if ($app_properties{DisplayIcon}->[-1] =~ /\.exe$/i) {
      $vlc_binary = $app_properties{DisplayIcon}->[-1];
      last;
    }
  }
  
  return $vlc_binary;
}

sub get_win_codepage {
  require Win32::API;

  if (! %Win32::API::Type::Known) {
    %Win32::API::Type::Known = (int => 'i');
  }

  Win32::API->Import("kernel32", "int GetACP()");
  return "cp" . GetACP();
}

sub get_user_config_dir {


  return $^O =~ /MSWin/i ? ($ENV{APPDATA} || 'c:/windows/application data')
                            . "/get_flash_videos"
                         : "$ENV{HOME}/.get_flash_videos";
}

sub is_program_on_path {
  my($program) = @_;
  my $win = $^O =~ /MSWin/i;

  for my $dir(split($win ? ";" : ":", $ENV{PATH})) {
    return 1 if -f "$dir/$program" . ($win ? ".exe" : "");
  }
  return 0;
}

sub get_terminal_width {
  if(eval { require Term::ReadKey } && (my($width) = Term::ReadKey::GetTerminalSize())) {
    return $width - 1 if $^O =~ /MSWin|cygwin/i; # seems to be off by 1 on Windows
    return $width;
  } elsif($ENV{COLUMNS}) {
    return $ENV{COLUMNS};
  } else {
    return 80;
  }
}

sub json_unescape {
  my($s) = @_;

  $s =~ s/\\u([0-9a-f]{1,4})/chr hex $1/ge;
  $s =~ s{(\\[\\/rnt"])}{"\"$1\""}gee;
  return $s;
}

sub convert_sami_subtitles_to_srt {
  my ($sami_subtitles, $filename, $decrypt_callback) = @_;

  die "SAMI subtitles must be provided"      unless $sami_subtitles;
  die "Output SRT filename must be provided" unless $filename;

  $sami_subtitles =~ s/[\r\n]//g; # flatten

  my @lines = split /<Sync\s/i, $sami_subtitles;
  shift @lines; # Skip headers

  my @subtitles;
  my $count = 0;

  my $last_proper_sub_end_time = '';

  for (@lines) {
    my ($begin, $sub);
    s|<\/?span.*?>| |g;
    
    s|&amp;|&|g;

    s{&(?:nbsp|#160);}{ }g;


    ($begin, $sub) = ($1, $2) if m{[^>]*Start="(.+?)"[^>]*>(.*?)<\/Sync>}i;

    if (/^\s*Encrypted="true"\s*/i) {
      if ($decrypt_callback and ref($decrypt_callback) eq 'CODE') {
        $sub = $decrypt_callback->($sub);
      }
    }

    $sub =~ s@&amp;@&@g;
    $sub =~ s@(?:</?span[^>]*>|&nbsp;|&#160;)@ @g;

    $sub =~ s{</?P[^>]*?>}{}g;  # remove <P Class="ENCC"> and similar

    $sub =~ s{<(/)?([BI])>}{"<$1" . lc($2) . ">"}eg;
    
    decode_entities($sub); # in void context, this works in place

    if ($sub and ($begin or $begin == 0)) {
      my $seconds = int( $begin / 1000.0 );
      my $ms = $begin - ( $seconds * 1000.0 );
      $begin = sprintf("%02d:%02d:%02d,%03d", (gmtime($seconds))[2,1,0], $ms );


      $sub =~ s/^\s*(.*?)\s*$/$1/;

      $sub =~ s/\s{2,}/ /g;

      $sub =~ s|<br ?\/? ?>|\n|ig;

      $sub =~ s/^\s*|\s*$//mg;

      if ($count and !$subtitles[$count - 1]->{end}) {
        $subtitles[$count - 1]->{end} = $begin;
      }

      if (!$sub or $sub =~ /^\s+$/) {
        if ($count) {
          $last_proper_sub_end_time = $subtitles[$count - 1]->{end};
        }

        next; # this is not a meaningful subtitle
      }

      push @subtitles, {
        start => $begin,
        text  => $sub,
      };

      $count++;
    }
  }

  $subtitles[$count - 1]->{end} = $last_proper_sub_end_time;

  open my $subtitle_fh, '>', $filename
    or die "Can't open subtitles file $filename: $!";

  binmode $subtitle_fh, ':utf8';

  $count = 1;

  foreach my $subtitle (@subtitles) {
    print $subtitle_fh "$count\n$subtitle->{start} --> $subtitle->{end}\n" .
                       "$subtitle->{text}\n\n";
    $count++;
  }

  close $subtitle_fh;

  return 1;
}

sub from_xml {
  my($xml, @args) = @_;

  if(!eval { require XML::Simple && XML::Simple::XMLin("<foo/>") }) {
    die "Must have XML::Simple to download " . caller =~ /::([^:])+$/ . " videos\n";
  }

  $xml = eval {
    XML::Simple::XMLin(ref $xml eq 'SCALAR' ? $xml
      : ref $xml ? $xml->content
      : $xml, @args);
  };

  if($@) {
    die "$@ (from ", join("::", caller), ")\n";
  }

  return $xml;
}

1;
}
##} blib/lib/FlashVideo/Utils.pm
##{ blib/lib/FlashVideo/Site/4od.pm
{
package FlashVideo::Site::4od;


use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_escape = \&URI::Escape::uri_escape; }

sub search {
  my ($self, $search, $type) = @_;

  unless(eval { from_xml("<foo/") }) {
    if($type eq 'site') {
      die $@;
    } else {
      debug $@;
      return;
    }
  }

  my $gdata_template_url =
    "http://gdata.youtube.com/feeds/api/videos?q=%s&orderby=published&start-index=1&max-results=50&v=2";
  my $search_url = sprintf $gdata_template_url, uri_escape($search);

  my $browser = FlashVideo::Mechanize->new();

  $browser->get($search_url);

  if (!$browser->success) {
    die "Couldn't get YouTube search Atom XML: " . $browser->response->status_line();
  }

  my $xml = from_xml($browser, KeyAttr => [], ForceArray => ['entry']);
  
  my @matches = map { _process_4od_result($_) }
                grep { $_->{author}->{name} =~ /^4oD\w+$/i } @{ $xml->{entry} };

  return @matches;
}

sub _process_4od_result {
  my $feed_entry = shift;

  my $url = $feed_entry->{'media:group'}->{'media:player'}->{url};
  $url =~ s/&feature=youtube_gdata//;

  my $published_date = $feed_entry->{published};
  $published_date =~ s/T.*$//; # only care about date, not time

  my $title = $feed_entry->{'media:group'}->{'media:title'}->{content};
  my $description = $feed_entry->{'media:group'}->{'media:description'}->{content};

  my $result_name = "$title ($published_date)";

  return { name => $result_name, url => $url, description => $description };
}

1;
}
##} blib/lib/FlashVideo/Site/4od.pm
BEGIN { $INC{'FlashVideo/Site/5min.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/5min.pm
{
package FlashVideo::Site::5min;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *extract_info = \&FlashVideo::Utils::extract_info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my $filename = title_to_filename(extract_info($browser)->{meta_title});

  my $url = (FlashVideo::Generic->find_video($browser, $browser->uri))[0];

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/5min.pm
BEGIN { $INC{'FlashVideo/Site/Abc.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Abc.pm
{
package FlashVideo::Site::Abc;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  if ($browser->uri->as_string =~ m'/watch/clip/[\w\-]+/(\w+)/(\w+)/(\w+)') {
    my $show_id     = $1;
    my $playlist_id = $2;
    my $video_id    = $3;

    return handle_abc_clip($browser, $show_id, $playlist_id, $video_id);
  }

  my $playpath;
  if ($browser->content =~ /http:\/\/cdn\.video\.abc\.com\/abcvideo\/video_fep\/thumbnails\/220x124\/([^"]*)220x124\.jpg/) {
    $playpath = "mp4:/abcvideo/video_fep/mov/" . lc($1) . "768x432_700.mov";
  }
  
  $browser->content =~ /<h2 id="video_title">([^<]*)<\/h2>/;
  my $title = $1;
  my $rtmpurl = "rtmp://abcondemandfs.fplive.net:1935/abcondemand";

  return {
    rtmp => $rtmpurl,
    playpath => $playpath,
    flv => title_to_filename($title)
  };
}

sub handle_abc_clip {
  my ($browser, $show_id, $playlist_id, $video_id) = @_;


  my $abc_clip_rss_url_template =
    "http://ll.static.abc.com/vp2/ws/s/contents/1000/videomrss?" .
    "brand=001&device=001&width=644&height=362&clipId=%s" .
    "&start=0&limit=1&fk=CATEGORIES&fv=%s";
  
  my $abc_clip_rss_url = sprintf $abc_clip_rss_url_template,
                                 $video_id, $playlist_id;

  $browser->get($abc_clip_rss_url);

  if (!$browser->success) {
    die "Couldn't download ABC clip RSS: " . $browser->response->status_line;
  }

  my $xml = from_xml($browser);

  my $video_url = $xml->{channel}->{item}->{'media:content'}->{url};
  my $type      = $video_url =~ /\.mp4$/ ? 'mp4' : 'flv';

  if (!$video_url) {
    die "Couldn't determine ABC clip URL";
  }

  my $episode_name;
  if ($video_url =~ /FLF_\d+[A-Za-z]{0,5}_([^_]+)/) {
    $episode_name = $1;
  }

  my $category    = $xml->{channel}->{item}->{category};
  my $title       = $xml->{channel}->{item}->{'media:title'}->{content};

  if (ref($category) eq 'HASH' and ! keys %$category) {
    $category = '';
  }

  my $description = $xml->{channel}->{item}->{'media:description'}->{content};

  for ($category, $description, $title) {
    s/<\/?\w+>//g;
  }

  my $video_title = make_title($category, $episode_name, $title, $description);

  return $video_url, title_to_filename($video_title, $type);
}

sub make_title {
  return join " - ", grep /./, @_;
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $url && URI->new($url)->host =~ /\babc\.(?:go\.)?com$/;
}

1;
}
##} blib/lib/FlashVideo/Site/Abc.pm
BEGIN { $INC{'FlashVideo/Site/Abclocal.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Abclocal.pm
{
package FlashVideo::Site::Abclocal;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
use Data::Dumper;
use File::Basename;

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  my($station,$id) = $browser->content =~ m{http://cdn.abclocal.go.com/[^"']*station=([^&;"']+)[^"']*mediaId=([^&;"']+)}s;

  die "No media id and station found" unless $id;

  $browser->get("http://cdn.abclocal.go.com/$station/playlistSyndicated?id=$id");

  my @tmp = $browser->content =~ m{<video *videopath="([^"]*)"[^>]*width="([^"]*)"[^>]*height="([^"]*)"[^>]*>}s ;
  my(@videos);
  for (my $i = 0; $i < @tmp; $i+=3)
  {
    push @videos, { "playpath" => $tmp[$i], "resolution" => [$tmp[$i+1], $tmp[$i+2]] };
  }

  my $video = $prefs->quality->choose(@videos);

  my $url = $video->{"playpath"};

  return $url, File::Basename::basename($url);
}

1;
}
##} blib/lib/FlashVideo/Site/Abclocal.pm
BEGIN { $INC{'FlashVideo/Site/About.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Site/Brightcove.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Brightcove.pm
{
package FlashVideo::Site::Brightcove;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use MIME::Base64;

my $encode_rates = {
     "low" => 480,
     "medium" => 800,
     "medium2" => 1200, 
     "high" => 1500 };

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  my $metadata = { };
  my ($video_id, $player_id);

  $player_id = ($browser->content =~ /playerId["'\] ]*[:=]["' ]*(\d+)/i)[0];
  $metadata->{videoplayer} = ($browser->content =~ /videoPlayer=ref:(C\d+)/i)[0];
  $metadata->{publisherId} = ($browser->content =~ /publisherID=(\d+)/i)[0];

  $player_id ||= ($browser->content =~ /<param name=["']?playerID["']? value=["'](\d+) ?["']/i)[0];
  $metadata->{videoplayer} ||= ($browser->content =~ /param name=["']?\@videoPlayer["']? value=["']?(\d+)["']?/i)[0];
  $metadata->{publisherId} ||= ($browser->content =~ /param name=["']?publisherID["']? value=["']?(\d+)["']?/i)[0];

  $player_id ||= ($browser->content =~ /flashVars.*playerID=(\d+)/i)[0];

  if(!$player_id && $browser->content =~ /brightcove.player.create\(['"]?(\d+)['"]?,\s*['"]?(\d+)/) {
    $player_id = $2;
  }

  $metadata->{sessionId} = ($browser->cookie_jar->as_string =~ /session=([0-9a-f]*);/)[0];

  for my $url($browser->uri->as_string, $embed_url) {

    if($url =~ /(?:playerID|bcpid)=?(\d+)/i) {
      $player_id ||= $1;
    }
  }

  debug "Extracted playerId: $player_id, sessionId: $metadata->{sessionId} videoplayer: $metadata->{videoplayer} publisherId: $metadata->{publisherId} "
    if $player_id or $video_id;

  die "Unable to extract Brightcove IDs from page" unless $player_id;

  return $self->amfgateway($browser, $player_id, $metadata, $prefs);
}

sub amfgateway {
  my($self, $browser, $player_id, $metadata, $prefs) = @_;

  my $has_amf_packet = eval { require Data::AMF::Packet };
  if (!$has_amf_packet) {
    die "Must have Data::AMF::Packet installed to download Brightcove videos";
  }

  my $page_url = $browser->uri;
  my $base_url = "" . $page_url;


  my $amf0_formatter = Data::AMF::Formatter->new(version =>0);
  my $amf3_formatter = Data::AMF::Formatter->new(version =>3);
  my @amf_pkt;


  $amf_pkt[0] = decode_base64(<<EOF1);
AAMAAAABAEZjb20uYnJpZ2h0Y292ZS5leHBlcmllbmNlLkV4cGVyaWVuY2VSdW50aW1lRmFjYWRl
LmdldERhdGFGb3JFeHBlcmllbmNlAAIvMQAA
EOF1

  $amf_pkt[2] = decode_base64(<<EOF2);
CgAAAAI=
EOF2

  $amf_pkt[3] = $amf0_formatter->format($metadata->{sessionId});

  $amf_pkt[4] = decode_base64(<<EOF3);
EQpjY2NvbS5icmlnaHRjb3ZlLmV4cGVyaWVuY2UuVmlld2VyRXhwZXJpZW5jZVJlcXVlc3QhY29u
dGVudE92ZXJyaWRlcwdVUkwZZXhwZXJpZW5jZUlkEVRUTFRva2VuE3BsYXllcktleRlkZWxpdmVy
eVR5cGUJAwEKgQNTY29tLmJyaWdodGNvdmUuZXhwZXJpZW5jZS5Db250ZW50T3ZlcnJpZGUXY29u
dGVudFR5cGUTY29udGVudElkGWNvbnRlbnRSZWZJZBtmZWF0dXJlZFJlZklkG2NvbnRlbnRSZWZJ
ZHMVZmVhdHVyZWRJZBVjb250ZW50SWRzDXRhcmdldAQABX/////gAAAA
EOF3

  $amf_pkt[5] = $amf3_formatter->format($metadata->{videoplayer});

  $amf_pkt[6] = decode_base64(<<EOF4);
AQEFf////+AAAAABBhd2aWRlb1BsYXllcg==
EOF4

  $amf_pkt[7] = $amf3_formatter->format($base_url);

  $amf_pkt[8] = decode_base64(<<EOF5);
BUI4gZvSwQAABgEGAQV/////4AAAAA==
EOF5


  $amf_pkt[1] = pack('n', length(join('',@amf_pkt[2..8])));

  my $data = join('',@amf_pkt[0..8]);





  $browser->post(
    "http://c.brightcove.com/services/messagebroker/amf?playerid=$player_id",
    Content_Type => "application/x-amf",
    Content => $data
  );

  die "Failed to post to Brightcove AMF gateway"
    unless $browser->response->is_success;

  debug $browser->response->content;

  my $packet = Data::AMF::Packet->deserialize($browser->content);

  if($self->debug) {
    require Data::Dumper;
    debug Data::Dumper::Dumper($packet);
  }

  if ( ref  $packet->messages->[0]->{value}->{programmedContent}->{videoPlayer}->{mediaDTO}->{renditions} ne 'ARRAY') {
    die "Unexpected data from AMF gateway";
  }

  my @found;
  for (@{$packet->messages->[0]->{value}->{programmedContent}->{videoPlayer}->{mediaDTO}->{renditions}}) {
    if ($_->{defaultURL}) {
      push @found, $_;
    }
  }

  my $mediaId = $packet->messages->[0]->{value}->{programmedContent}->{videoPlayer}->{mediaId};
  my $seasonnumber = $packet->messages->[0]->{value}->{programmedContent}->{videoPlayer}->{mediaDTO}->{customFields}->{seasonnumber};
  my $episodenumber = $packet->messages->[0]->{value}->{programmedContent}->{videoPlayer}->{mediaDTO}->{customFields}->{episodenumber};
  my $show = ($page_url =~ m!/shows/([^/]+)/!i)[0];
  my $episode = ($page_url =~ m!/episodes/([^/]+)!i)[0];
  my $filehead = $show . "_Series" . $seasonnumber;
  if ( $show ne $episode ) {
    $filehead = $filehead . "_Episode" . $episodenumber . "_" . $episode;
  }
  my $encode_rate = $encode_rates->{$prefs->{quality}};
  if (! defined $encode_rate ) {
    $encode_rate = $prefs->{quality};
  }

  my @rtmpdump_commands;

  for my $d (@found) {

    my $rate = ($d->{defaultURL} =~ /H264-(\d+)-16x9/i)[0];
    next if $encode_rate != $rate;
    my $host = ($d->{defaultURL} =~ m!rtmpe://(.*?)/!)[0];
    my $file = ($d->{defaultURL} =~ /^[^&]+&(.*)$/)[0];
    my $app = ($d->{defaultURL} =~ m!//.*?/(.*?)/&!)[0];
    my $filename = $filehead . "_" . $rate;

    $app .= "?videoId=$mediaId&lineUpId=&pubId=$metadata->{publisherId}&playerId=$player_id&affiliateId=";

    my $args = {
      app => $app,
      pageUrl => $page_url,
      swfVfy => "http://admin.brightcove.com/viewer/us1.24.04.08.2011-01-14072625/connection/ExternalConnection_2.swf",
      tcUrl => "rtmpe://$host:1935/$app",
      rtmp => "$d->{defaultURL}",
      playpath => $file,
      flv => "$filename.flv",
    };

    if ($d->{publisherName} and $d->{displayName}) {
      $args->{flv} = title_to_filename("$d->{publisherName} - $d->{displayName}");
    }


    push @rtmpdump_commands, $args;
  }

  if (@rtmpdump_commands > 1) {
    return \@rtmpdump_commands;
  }
  else {
    return $rtmpdump_commands[-1];
  }
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return 1 if $url && URI->new($url)->host =~ /\.brightcove\.com$/;

  return $browser->content =~ /(playerI[dD]|brightcove.player.create)/
    && $browser->content =~ /brightcove/i;
}

1;
}
##} blib/lib/FlashVideo/Site/Brightcove.pm
##{ blib/lib/FlashVideo/Site/About.pm
{
package FlashVideo::Site::About;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { FlashVideo::Site::Brightcove->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Brightcove';

my $JS_RE = qr/vdo_None\.js/;

sub find_video {
  my($self, $browser, $embed_url) = @_;

  my($video_ref) = $browser->content =~ /zIvdoId=["']([^"']+)/;
  die "Unable to extract video ref" unless $video_ref;

  my($js_src) = $browser->content =~ /["']([^"']+$JS_RE)/;
  $browser->get($js_src);
  my($player_id) = $browser->content =~ /playerId.*?(\d+)/;
  die "Unable to extract playerId" unless $player_id;

  return $self->amfgateway($browser, $player_id, { videoRefId => $video_ref });
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->content =~ $JS_RE; 
}

1;
}
##} blib/lib/FlashVideo/Site/About.pm
BEGIN { $INC{'FlashVideo/Site/Adultswim.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Adultswim.pm
{
package FlashVideo::Site::Adultswim;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
	my($self, $browser, $embed_url) = @_;

	my $xml;
	my $id;

	my $segIds;
	if($browser->{content} =~ m/(<meta[^>]* ?name=["']segIds["'] ?[^>]*>)/){
		my $text = $1;
		if($text =~ m/content=["']([^"']+)["']/){
			$segIds = $1;
		}
	}

	my $id1;
	if($segIds =~ m/^([^#]*)#/){
		$id1 = $1;
	}

	my $title;
	if($browser->{content} =~ m/<meta property=["']og:title["'] content=["']([^"']+)["']\/>/){
		$title = $1;
	}

	my $configURL = "/tools/swf/player_configs/watch_player.xml";

		if($browser->content =~ /pageObj\.configURL = ["']([^"']+)["'];/) {
			$configURL = $1;
		}

	$browser->get($configURL);

	my $serviceConfigURL;

	if($browser->response->code =~ /^30\d$/){

		$xml = from_xml($browser);

		if($xml->{serviceConfigURL} ne ""){
			$serviceConfigURL = $1;
		}
	} else {
		$serviceConfigURL = "http://asfix.adultswim.com/staged/AS.configuration.xml";
	}

	$browser->get($serviceConfigURL);

	$xml = from_xml($browser);

	my $getVideoPlayerURL;
	if($xml->{config}->{services}->{getVideoPlaylist}->{url} ne ""){
		$getVideoPlayerURL = $1;
	} else {
		$getVideoPlayerURL = "http://asfix.adultswim.com/asfix-svc/episodeservices/getVideoPlaylist?networkName=AS";
	}

	my $videoURL = "$getVideoPlayerURL&id=$id1";
	$browser->get($videoURL);

	$xml = from_xml($browser);



	my $pick = $xml->{entry}[4];

	my $file_url = $pick->{ref}->{href};


	return $file_url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Adultswim.pm
BEGIN { $INC{'FlashVideo/Site/Amazon.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Amazon.pm
{
package FlashVideo::Site::Amazon;

use strict;

use Encode;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

my $playlist_url_template = 'http://%s/gp/mpd/getplaylist-v2/%s/%s';

sub find_video {
  my ($self, $browser) = @_;

  my $amazon_host = $browser->uri()->host();

  if ($browser->content =~ /swfParams\.xmlUrl = ["'](http:.*?)["']/) {
    debug "Getting Amazon URL direct URL $1";
    $browser->get($1);
  }
  else {
    my ($video_id, $session_id);
    
    if ($browser->content =~
      /swfParams\.mediaObjectId = ["'](.*?)["']/) {
      $video_id = $1;
    }
    else {
      die "Couldn't find video ID / media object ID in Amazon page";
    }

    if ($browser->content =~
      /swfParams\.sessionId = ["'](.*?)["']/) {
      $session_id = $1;
    }
    else {
      die "Couldn't find session ID in Amazon page";
    }

    my $playlist_url =
      sprintf($playlist_url_template, $amazon_host, $video_id, $session_id);

    $browser->get($playlist_url);
  }

  my ($title, @video_urls) = parse_smil_like_xml($browser->content);

  my $filename = title_to_filename($title);

  return $video_urls[0], $filename;
}

sub parse_smil_like_xml {
  my $smil = shift;

  my $parsed_smil = from_xml($smil);


  my $title;

  my $video_ref = $parsed_smil->{videoObject}->{smil}->{body}->{switch}->{video}; 
  if (ref($video_ref) ne 'ARRAY') {
    my $id;

    my %videos = %{ $parsed_smil->{videoObject} };

    foreach my $video (keys %videos) {
      next unless ref $videos{$video};

      if ($videos{$video}->{index} == 0) {
        $id = $video;
        $title = $videos{$video}->{title};
        last;
      }
    }

    $video_ref = $parsed_smil->{videoObject}->{$id}->{smil}->{body}->{switch}->{video}; 
  }

  my @different_quality_videos = map { $_->{src} }
                                 sort { $b->{'system-bitrate'} <=> $a->{'system-bitrate'} }
                                 @$video_ref;

  $title ||= $parsed_smil->{videoObject}->{title};

  if ($title !~ /\s/) {
    $title = uri_unescape($title);
  }

  return ($title, @different_quality_videos);
}

1;
}
##} blib/lib/FlashVideo/Site/Amazon.pm
BEGIN { $INC{'FlashVideo/Site/Aniboom.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Aniboom.pm
{
package FlashVideo::Site::Aniboom;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my ($id, $url, $title);

  if ($browser->uri->as_string =~ /\/animation-video\/(\d*)\/([^\/]*)/) {
    $id = $1;
    $title = $2;
    $title =~ s/-/ /g;
  } else {
    die "Could not detect video ID!";
  }
  
  $browser->get("http://www.aniboom.com/animations/player/handlers/animationDetails.aspx?mode=&movieid=$id");

  if ($browser->content =~ /(?:mp4|flv)=([^&]*)/) {
    $url = $1;
    $url =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  } else {
    die "Could not get flv/mp4 location!";
  }
  
  return $url, title_to_filename($title);
}

1;

}
##} blib/lib/FlashVideo/Site/Aniboom.pm
BEGIN { $INC{'FlashVideo/Site/Apple.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Apple.pm
{
package FlashVideo::Site::Apple;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  if(!FlashVideo::Downloader->check_file($browser->content)) {
    my @urls = $browser->content =~ /['"]([^'"]+\.mov)(?:\?[^'"]+)?['"]/g;
    die "No .mov URLs found on page" unless @urls;
    debug "Found URLs: @urls";

    my $redirect_url = $prefs->quality->choose(map {
        /(\d+p?)\.mov/ && {
          url => $_,
          resolution => $prefs->quality->format_to_resolution($1)
        }
      } @urls
    )->{url};

    $browser->get($redirect_url);
  }

  my $url = $self->handle_mov($browser);
  my $filename = ($url->path =~ m{([^/]+)$})[0];

  return $url, $filename;
}

sub handle_mov {
  my ($self, $browser) = @_;

  $browser->agent("Apple iPhone OS v2.0.1 CoreMedia v1.0.0.5B108");

  if($browser->content =~ /url\s*\0+[\1-,]*(.*?)\0/) {
    return URI->new_abs($1, $browser->uri)
  } else {
    die "Cannot find link in .mov";
  }
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $url =~ m{apple\.com/trailers/} || $url =~ m{movies\.apple\.com};
}

1;
}
##} blib/lib/FlashVideo/Site/Apple.pm
BEGIN { $INC{'FlashVideo/Site/Arte.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Arte.pm
{
package FlashVideo::Site::Arte;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  my ($lang, $xmlurl1, $xmlurl2, $filename, $videourl, $hash, $playerurl, $quality);

  debug "Arte::find_video called, embed_url = \"$embed_url\"\n";

  my $pageurl = $browser->uri() . "";
  if($pageurl =~ /videos\.arte\.tv\/(..)\//) {
    $lang = $1;
  } else {
    die "Unable to find language in original URL \"$pageurl\"\n";
  }

  if($browser->content =~ /videorefFileUrl = "(.*)";/) {
    $xmlurl1 = $1;
    debug "found videorefFileUrl \"$xmlurl1\"\n";
    ($filename = $xmlurl1) =~ s/-.*$//;
    $filename =~ s/^.*\///g;
    $filename = title_to_filename($filename);
  } else {
    die "Unable to find 'videorefFileUrl' in page\n";
  }

  if($browser->content =~ /<param name="movie" value="(http:\/\/videos\.arte\.tv\/[^\?]+)\?/) {
    $playerurl = $1;
    debug "found playerurl \"$playerurl\"\n";
  }

  $browser->get($xmlurl1);

  if($browser->content =~ /<video lang="$lang" ref="(.*)"\/>/) {
    $xmlurl2 = $1;
    debug "found <video ref=\"$xmlurl2\">\n";
  } else {
    die "Unable to find <video ref...> in XML $xmlurl1\n";
  }

  $browser->get($xmlurl2);
  $quality = {high => 'hd', low => 'sd'}->{$prefs->{quality}};

  if($browser->content =~ /<url quality="$quality">([^<]+)<\/url>/) {
    $videourl = { rtmp => $1,
		flv => $filename};
    if(defined $playerurl) {
      $videourl->{swfVfy} = $playerurl;
    }
  } else {
    die "Unable to find <url ...> in XML $xmlurl2\n";
  }

  return $videourl, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Arte.pm
BEGIN { $INC{'FlashVideo/Site/Bbc.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Bbc.pm
{
package FlashVideo::Site::Bbc;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI->import(); } # (added by utils/combine-perl.pl)

sub find_video {
  my ($self, $browser, $page_url, $prefs) = @_;

  my $count = 0;
  while((my $location = $browser->response->header("Location")) && $count++ < 5) {
    $browser->get($location);
  }

  my $playlist_xml;
  if ($browser->content =~ /<param name="playlist" value="(http:.+?\.s?xml)"/) {
    $playlist_xml = $1;
  }
  elsif($browser->content =~ /empDivReady\s*\(([^)]+)/) {
    my @params = split /,\s*/, $1;

    my $id   = $params[3];
    my $path = $params[4];

    $id   =~ s/['"]//g;
    $path =~ s/['"]//g;

    $playlist_xml = URI->new_abs($path, $browser->uri) . "/media/emp/playlists/$id.xml";
  }
  elsif($browser->content =~ /setPlaylist\s*\(([^)]+)/) {
    my $path = $1;
    $path =~ s/['"]//g;
    $playlist_xml = URI->new_abs($path, $browser->uri);
  }
  elsif($browser->content =~ /EmpEmbed.embed\s*\((.*?)\);/) {
    my $path = (split /,/, $1)[3];
    $path =~ s/"//g;
    $playlist_xml = URI->new_abs($path, $browser->uri);
  }
  elsif($browser->uri =~ m!/(b[0-9a-z]{7})(?:/|$)!) {
    my @gi_cmd = (qw(get_iplayer -g --pid), $1);

    if($browser->content =~ /buildAudioPlayer/) {
      push @gi_cmd, "--type=radio";
    }

    error "get_flash_videos does not support iplayer, but get_iplayer does..";
    info "Attempting to run '@gi_cmd'";
    exec @gi_cmd;
    error "Please download get_iplayer from http://linuxcentre.net/getiplayer/\n" .
      "and install in your PATH";
    exit 1;
  }
  else {
    die "Couldn't find BBC XML playlist URL in " . $browser->uri->as_string;
  }

  $browser->get($playlist_xml);
  if (!$browser->success) {
    die "Couldn't download BBC XML playlist $playlist_xml: " .
      $browser->response->status_line;
  }

  my $playlist = eval { from_xml($browser, KeyAttr => {item => 'kind'}) };

  if ($@) {
    my $content = $browser->content;
    if ($content !~ m{</media>}) {
      $content .= "\n</media></item></playlist>\n";
    }
    $playlist = from_xml($$content, KeyAttr => {item => 'kind'})
  }

  my $sound = ($playlist->{item}->{guidance} !~ /has no sound/);

  my $info = ref $playlist->{item}->{media} eq 'ARRAY'
    ? $playlist->{item}->{media}->[0]->{connection}
    : $playlist->{item}->{media}->{connection};

  $info = $playlist->{item}->{programme}->{media}->{connection} unless $info;

  $info->{application} ||= "ondemand";

  if (!$info->{server}) {
    my $id = $playlist->{item}->{mediator}->{identifier};
    if(!$id) { $id = $playlist->{item}->{programme}->{mediator}->{identifier}; }

    my $stream_info_url = sprintf
      "http://open.live.bbc.co.uk/mediaselector/4/mtis/stream/%s", $id;

    $browser->back();
    $browser->get($stream_info_url);

    if (!$browser->success) {
      die "Couldn't get BBC stream info URL: " .
        $browser->response->status_line;
    }

    my $stream_info = from_xml($browser->content);

    if( ref $stream_info->{media} eq 'ARRAY' ){
      my $q = $prefs->{quality};
      my @media = sort { $a->{bitrate} <=> $b->{bitrate} } @{$stream_info->{media}};
      my @q_media = grep { $_->{bitrate} == $q || "$_->{height}x$_->{width}x$_->{bitrate}" == $q || "$_->{height}x$_->{width}" == $q } @media;
      if( @q_media ){ @media = @q_media; }
      my $cnt = @media;
      my $num = {high => int($cnt)-1, medium => int($cnt/2), low => 0}->{$q};
      $info = $media[$num]->{connection};
    } else {
      $info = $stream_info->{media}->{connection};
    }
  }

  if( $info->{href} ){
    my $url = $info->{href};
    my @path = URI->new($url)->path_segments();
    return $url, @path[-1];
  }

  my $data = {
    app      => $info->{application},
    tcUrl    => "rtmp://$info->{server}/$info->{application}",
    swfUrl   => "http://news.bbc.co.uk/player/emp/2.11.7978_8433/9player.swf",
    pageUrl  => $page_url,
    rtmp     => "rtmp://" .  $info->{server} . "/$info->{application}",
    playpath => $info->{identifier},
    flv      => title_to_filename('BBC - ' . $playlist->{title} .
                                ($sound ? '' : ' (no sound)'))
  };

  if ($info->{authString}) {
    my $token = $info->{authString};

    $data->{app} = "$info->{application}?_fcs_vhost=$info->{server}" .
                   "&$token";
                    
    $data->{tcUrl} = "rtmp://$info->{server}/$info->{application}?_fcs_vhost=$info->{server}"
            . "&$token";

    $data->{playpath} .= "?$token";
  }

  if ($info->{identifier} =~ /^secure/ or $info->{tokenIssuer}) {
    my $url = "http://www.bbc.co.uk/mediaselector/4/gtis?server=$info->{server}" .
              "&identifier=$info->{identifier}&kind=$info->{kind}" .
              "&application=$info->{application}&cb=123";

    debug "Got BBC auth URL for 'secure' video: $url";

    $browser->get($url);

    if (my $redirect = $browser->response->header('Location')) {
      debug "BBC auth URL redirects to: $url";
      $browser->get($redirect);
    }

    my $stream_auth = from_xml($browser);

    my $token = $stream_auth->{token};

    if (!$token) {
      die "Couldn't get token for 'secure' video download";
    }

    $data->{app} = "$info->{application}?_fcs_vhost=$info->{server}"
            . "&auth=$token"
            . "&aifp=v001&slist=" . $info->{identifier};
    $data->{tcUrl} = "rtmp://$info->{server}/$info->{application}?_fcs_vhost=$info->{server}"
            . "&auth=$token"
            . "&aifp=v001&slist=" . $info->{identifier};
    $data->{playpath} .= "?auth=$token&aifp=v0001";

    if($info->{application} eq 'live') {
      $data->{subscribe} = $data->{playpath};
      $data->{live} = 1;
    }
  }

  return $data;
}

1;
}
##} blib/lib/FlashVideo/Site/Bbc.pm
BEGIN { $INC{'FlashVideo/Site/Bing.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Bing.pm
{
package FlashVideo::Site::Bing;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  my $count = 0;
  while((my $location = $browser->response->header("Location")) && $count++ < 5) {
    $browser->get($location);
  }

  my $title;
  if ($browser->content =~ /sourceFriendly:\s*'([^']+)'[\s\S]+?\s*title:\s*'([^']+)'/) {
    $title = "$1 - $2";
  }

  my $url;
  if ($browser->content =~ /formatCode:\s*1003,\s*url:\s*'([^']+)'/) {
    $url = $1;

    $url =~ s/\\x([0-9a-f]{2})/chr hex $1/egi;
  }
  die "Unable to extract video url" unless $url;

  $browser->allow_redirects;

  return $url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Bing.pm
BEGIN { $INC{'FlashVideo/Site/Blip.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Blip.pm
{
package FlashVideo::Site::Blip;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;
  my $base = "http://blip.tv";

  my $id;
  if($embed_url =~ m{flash/(\d+)}) {
    $id = $1;
  } else {
    $browser->get($embed_url);

    if($browser->response->is_redirect
        && $browser->response->header("Location") =~ m!(?:/|%2f)(\d+)!i) {
      $id = $1;
    } else {
      $id = ($browser->content =~ m!/rss/flash/(\d+)!)[0];
    }
  }

  if (!$id) {
    if ($browser->content =~ /post_masthed_(\d+)/) {
      $id = $1;
    }
  }

  if (!$id) { ($id) = ($browser->content =~ m{data-posts-id="(\d+)"}s); }
  if (!$id) { ($id) = ($browser->content =~ m{data-disqus-id="(\d+)"}s); }
  if (!$id) { ($id) = ($browser->content =~ m{content="http://[^"]-(\d+)"}s); }

  die "No ID found\n" unless $id;

  $browser->get("$base/rss/flash/$id");

  my $xml = from_xml($browser);

  my $content = $xml->{channel}->{item}->{"media:group"}->{"media:content"};

  my $url = ref $content eq 'ARRAY' ? $content->[0]->{url} : $content->{url};

  my $filename = title_to_filename($xml->{channel}->{item}->{title}, $url);

  $browser->allow_redirects;

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Blip.pm
BEGIN { $INC{'FlashVideo/Site/Break.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Break.pm
{
package FlashVideo::Site::Break;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my($self, $browser, $embed_url) = @_;

  my $video_id;

  if ($browser->content =~ /flashVars\.icon = ["'](\w+)["']/) {
    $video_id = $1;
  }
  else {
    die "Couldn't get Break video ID";
  }

  if($browser->content =~ /<meta name=['"]embed_video_url['"] content=["']([^'"]*)["']/) {
    $browser->get($1);
  }

  if(URI->new($embed_url)->host eq "embed.break.com") {
    $browser->get($embed_url);
  }

  if($browser->uri->host eq "embed.break.com") {
    if(!$browser->success && $browser->response->header('Location') !~ /sVidLoc/) {
      $browser->get($browser->response->header('Location'));
    }

    if($browser->response->header("Location") =~ /sVidLoc=([^&]+)/) {
      my $url = uri_unescape($1).'?'.$video_id;
      my $filename = title_to_filename((split /\//, $url)[-1]);

      return $url, $filename;
    }
  }

  my $path = ($browser->content =~ /sGlobalContentFilePath='([^']+)'/)[0];
  my $filename = ($browser->content =~ /sGlobalFileName='([^']+)'/)[0];

  die "Unable to extract path and filename" unless $path and $filename;

  my $video_path = ($browser->content =~ /videoPath\s*(?:',|=)\s*['"]([^'"]+)/)[0];

  $browser->allow_redirects;

  return $video_path . $path . "/" . $filename . ".flv" . "?" . $video_id,
    title_to_filename($filename);
}

1;
}
##} blib/lib/FlashVideo/Site/Break.pm
BEGIN { $INC{'FlashVideo/Site/Canalvie.pm'}++; }
#############################################################################
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
#	Canalvie.pm												2010-11-25
#
#	Reverse-engineered using URLSnooper v2.28.01 & WinPcap 4.1.2
#
#	Stavr0
#
#
##{ blib/lib/FlashVideo/Site/Canalvie.pm
{
{
package FlashVideo::Site::Canalvie;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;

  my $check_response = sub {
    my ( $message ) = @_;
    return if $browser->success;
    die sprintf $message, $browser->response->code;
  };


  my $videoID = 0;

  ( $videoID ) = ( $browser->content =~ /var\s+videoId\s*=\s*(\d+)\s*;/ );
  debug "VIDEOID = " . $videoID;
  
  die "No Canalvie Video ID found" unless  $videoID;
  
  my $title;
  ( $title ) = ( $browser->content =~ /NOM EPISODE\+LIEN ici --><a [^>]+>([^<]+)/ );
  debug "TITLE = " . $title . " " . title_to_filename($title, 'flv');
 
  my $xmlurl = 'http://www.canalvie.com/webtele/_dyn/getVideoDataXml.jsp?videoId=' . $videoID;
  $browser->get($xmlurl);
  my $xml = from_xml($browser);
  
  my $url;
  if ( $prefs->{quality} == "high" ) {
	$url = $xml->{video}->{highFlvUrl};
  } else {		
  	$url = $xml->{video}->{lowFlvUrl};
  }
  debug "URL = " . $url;
  
  my $ext;
  ( $ext ) = ( $url =~ /\.(.+)$/ );

  die "No (high|low)FlvUrl found in XML ". $xmlurl unless $url;
  
  return $url, title_to_filename($title, $ext);
  
 }


1;
}
}
##} blib/lib/FlashVideo/Site/Canalvie.pm
BEGIN { $INC{'FlashVideo/Site/Canoe.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Canoe.pm
{
package FlashVideo::Site::Canoe;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; }
BEGIN { FlashVideo::Site::Brightcove->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Brightcove';

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_id  = ($browser->content =~ /player.SetVideo.(\d+)/i)[0];
  my $player_id = ($browser->content =~ /player.SetPlayer.(\d+)/i)[0];

  debug "Extracted playerId: $player_id, videoId: $video_id"
    if $player_id or $video_id;

  if(!$video_id) {
    my $video_offset = ($browser->content =~ /player.SetVideo.\w+\[(\d+)/i)[0];
    $video_id = ($browser->content =~ /videos\[$video_offset\].+'(\d+)'\s*\]/)[0];
  }

  die "Unable to extract Brightcove IDs from page"
    unless $player_id and $video_id;

  return $self->amfgateway($browser, $player_id, { videoId => $video_id, } );
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->content =~ /player = CanoeVideoStandalone\.create\(\);/i;
}

1;
}
##} blib/lib/FlashVideo/Site/Canoe.pm
BEGIN { $INC{'FlashVideo/Site/Cartoonnetwork.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Cartoonnetwork.pm
{
package FlashVideo::Site::Cartoonnetwork;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
use POSIX();

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_id;
  if ($browser->uri->as_string =~ /episodeID=([a-z0-9]*)/) {
    $video_id = $1;
  }

  $browser->get("http://www.cartoonnetwork.com/cnvideosvc2/svc/episodeSearch/getEpisodesByIDs?ids=$video_id");
  my $xml = from_xml($browser);
  my $episodes = $xml->{episode};
  my $episode = ref $episodes eq 'ARRAY' ?
    (grep { $_->{id} eq $video_id } @$episodes)[0] :
    $episodes;

  my $title = $episode->{title};

  my @gmtime = gmtime;
  $gmtime[1] = 15 * int($gmtime[1] / 15);
  my $date = POSIX::strftime("%m%d%Y%H%M", @gmtime);

  my $url;
  foreach my $key (keys (%{$episode->{segments}->{segment}})){
    my $content_id = $key;
    $browser->post("http://www.cartoonnetwork.com/cnvideosvc2/svc/episodeservices/getVideoPlaylist",
      Content  => "id=$content_id&r=$date"
    );

    if ($browser->content =~ /<ref href="([^"]*)" \/>/){
      $url = $1;
    }
  }

  return $url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Cartoonnetwork.pm
BEGIN { $INC{'FlashVideo/Site/Cbs.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Cbs.pm
{
package FlashVideo::Site::Cbs;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $pid;
  if ($browser->uri->as_string =~ /pid=([^&]*)/) {
    $pid = $1;
  }

  $browser->get("http://release.theplatform.com/content.select?format=SMIL&Tracking=true&balance=true&MBR=true&pid=$pid");

  my $xml = from_xml($browser->content);

  my $items = $xml->{body}->{switch};
  my $item = ref $items eq 'ARRAY' ?
    (grep { $_->{video}->{src} =~ /^rtmp:\/\// } @$items)[0] :
    $items;

  my $rtmpurl = $item->{video}->{src};
  $rtmpurl =~ s/<break>.*//;
  my $title = $item->{ref}->{title};

  return {
    rtmp => $rtmpurl,
    flv => title_to_filename($title)
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Cbs.pm
BEGIN { $INC{'FlashVideo/Site/Cbsnews.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Site/Cnet.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Cnet.pm
{
package FlashVideo::Site::Cnet;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

my $cnet_api_base = "http://api.cnet.com";
my $cnet_api_rest = $cnet_api_base . "/restApi/v1.0";
my $cnet_api_video_search = $cnet_api_rest . "/videoSearch";


sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_id;

  if($browser->content =~ /<param name="FlashVars" value="playerType=embedded&type=id&value=([0-9]+)" \/>/) {
    $video_id = $1;
  } elsif($browser->content =~ /assetId: '([0-9]+)',/) {
    $video_id = $1;
  } else {
    die "Could not find video ID; you may have to click the 'share' link on the flash player to get the permalink to the video.";
  }

  return $self->get_video($browser, $video_id);
}

sub get_video {
  my ($self, $browser, $video_id) = @_;

  $browser->get($cnet_api_video_search . "?videoIds=" . $video_id . "&iod=videoMedia&players=RTMP");

  my $xml = from_xml($browser->content, NoAttr => 1);

  my $video = $xml->{"Videos"}->{"Video"};

  my $medias = $video->{"VideoMedias"}->{"VideoMedia"};

  my $max = 0;
  foreach (@{$video->{VideoMedias}->{VideoMedia}}) {
    if(int($_->{Width}) * int($_->{Height}) > $max){
      $max = int($_->{Width}) * int($_->{Height});
    }
  }
  my $media = (grep { (int($_->{Width}) * int($_->{Height})) eq $max } @$medias)[0];
  my $delivery_url = $media->{DeliveryUrl};

  my $title = $video->{FranchiseName} . ' - ' . $video->{Title};

  if($media->{Player} eq 'RTMP'){
    return {
      rtmp => $delivery_url,
      flv => title_to_filename($title)
    };
  } elsif($media->{Player} eq 'Download'){
    return $delivery_url, title_to_filename($title)
  }
}

1;

}
##} blib/lib/FlashVideo/Site/Cnet.pm
##{ blib/lib/FlashVideo/Site/Cbsnews.pm
{
package FlashVideo::Site::Cbsnews;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { FlashVideo::Site::Cnet->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Cnet';

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_id;
  if($browser->content =~ /CBSVideo\.setVideoId\(["']([0-9]+)["']\)/) {
    $video_id = $1;
  } else {
    die "Could not find video id. If this is a valid CBS News video, please file a bug report at http://code.google.com/p/get-flash-videos/issues";
  }
  return $self->get_video($browser, $video_id);
}

1;
}
##} blib/lib/FlashVideo/Site/Cbsnews.pm
BEGIN { $INC{'FlashVideo/Site/Channel4.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
# Thanks to Nibor for his XBMC 4od plugin - this is largely a Perl port of
# it.
BEGIN { $INC{'Crypt/Blowfish_PP.pm'}++; }
# This is Crypt/Blowfish_PP.pm which is an implementation of Bruce Schneier's
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
#   blowfish cryptographic algorithm. I will write some proper docs when I get
#   time....
#   code is (c) copyright Matthew Byng-Maddick <mbm@colondot.net> 2000-2001, and
#   some bits are copyright Bruce Schneier. For more information see his website
#   at http://www.counterpane.com/

##{ /usr/local/libdata/perl5/site_perl/Crypt/Blowfish_PP.pm
{
package Crypt::Blowfish_PP;

use strict;
use vars qw($VERSION);

$VERSION="1.12";


sub new
	{
	my $pack=shift;
	my $key=shift;
	return undef if(!defined($key));
	my %h=(
		p_boxes	=>
			[
			0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
			0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
			0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
			0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
			0x9216d5d9, 0x8979fb1b
			],
		s_boxes =>
			[
				[
				0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
				0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
				0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
				0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
				0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
				0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
				0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
				0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
				0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
				0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
				0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
				0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
				0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
				0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
				0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
				0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
				0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
				0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
				0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
				0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
				0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
				0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
				0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
				0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
				0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
				0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
				0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
				0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
				0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
				0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
				0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
				0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
				0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
				0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
				0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
				0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
				0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
				0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
				0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
				0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
				0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
				0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
				0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
				0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
				0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
				0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
				0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
				0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
				0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
				0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
				0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
				0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
				0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
				0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
				0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
				0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
				0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
				0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
				0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
				0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
				0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
				0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
				0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
				0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
				],
				[
				0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
				0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
				0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
				0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
				0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
				0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
				0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
				0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
				0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
				0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
				0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
				0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
				0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
				0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
				0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
				0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
				0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
				0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
				0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
				0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
				0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
				0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
				0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
				0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
				0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
				0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
				0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
				0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
				0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
				0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
				0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
				0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
				0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
				0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
				0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
				0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
				0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
				0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
				0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
				0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
				0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
				0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
				0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
				0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
				0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
				0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
				0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
				0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
				0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
				0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
				0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
				0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
				0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
				0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
				0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
				0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
				0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
				0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
				0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
				0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
				0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
				0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
				0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
				0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
				],
				[
				0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
				0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
				0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
				0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
				0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
				0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
				0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
				0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
				0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
				0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
				0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
				0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
				0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
				0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
				0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
				0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
				0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
				0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
				0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
				0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
				0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
				0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
				0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
				0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
				0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
				0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
				0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
				0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
				0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
				0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
				0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
				0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
				0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
				0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
				0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
				0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
				0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
				0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
				0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
				0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
				0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
				0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
				0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
				0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
				0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
				0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
				0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
				0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
				0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
				0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
				0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
				0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
				0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
				0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
				0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
				0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
				0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
				0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
				0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
				0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
				0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
				0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
				0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
				0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
				],
				[
				0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
				0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
				0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
				0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
				0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
				0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
				0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
				0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
				0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
				0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
				0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
				0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
				0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
				0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
				0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
				0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
				0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
				0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
				0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
				0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
				0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
				0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
				0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
				0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
				0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
				0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
				0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
				0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
				0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
				0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
				0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
				0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
				0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
				0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
				0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
				0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
				0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
				0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
				0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
				0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
				0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
				0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
				0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
				0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
				0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
				0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
				0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
				0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
				0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
				0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
				0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
				0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
				0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
				0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
				0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
				0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
				0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
				0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
				0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
				0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
				0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
				0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
				0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
				0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
				]
			]
		);
	my $keylen=length($key);
	return undef if(($keylen < 8) || ($keylen > 56));
	my @keybytes=split//,$key;
	my $b;
	for $b (@keybytes)
		{
		$b=unpack("C",$b);
		}
	my $j=0;
	my $i=0;
	my($l,$r)=(0,0);

	for ($i=0;$i<18;$i++)
		{
		my $temp=	($keybytes[$j]<<24) +
				($keybytes[($j+1)%($keylen)]<<16) +
				($keybytes[($j+2)%($keylen)]<<8) +
				($keybytes[($j+3)%($keylen)]) ;
		$h{"p_boxes"}->[$i]^=$temp;
		$j=($j+4)%($keylen);
		}
	for ($i=0;$i<18;$i+=2)
		{
		($l,$r)=crypt_block(\%h,$l,$r,0);
		$h{"p_boxes"}->[$i]=$l;
		$h{"p_boxes"}->[$i+1]=$r;
		}
	for $i (0..3)
		{
		for($j=0;$j<256;$j+=2)
			{
			($l,$r)=crypt_block(\%h,$l,$r,0);
			$h{"s_boxes"}->[$i]->[$j]=$l;
			$h{"s_boxes"}->[$i]->[$j+1]=$r;
			}
		}
	return bless \%h, $pack;
	}

sub F
	{
	my $S0=$_[0]->{"s_boxes"}->[0]->[($_[1]&0xFF000000)>>24];
	my $S1=$_[0]->{"s_boxes"}->[1]->[($_[1]&0x00FF0000)>>16];
	my $S2=$_[0]->{"s_boxes"}->[2]->[($_[1]&0x0000FF00)>>8];
	my $S3=$_[0]->{"s_boxes"}->[3]->[($_[1]&0x000000FF)];
	if($S0>$S1)
		{
		$S0=$S0-4294967296 if($S0>2147483647);
		}
	else
		{
		$S1=$S1-4294967296 if($S1>2147483647);
		}
	my $F=($S0+$S1);
	$F+=4294967296 if($F<0);
	$F^=$S2;
	if($F>$S3)
		{
		$F=$F-4294967296 if($F>2147483647);
		}
	else
		{
		$S3=$S3-4294967296 if($S3>2147483647);
		}
	$F+=$S3;
	$F&=0xFFFFFFFF;
	return $F;
	}

sub ROUND
	{
	return($_[1],($_[2]^($_[0]->{"p_boxes"}->[$_[3]]))^F($_[0],$_[1]));
	}

sub crypt_block
	{
	my $self=shift;
	my $l=shift;
	my $r=shift;
	my $d=shift;
	if(!$d)
		{
		$l^=$self->{"p_boxes"}->[0];
		my $i;
		for $i (1..16)
			{
			($r,$l)=ROUND($self,$l,$r,$i);
			}
		$r^=$self->{"p_boxes"}->[17];
		}
	else
		{
		$l^=$self->{"p_boxes"}->[17];
		my $i;
		for $i (1..16)
			{
			($r,$l)=ROUND($self,$l,$r,17-$i);
			}
		$r^=$self->{"p_boxes"}->[0];
		}
	return($r,$l);
	}


sub encrypt
	{
	my($self)=shift;
	my($block)=shift;
	my(@block)=split//,$block;
	map{$_=unpack("C",$_)}@block;
	my($l)=$block[3]|($block[2]<<8)|($block[1]<<16)|($block[0]<<24);
	my($r)=$block[7]|($block[6]<<8)|($block[5]<<16)|($block[4]<<24);
	
	($l,$r)=crypt_block($self,$l,$r,0);

	@block=(
		$l>>24,($l>>16)&0xFF,($l>>8)&0xFF,$l&0xFF,
		$r>>24,($r>>16)&0xFF,($r>>8)&0xFF,$r&0xFF
		);
	map{$_=pack("C",$_)}@block;
	return join"",@block;
	}


sub decrypt
	{
	my($self)=shift;
	my($block)=shift;
	my(@block)=split//,$block;
	map{$_=unpack("C",$_)}@block;
	my($l)=$block[3]|($block[2]<<8)|($block[1]<<16)|($block[0]<<24);
	my($r)=$block[7]|($block[6]<<8)|($block[5]<<16)|($block[4]<<24);
	
	($l,$r)=crypt_block($self,$l,$r,1);

	@block=(
		$l>>24,($l>>16)&0xFF,($l>>8)&0xFF,$l&0xFF,
		$r>>24,($r>>16)&0xFF,($r>>8)&0xFF,$r&0xFF
		);
	map{$_=pack("C",$_)}@block;
	return join"",@block;
	}

sub blocksize
	{
	return 8;
	}

sub keysize
	{
	return 56;
	}


1;
}
##} /usr/local/libdata/perl5/site_perl/Crypt/Blowfish_PP.pm
##{ blib/lib/FlashVideo/Site/Channel4.pm
{
package FlashVideo::Site::Channel4;

use strict;

BEGIN { Crypt::Blowfish_PP->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *convert_sami_subtitles_to_srt = \&FlashVideo::Utils::convert_sami_subtitles_to_srt; *from_xml = \&FlashVideo::Utils::from_xml; }
use MIME::Base64;

use constant TOKEN_DECRYPT_KEY => 'STINGMIMI';

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  my $page_url = $browser->uri->as_string;

  my $asset_id;

  if ($page_url =~ m'(?:4od/player/|4od#)(\d+)') {
    $asset_id = $1;
  }
  else {
    die "Can't get asset ID";
  }

  my $raw_xml = $browser->get("http://ais.channel4.com/asset/$asset_id");

  if (!$browser->success) {
    die "Couldn't get asset XML: " . $browser->status_line;
  }

  my $xml = from_xml($raw_xml);

  my $stream_url = $xml->{assetInfo}->{uriData}->{streamUri};
  my $token      = $xml->{assetInfo}->{uriData}->{token};
  my $cdn        = $xml->{assetInfo}->{uriData}->{cdn};

  my $decoded_token = decode_4od_token($token);

  my $auth;

  if ($cdn eq 'll') {
    my $ip = $xml->{assetInfo}->{uriData}->{ip};
    my $e  = $xml->{assetInfo}->{uriData}->{e};

    $auth = sprintf "e=%s&ip=%s&h=%s", $e, $ip, $decoded_token;
  }
  else {
    my $fingerprint = $xml->{assetInfo}->{uriData}->{fingerprint};
    my $slist       = $xml->{assetInfo}->{uriData}->{slist};

    $auth = sprintf "auth=%s&aifp=%s&slist=%s",
      $decoded_token, $fingerprint, $slist;
  }

  my $title;
  my @title_components = grep defined,
                         map { $xml->{assetInfo}->{$_} }
                         qw(brandTitle episodeTitle);

  if (@title_components) {
    $title = join " - ", @title_components;
  }
  
  my $filename = title_to_filename($title, "mp4");

  if ($prefs->subtitles) {
    if (my $subtitles_url = $xml->{assetInfo}->{subtitlesFileUri}) {
      $subtitles_url = "http://ais.channel4.com$subtitles_url";
      
      $browser->get($subtitles_url);

      if (!$browser->success) {
        info "Couldn't download 4od subtitles: " . $browser->status_line;
      }

      my $subtitles_file = title_to_filename($title, "srt");
      convert_sami_subtitles_to_srt($browser->content, $subtitles_file); 

      info "Saved subtitles to $subtitles_file";
    }
    else {
      debug("Subtitles requested for '$title' but none available.");
    }
  }

  my $rtmp_url;
  
  if ($stream_url =~ /(.*?)mp4:/) {
    $rtmp_url = $1;
  }

  $rtmp_url =~ s{\.com/}{.com:1935/};
  $rtmp_url .= "?ovpfv=1.1&$auth";
  
  my $app;
  if ($stream_url =~ /.com\/(.*?)mp4:/) {
    $app = $1;
    $app .= "?ovpfv=1.1&$auth";
  }

  my $playpath;
  if ($stream_url =~ /.*?(mp4:.*)/) {
    $playpath = $1;
    $playpath .= "?$auth";
  }

  return {
    flv      => $filename,
    rtmp     => $rtmp_url,
    flashVer => '"WIN 10,3,183,7"',
    swfVfy   => "http://www.channel4.com/static/programmes/asset/flash/swf/4odplayer-11.8.5.swf",
    conn     => 'Z:',
    playpath => $playpath,
    app      => $app,
  };
}

sub decode_4od_token {
  my $encrypted_token = shift;

  $encrypted_token = decode_base64($encrypted_token);

  my $blowfish = Crypt::Blowfish_PP->new(TOKEN_DECRYPT_KEY);

  my $decrypted_token = '';

  my $position = 0;

  while ( ($position + 8) < length $encrypted_token) {
    $decrypted_token .= $blowfish->decrypt(substr $encrypted_token, $position, 8);
    $position += 8;
  }

  return $decrypted_token;
}

1;
}
##} blib/lib/FlashVideo/Site/Channel4.pm
BEGIN { $INC{'FlashVideo/Site/Collegehumor.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Collegehumor.pm
{
package FlashVideo::Site::Collegehumor;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;
  my $base = "http://www.collegehumor.com/moogaloop";

  my $id;
  if($browser->content =~ /video:(\d+)/) {
    $id = $1;
  } elsif($embed_url =~ m![/:](\d+)!) {
    $id = $1;
  }
  die "No ID found\n" unless $id;

  $browser->get("$base/video:$id");

  my $xml = from_xml($browser);

  my $title = $xml->{video}->{caption};
  $title = extract_title($browser) if ref $title;

  return $xml->{video}->{file}, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Collegehumor.pm
BEGIN { $INC{'FlashVideo/Site/Ctv.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
#
#	Handler module for CTV Canadian broadcaster
#	- Requires RTMPDUMP
#	- Expects an URL in the form of: http://watch.ctv.ca/ $show / $season / $episode /
#	- Each show is split in clips intersected with commercial breaks, so there will be several calls to RTMPDUMP
#	- Streams are restricted to Canadian ISPs
#
#	Stavr0
#
##{ blib/lib/FlashVideo/Site/Ctv.pm
{
package FlashVideo::Site::Ctv;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; }

sub find_video {
  my($self, $browser, $page_url) = @_;

  my $entityid = ($browser->content =~ /<meta name="EntityId" content="(\d+)"/i)[0];
  debug "EntityID = " . $entityid;

  die "Couldn't find EntityId in <meta> tags" unless $entityid;

  $browser->get("http://watch.ctv.ca/AJAX/ClipLookup.aspx?callfunction=Playlist.GetInstance.AddEpisodeClipsAfter&episodeid=$entityid&maxResults=99");
  die "Couldn't download playlist: " . $browser->response->status_line
    if !$browser->success;

  my $plist = $browser->content;
  my @found;
  while ($plist =~ /(videoArray\.push[^}]+} \) \);)/gi) {
    push @found, ($1 =~ /Format\:'FLV', ClipId\:'(\d+)'/i);
  }

  my @rtmpdump_commands;

  for my $clipid (@found) {
    debug "clipID = $clipid";
    my $rand =  int rand 999999;
    $browser->get("http://esi.ctv.ca/datafeed/flv/urlgenjs.aspx?vid=$clipid&timeZone=-4&random=$rand");

    if ($browser->content =~ /(rtmpe\:\/\/[^\']+)/) {
      my $rtmp = $1;
      my $tcurl = ($rtmp =~ /\?(auth=.+)/ )[0];
      my $filename =  ($rtmp =~ /([^\?\/]+)\?/ )[0];
      $filename =~ s/\.mp4/\.flv/;

      debug "$rtmp, $tcurl, $filename";

      push @rtmpdump_commands, {
        app => "ondemand?$tcurl",
        pageUrl => $page_url,
        swfUrl => "http://watch.ctv.ca/Flash/player.swf?themeURL=http://watch.ctv.ca/themes/CTV/player/theme.aspx",
        tcUrl => "rtmpe://cp45924.edgefcs.net/ondemand?$tcurl",
        auth => ($rtmp =~ /auth=([^&]+)/)[0],
        rtmp => $rtmp,
        playpath => "mp4:" . ($rtmp =~ /ondemand\/(.+)/)[0],
        flv => $filename,
      };
    } elsif($browser->content =~ /geoblock/) {
      die "CTV returned geoblock (content not available in your country)\n";
    }
  }

  return \@rtmpdump_commands;
}

sub can_handle {
  my($self, $browser, $url) = @_;
  return $url =~ m{watch\.ctv\.ca};
}

1;
}
##} blib/lib/FlashVideo/Site/Ctv.pm
BEGIN { $INC{'FlashVideo/Site/Dailymotion.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Dailymotion.pm
{
package FlashVideo::Site::Dailymotion;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *json_unescape = \&FlashVideo::Utils::json_unescape; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  if ($browser->content =~ /content.is.not.available.for.your.country/i) {
    error "Can't (yet) download this video because it's not available " .
          "in your area";
    exit 1;
  }
 
  $browser->allow_redirects;

  $browser->content =~ /<h1[^>]*>(.*?)<\//;
  my $filename = title_to_filename($1);

  my $video;
  if ($browser->content =~ /"video", "([^"]+)/) {
    $video = uri_unescape($1);
  }
  if (!$video && $browser->content =~ /"sequence", *"([^"]+)/) {
    my $data = json_unescape(uri_unescape($1));
    my ($low) = $data =~ /"sdURL" *: *"([^"]+)"/i;
    my ($high) = $data =~ /"hqURL" *: *"([^"]+)"/i;
    if($data =~ /"videoTitle" *: *"([^"]+)"/i){
      my $title = uri_unescape($1);
      $title =~ s/\+/ /g;
      $filename = title_to_filename($title);
    }
    if( $prefs->{quality} == 'high' && $high ){ $video = $high; }
    elsif( $low ){ $video = $low; }
  }
  if(!$video) {
    if ($embed_url !~ m!/swf/!) {
      $browser->uri =~ m!video(?:%2F|/)([^_]+)!;
      $embed_url = "http://www.dailymotion.com/swf/$1";
    }

    $browser->get($embed_url);

    die "Must have Compress::Zlib for embedded Dailymotion videos\n"
      unless eval { require Compress::Zlib; };

    my $data = Compress::Zlib::uncompress(substr $browser->content, 8);

    $data =~ /\{\{video\}\}\{\{(.*?)\}\}/;
    $video = $1;

    if($data =~ /videotitle=([^&]+)/) {
      $filename = title_to_filename(uri_unescape($1));
    }
  }

  if(!$video) {
    my($package, $possible_url) = FlashVideo::URLFinder->find_package($browser->uri, $browser);

    if($package ne __PACKAGE__) {
      return $package->find_video($browser, $possible_url, $prefs);
    }
  }

  die "Couldn't find video parameter." unless $video;

  my @streams;
  for(split /\|\|/, $video) {
    my($path, $type) = split /@@/;

    my($width, $height) = $path =~ /(\d+)x(\d+)/;

    push @streams, {
      width  => $width,
      height => $height,
      url    => URI->new_abs($path, $browser->uri)->as_string
    };
  }

  my $url = (sort { $b->{width} <=> $a->{width} } @streams)[0]->{url};

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Dailymotion.pm
BEGIN { $INC{'FlashVideo/Site/Daum.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Daum.pm
{
package FlashVideo::Site::Daum;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use HTML::Entities qw(decode_entities);

sub find_video {
  my ($self, $browser) = @_;

  my $video_id = get_video_id($browser);
  debug "Video ID: $video_id";

  my $video_title = get_video_title($browser, $video_id);
  debug "Video title: $video_title";

  my $video_url = get_video_url($browser, $video_id);
  debug "Video URL: $video_url";

  return $video_url, title_to_filename($video_title);
}


sub is_valid_video_id {
  my ($video_id) = @_;

  return if !defined $video_id;

  return if length $video_id != 12;

  return if $video_id !~ /\$$/xms;

  return 1;
}

sub get_video_id {
  my ($browser) = @_;

  my $singer_url
    = quotemeta 'http://media.daum.net/entertain/showcase/singer/';
  my $singer_url_pattern = qr{^ $singer_url .* [#] (\d+) $}xmsi;
  if ( $browser->uri()->as_string() =~ $singer_url_pattern ) {
    my $id = $1;
    return get_video_id_for_singer($browser, $id);
  }

  if ( $browser->uri()->as_string() =~ /[#] clipid = (\d+)/xmsi ) {
    my $url = 'http://tvpot.daum.net/clip/ClipView.do?clipid=' . $1;
    $browser->get($url);
    if ( !$browser->success() ) {
      die "Cannot fetch the document identified by the given URL: $url\n";
    }
  }

  my $document = $browser->content();

  my $flv_player_url = quotemeta 'http://flvs.daum.net/flvPlayer.swf';
  my $video_id_pattern_1 = qr{['"] $flv_player_url [?] vid = ([^'"&]+)}xmsi;

  my $function_name      = quotemeta 'Story.UI.PlayerManager.createViewer';
  my $video_id_pattern_2 = qr{$function_name [(] '(.+?)' [)]}xms;

  if (    $document !~ $video_id_pattern_1
       && $document !~ $video_id_pattern_2 )
  {
    die "Cannot find video ID from the document.\n";
  }
  my $video_id = $1;

  $video_id =~ s/\s+//xmsg;

  die "Invalid video ID: $video_id\n" if !is_valid_video_id($video_id);

  return $video_id;
}

sub get_video_id_for_singer {
  my ($browser, $id) = @_;

  my $document = $browser->content();

  my $video_id_pattern = qr{id:'$id', \s* vid:'(.+?)'}xms;
  if ( $document !~ $video_id_pattern ) {
    die "Cannot find video ID from the document.\n";
  }
  my $video_id = $1;

  $video_id =~ s/\s+//xmsg;

  die "Invalid video ID: $video_id\n" if !is_valid_video_id($video_id);

  return $video_id;
}

sub get_video_title {
  my ($browser, $video_id) = @_;

  my $query_url = "http://tvpot.daum.net/clip/ClipInfoXml.do?vid=$video_id";

  $browser->get($query_url);
  if ( !$browser->success() ) {
    die "Cannot fetch the document identified by the given URL: $query_url\n";
  }

  my $document = $browser->content();

  my $video_title_pattern
    = qr{<TITLE> <!\[CDATA \[ (.+?) \] \]> </TITLE>}xmsi;
  if ( $document !~ $video_title_pattern ) {
    die "Cannot find video title from the document.\n";
  }
  my $video_title = $1;

  $video_title = decode_entities($video_title);

  return $video_title;
}

sub get_video_url {
  my ($browser, $video_id) = @_;

  my $query_url
    = 'http://stream.tvpot.daum.net/fms/pos_query2.php'
    . '?service_id=1001&protocol=http&out_type=xml'
    . "&s_idx=$video_id";

  $browser->get($query_url);
  if ( !$browser->success() ) {
    die "Cannot fetch the document identified by the given URL: $query_url\n";
  }

  my $document = $browser->content();

  my $video_url_pattern = qr{movieURL = "(.+?)"}xmsi;
  if ( $document !~ $video_url_pattern ) {
    die "Cannot find video URL from the document.\n";
  }
  my $video_url = $1;

  return $video_url;
}

1;
}
##} blib/lib/FlashVideo/Site/Daum.pm
BEGIN { $INC{'FlashVideo/Site/Ehow.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Ehow.pm
{
package FlashVideo::Site::Ehow;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_escape = \&URI::Escape::uri_escape; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  my $video_id;
  if ($browser->content =~ /flashvars=(?:&quot;|'|")id=(.*?)[ &]/) {
    $video_id = $1;
  }
  else {
    die "Couldn't extract video ID from page";
  }

  my $title;
  if ($browser->content =~ /(?:<div\ class="DetailHeader">)?
                            <h1\ class="(?:Heading1a|SubHeader)"[^>]*>(.*?)<\/h1>/x) {
    $title = $1;
  }

  if($video_id =~ /^http:/) {
    return $video_id, title_to_filename($title);
  }
  else {
    my $embed_url =
      "http://www.ehow.com/embedvars.aspx?isEhow=true&show_related=true&" .
      "from_url=" . uri_escape($browser->uri->as_string) .
      "&id=" . $video_id;

    $browser->get($embed_url);

    if ($browser->content =~ /&source=(http.*?flv)&/) {
      return uri_unescape($1), title_to_filename($title);
    }
    else {
      die "Couldn't extract Flash video URL from embed page";
    }
  }
}


1;
}
##} blib/lib/FlashVideo/Site/Ehow.pm
BEGIN { $INC{'FlashVideo/Site/Expertvillage.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Expertvillage.pm
{
package FlashVideo::Site::Expertvillage;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  my($fn) = $browser->content =~ /SWFObject\(['"][^'"]+flv=([^'"]+)/;
  my $embedvars = uri_unescape($browser->content =~ /embedvars['"],\s*['"]([^'"]+)/);
  die "Unable to find video info" unless $fn and $embedvars;

  my($title) = $browser->content =~ m{<h1[^>]*>(.*)</h1>}s;
  my $filename = title_to_filename($title);

  $browser->get("$embedvars?fn=$fn");
  die "Unable to get emebdding info" if $browser->response->is_error;

  my $url = uri_unescape($browser->content =~ /source=([^&]+)/);
  die "Unable to find video URL" unless $url;

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Expertvillage.pm
BEGIN { $INC{'FlashVideo/Site/Flickr.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Flickr.pm
{
package FlashVideo::Site::Flickr;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

my $get_mtl = "http://www.flickr.com/apps/video/video_mtl_xml.gne?v=x";

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my($id) = $browser->content =~ /photo_id=(\d+)/;
  my($secret) = $browser->content =~ /photo_secret=(\w+)/;

  die "No video ID found\n" unless $id;

  $browser->get($get_mtl . "&photo_id=$id&secret=$secret&olang=en-us&noBuffer=null&bitrate=700&target=_self");

  my $xml = from_xml($browser);

  my $guid = $self->make_guid;
  my $video_id = $xml->{Data}->{Item}->{id}->{content};
  my $playlist_url = $xml->{Playlist}->{TimelineTemplates}->{Timeline}
    ->{Metadata}->{Item}->{playlistUrl}->{content};

  die "No video ID or playlist found" unless $video_id and $playlist_url;

  $browser->get($playlist_url
    . "?node_id=$video_id&secret=$secret&tech=flash&mode=playlist"
    . "&lq=$guid&bitrate=700&rd=video.yahoo.com&noad=1");

  $xml = eval { XML::Simple::XMLin($browser->content) };
  die "Failed parsing XML: $@" if $@;

  $xml = $xml->{"SEQUENCE-ITEM"};
  die "XML not as expected" unless $xml;

  my $filename = title_to_filename($xml->{META}->{TITLE});
  my $url = $xml->{STREAM}->{APP} . $xml->{STREAM}->{FULLPATH};

  return $url, $filename;
}

sub make_guid {
  my($self) = @_;

  my @chars = ('A' .. 'Z', 'a' .. 'z', 0 .. 9, '.', '_');
  return join "", map { $chars[rand @chars] } 1 .. 22;
}

1;
}
##} blib/lib/FlashVideo/Site/Flickr.pm
BEGIN { $INC{'FlashVideo/Site/Fliqz.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Fliqz.pm
{
package FlashVideo::Site::Fliqz;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $id;
  if ($browser->content =~ /<param name=["']flashvars["'] value=["']file=([a-f0-9]{32})/) {
    $id = $1;
  }

  if (!$id and $browser->content =~ /\Q$embed_url\E.*?([a-f0-9]{32})/) {
    $id = $1;
  }

  $browser->post("http://services.fliqz.com/mediaassetcomponentservice/20071201/service.svc",
    Content_Type => "text/xml; charset=utf-8",
    SOAPAction   => '"urn:fliqz.s.mac.20071201/IMediaAssetComponentService/ad"',
    Referer      => $embed_url,
    Content      => _get_soap_xml($id)
  );

  my $flv_url  = ($browser->content =~ />(http:[^<]+\.flv)</)[0];

  if (!$flv_url) {
    $browser->post("http://services.fliqz.com/LegacyServices/Services/MediaAsset/Component/R20071201/service.svc",
      Content_Type => "text/xml; charset=utf-8",
      SOAPAction   => '"urn:fliqz.s.mac.20071201/IMediaAssetComponentService/ad"',

      Referer      => $embed_url,

      Content      => _get_soap_xml($id)
    );

    $flv_url = ($browser->content =~ />(http:[^<]+\.flv)</)[0];
  }

  my $filename = ($browser->content =~ /<t [^>]+>([^<]+)/)[0];
  $filename = title_to_filename($filename);

  $browser->allow_redirects;

  return $flv_url, $filename;
}

sub _get_soap_xml {
  my $id = shift;

  return <<EOF
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP-ENV:Body>
  <i0:ad xmlns:i0="urn:fliqz.s.mac.20071201">
  <i0:rq>
    <i0:a>$id</i0:a>
    <i0:pu></i0:pu>
    <i0:pid>1F866AF1-1DB0-4864-BCA1-6236377B518F</i0:pid>
  </i0:rq>
</i0:ad> 
</SOAP-ENV:Body>
</SOAP-ENV:Envelope>
EOF
}

1;
}
##} blib/lib/FlashVideo/Site/Fliqz.pm
BEGIN { $INC{'FlashVideo/Site/Fora.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Fora.pm
{
package FlashVideo::Site::Fora;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my($clip_id) = $browser->content =~ /clipid=(\d+)/;
  die "Unable to extract clipid" unless $clip_id;

  $browser->get("http://fora.tv/fora/fora_player_full?cid=$clip_id&h=1&b=0");

  my $xml = from_xml($browser);

  my $filename = title_to_filename($xml->{clipinfo}->{clip_title});

  my $playpath = $xml->{encodeinfo}->{encode_url};
  $playpath =~ s/\.flv$//;

  return {
    flv => $filename,
    app => "a953/o10",
    rtmp => "rtmp://foratv.fcod.llnwd.net",
    playpath => $playpath,
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Fora.pm
BEGIN { $INC{'FlashVideo/Site/Freevideo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Freevideo.pm
{
package FlashVideo::Site::Freevideo; # .ru

use strict;
use Encode;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  my $ticket;
  if ($browser->uri->as_string =~ /\?id=(.*?)$/) {
    $ticket = $1;
  }

  $browser->post(
    "http://freevideo.ru/video/view/url/-/" . int(rand 100_000), 
    [
      onLoad       => '[type Function]',
      highquality  => 0,
      getvideoinfo => 1,
      devid        => 'LoadupFlashPlayer',
      after_adv    => 0,
      before_adv   => 1,
      frame_url    => 1,
      'ref'        => $browser->uri->as_string,
      video_url    => 1,
      ticket       => $ticket,
    ]
  );

  if (!$browser->success) {
    die "Posting to Freevideo failed: " . $browser->response->status_line();
  }

  my $video_data = uri_unescape($browser->content);

  my $url;

  if ($video_data =~ m'vidURL=(http://.*?\.flv)') {
    $url = $1;
  }
  else {
    die "Couldn't find Freevideo URL";
  }

  my $title;

  if ($video_data =~ /title=(.*?)&userNick/) {
    $title = $1;
  }

  $title = decode('utf-8', $title);

  return $url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Freevideo.pm
BEGIN { $INC{'FlashVideo/Site/Gamespot.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Gamespot.pm
{
package FlashVideo::Site::Gamespot;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my($params) = $browser->content =~ /xml.php\?(id=[0-9]+.*?)&quot/;
  ($params) = $embed_url =~ /xml.php%3F(id%3D[^"&]+)/ unless $params;
  die "No params found\n" unless $params;

  $browser->get("http://www.gamespot.com/pages/video_player/xml.php?" . $params);

  my $xml = from_xml($browser);

  my $title = $xml->{playList}->{clip}->{title};
  my $url = $xml->{playList}->{clip}->{URI};

  $browser->allow_redirects;
  return $url, title_to_filename($title);
}

1;

}
##} blib/lib/FlashVideo/Site/Gamespot.pm
BEGIN { $INC{'FlashVideo/Site/Gawker.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Gawker.pm
{
package FlashVideo::Site::Gawker;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my $title = extract_title($browser);
  $title =~ s/^\w+\s+-\s*//;
  $title =~ s/\s*-\s+\w+$//;
  my $filename = title_to_filename($title);

  my $url = "http://cache." . $browser->uri->host . "/assets/video/" .
    ($browser->content =~ /newVideoPlayer\("([^"]+)/)[0];

  return $url, $filename;
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->content =~ /newVideoPlayer/;
}

1;
}
##} blib/lib/FlashVideo/Site/Gawker.pm
BEGIN { $INC{'FlashVideo/Site/Globaltv.pm'}++; }
#################################
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
#	GlobalTV Canada
#
#	first alpha plugin version
#
#	Input URL should be 
#		http://www.globaltv.com/$show/video/full+episodes/$clip/video.html?v=$contentID
#	where
#		$show		show name
#		$clip		section
#		$contentID 	numeric ID
#	Stavr00
#
#	TODO:	fetch all clips for a show
#

##{ blib/lib/FlashVideo/Site/Globaltv.pm
{
package FlashVideo::Site::Globaltv;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
use strict 'refs';

sub find_video {
	my ($self, $browser, $embed_url, $prefs) = @_;

	my $pid;
	if ( $browser->content =~ /pid:\s+"([^"]+?)"/ ) {
		$pid = $1;	
	}
	
	debug "PID = " . $pid;
	
	die "PID not found." unless $pid;
	
	$browser->get("http://release.theplatform.com/content.select?pid=$pid&mbr=true&Embedded=True&Portal=GlobalTV&Site=global_prg.com&TrackBrowser=True&Tracking=True&TrackLocation=True&format=SMIL");

	my $xml = from_xml($browser->content); 

	my $maxres = $prefs->quality->quality_to_resolution($prefs->{quality});
	my $sw;		
	my $vid;
	my $title;
	my $url;
	my $rate = 0;
	my $res;
	debug "Enumerating all streams ...";
	foreach $sw (@{ $xml->{body}->{switch} }) {
		if ($sw->{ref}->{src} =~  /^rtmp\:\/\// ) {
			$title = $sw->{ref}->{title};	
			debug "TITLE = " . $title; # short title, not very useful
		}
		if ( ref($sw->{video}) eq "ARRAY" ) {
			foreach $vid (@{ $sw->{video} }) {
				my $t = $vid->{src};
				if ( $t =~ /^rtmp\:\/\// ) {
					my $w  = $vid->{width};
					my $h  = $vid->{height};
					my $br = $vid->{'system-bitrate'};
					debug ' '. $t ." ". $w . 'x' . $h ."/". $br;
					if ( ( $br > $rate ) && ( $h <= @$maxres[1] ) )	{
						$rate = $br;
						$url = $t;
						$res = $w .'x'. $h .' '. int($br/1024) . 'kb/s';
					}
				}
			}
		}
	}
	
	info 'Stream selected: ' .  $url . ' ' . $res;

	
	$url =~ /([^\/]+\.mp4$)/;
	$title = $1;
	
	return	{
	rtmp => $url,
	    flv => title_to_filename($title)
	};

	
}
	
1;	

}
##} blib/lib/FlashVideo/Site/Globaltv.pm
BEGIN { $INC{'FlashVideo/Site/Google.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Google.pm
{
package FlashVideo::Site::Google;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  if ($browser->content =~ /googleplayer\.swf\?doc[iI]d=([^&;'"]+)/) {
    $browser->get("http://video.google.com/videoplay?docid=$1");
  }

  if (!$browser->success) {
    $browser->get($browser->response->header('Location'));
    die "Couldn't download URL: " . $browser->response->status_line
      unless $browser->success;
  }

  my $url;
  if ($browser->content =~ /googleplayer\.swf\?&?videoUrl(.+?)\\x26/) {
    $url = uri_unescape($1);

    $url =~ s/\\x([A-F0-9]{2})/chr(hex $1)/egi;
    $url =~ s/^=//;
  }

  my $filename = title_to_filename(extract_title($browser));

  $browser->allow_redirects;

  return $url, $filename;
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->response->header('Location') =~ /google/i
    || $browser->content =~ /googleplayer\.swf/;
}

1;
}
##} blib/lib/FlashVideo/Site/Google.pm
BEGIN { $INC{'FlashVideo/Site/Googlevideosearch.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Mechanize.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'WWW/Mechanize.pm'}++; }
BEGIN { $INC{'LWP/UserAgent.pm'}++; }
BEGIN { $INC{'LWP.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/LWP.pm
{
package LWP;

$VERSION = "5.837";
sub Version { $VERSION; }

require 5.005;

1;

}
##} /usr/local/libdata/perl5/site_perl/LWP.pm
##{ /usr/local/libdata/perl5/site_perl/LWP/UserAgent.pm
{
package LWP::UserAgent;

use strict;
use vars qw(@ISA $VERSION);

@ISA = qw(LWP::MemberMixin);
$VERSION = "5.835";



use Carp ();

if ($ENV{PERL_LWP_USE_HTTP_10}) {
    require LWP::Protocol::http10;
    LWP::Protocol::implementor('http', 'LWP::Protocol::http10');
    eval {
        require LWP::Protocol::https10;
        LWP::Protocol::implementor('https', 'LWP::Protocol::https10');
    };
}



sub new
{
    Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference") 
        if ref($_[1]) eq 'HASH'; 

    my($class, %cnf) = @_;

    my $agent = delete $cnf{agent};
    my $from  = delete $cnf{from};
    my $def_headers = delete $cnf{default_headers};
    my $timeout = delete $cnf{timeout};
    $timeout = 3*60 unless defined $timeout;
    my $local_address = delete $cnf{local_address};
    my $use_eval = delete $cnf{use_eval};
    $use_eval = 1 unless defined $use_eval;
    my $parse_head = delete $cnf{parse_head};
    $parse_head = 1 unless defined $parse_head;
    my $show_progress = delete $cnf{show_progress};
    my $max_size = delete $cnf{max_size};
    my $max_redirect = delete $cnf{max_redirect};
    $max_redirect = 7 unless defined $max_redirect;
    my $env_proxy = delete $cnf{env_proxy};

    my $cookie_jar = delete $cnf{cookie_jar};
    my $conn_cache = delete $cnf{conn_cache};
    my $keep_alive = delete $cnf{keep_alive};
    
    Carp::croak("Can't mix conn_cache and keep_alive")
	  if $conn_cache && $keep_alive;


    my $protocols_allowed   = delete $cnf{protocols_allowed};
    my $protocols_forbidden = delete $cnf{protocols_forbidden};
    
    my $requests_redirectable = delete $cnf{requests_redirectable};
    $requests_redirectable = ['GET', 'HEAD']
      unless defined $requests_redirectable;

    Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
      if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
    Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
      if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
    Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
      if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';


    if (%cnf && $^W) {
	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
    }

    my $self = bless {
		      def_headers  => $def_headers,
		      timeout      => $timeout,
		      local_address => $local_address,
		      use_eval     => $use_eval,
                      show_progress=> $show_progress,
		      max_size     => $max_size,
		      max_redirect => $max_redirect,
                      proxy        => {},
		      no_proxy     => [],
                      protocols_allowed     => $protocols_allowed,
                      protocols_forbidden   => $protocols_forbidden,
                      requests_redirectable => $requests_redirectable,
		     }, $class;

    $self->agent(defined($agent) ? $agent : $class->_agent)
	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
    $self->from($from) if $from;
    $self->cookie_jar($cookie_jar) if $cookie_jar;
    $self->parse_head($parse_head);
    $self->env_proxy if $env_proxy;

    $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
    $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;

    if ($keep_alive) {
	$conn_cache ||= { total_capacity => $keep_alive };
    }
    $self->conn_cache($conn_cache) if $conn_cache;

    return $self;
}


sub send_request
{
    my($self, $request, $arg, $size) = @_;
    my($method, $url) = ($request->method, $request->uri);
    my $scheme = $url->scheme;

    local($SIG{__DIE__});  # protect against user defined die handlers

    $self->progress("begin", $request);

    my $response = $self->run_handlers("request_send", $request);

    unless ($response) {
        my $protocol;

        {
            my $x;
            if($x = $self->protocols_allowed) {
                if (grep lc($_) eq $scheme, @$x) {
                }
                else {
                    require LWP::Protocol::nogo;
                    $protocol = LWP::Protocol::nogo->new;
                }
            }
            elsif ($x = $self->protocols_forbidden) {
                if(grep lc($_) eq $scheme, @$x) {
                    require LWP::Protocol::nogo;
                    $protocol = LWP::Protocol::nogo->new;
                }
            }
        }

        my $proxy = $request->{proxy};
        if ($proxy) {
            $scheme = $proxy->scheme;
        }

        unless ($protocol) {
            $protocol = eval { LWP::Protocol::create($scheme, $self) };
            if ($@) {
                $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                if ($scheme eq "https") {
                    $response->message($response->message . " (Crypt::SSLeay or IO::Socket::SSL not installed)");
                    $response->content_type("text/plain");
                    $response->content(<<EOT);
LWP will support https URLs if either Crypt::SSLeay or IO::Socket::SSL
is installed. More information at
<http://search.cpan.org/dist/libwww-perl/README.SSL>.
EOT
                }
            }
        }

        if (!$response && $self->{use_eval}) {
            eval {
                $response = $protocol->request($request, $proxy,
                                               $arg, $size, $self->{timeout});
            };
            if ($@) {
                $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                    $response = _new_response($request,
                                              &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
                                              $@);
            }
        }
        elsif (!$response) {
            $response = $protocol->request($request, $proxy,
                                           $arg, $size, $self->{timeout});
        }
    }

    $response->request($request);  # record request for reference
    $response->header("Client-Date" => HTTP::Date::time2str(time));

    $self->run_handlers("response_done", $response);

    $self->progress("end", $response);
    return $response;
}


sub prepare_request
{
    my($self, $request) = @_;
    die "Method missing" unless $request->method;
    my $url = $request->uri;
    die "URL missing" unless $url;
    die "URL must be absolute" unless $url->scheme;

    $self->run_handlers("request_preprepare", $request);

    if (my $def_headers = $self->{def_headers}) {
	for my $h ($def_headers->header_field_names) {
	    $request->init_header($h => [$def_headers->header($h)]);
	}
    }

    $self->run_handlers("request_prepare", $request);

    return $request;
}


sub simple_request
{
    my($self, $request, $arg, $size) = @_;

    if (defined $request) {
	if (ref $request) {
	    Carp::croak("You need a request object, not a " . ref($request) . " object")
	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
		 !$request->can('method') or !$request->can('uri');
	}
	else {
	    Carp::croak("You need a request object, not '$request'");
	}
    }
    else {
        Carp::croak("No request object passed in");
    }

    eval {
	$request = $self->prepare_request($request);
    };
    if ($@) {
	$@ =~ s/ at .* line \d+.*//s;  # remove file/line number
	return _new_response($request, &HTTP::Status::RC_BAD_REQUEST, $@);
    }
    return $self->send_request($request, $arg, $size);
}


sub request
{
    my($self, $request, $arg, $size, $previous) = @_;

    my $response = $self->simple_request($request, $arg, $size);
    $response->previous($previous) if $previous;

    if ($response->redirects >= $self->{max_redirect}) {
        $response->header("Client-Warning" =>
                          "Redirect loop detected (max_redirect = $self->{max_redirect})");
        return $response;
    }

    if (my $req = $self->run_handlers("response_redirect", $response)) {
        return $self->request($req, $arg, $size, $response);
    }

    my $code = $response->code;

    if ($code == &HTTP::Status::RC_MOVED_PERMANENTLY or
	$code == &HTTP::Status::RC_FOUND or
	$code == &HTTP::Status::RC_SEE_OTHER or
	$code == &HTTP::Status::RC_TEMPORARY_REDIRECT)
    {
	my $referral = $request->clone;

	$referral->remove_header('Host', 'Cookie');
	
	if ($referral->header('Referer') &&
	    $request->uri->scheme eq 'https' &&
	    $referral->uri->scheme eq 'http')
	{
	    $referral->remove_header('Referer');
	}

	if ($code == &HTTP::Status::RC_SEE_OTHER ||
	    $code == &HTTP::Status::RC_FOUND) 
        {
	    my $method = uc($referral->method);
	    unless ($method eq "GET" || $method eq "HEAD") {
		$referral->method("GET");
		$referral->content("");
		$referral->remove_content_headers;
	    }
	}

	my $referral_uri = $response->header('Location');
	{
	    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
	    my $base = $response->base;
	    $referral_uri = "" unless defined $referral_uri;
	    $referral_uri = $HTTP::URI_CLASS->new($referral_uri, $base)
		            ->abs($base);
	}
	$referral->uri($referral_uri);

	return $response unless $self->redirect_ok($referral, $response);
	return $self->request($referral, $arg, $size, $response);

    }
    elsif ($code == &HTTP::Status::RC_UNAUTHORIZED ||
	     $code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED
	    )
    {
	my $proxy = ($code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
	my $ch_header = $proxy ?  "Proxy-Authenticate" : "WWW-Authenticate";
	my @challenge = $response->header($ch_header);
	unless (@challenge) {
	    $response->header("Client-Warning" => 
			      "Missing Authenticate header");
	    return $response;
	}

	require HTTP::Headers::Util;
	CHALLENGE: for my $challenge (@challenge) {
	    $challenge =~ tr/,/;/;  # "," is used to separate auth-params!!
	    ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
	    my $scheme = shift(@$challenge);
	    shift(@$challenge); # no value
	    $challenge = { @$challenge };  # make rest into a hash

	    unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
		$response->header("Client-Warning" => 
				  "Bad authentication scheme '$scheme'");
		return $response;
	    }
	    $scheme = $1;  # untainted now
	    my $class = "LWP::Authen::\u$scheme";
	    $class =~ s/-/_/g;

	    no strict 'refs';
	    unless (%{"$class\::"}) {
		eval "require $class";
		if ($@) {
		    if ($@ =~ /^Can\'t locate/) {
			$response->header("Client-Warning" =>
					  "Unsupported authentication scheme '$scheme'");
		    }
		    else {
			$response->header("Client-Warning" => $@);
		    }
		    next CHALLENGE;
		}
	    }
	    unless ($class->can("authenticate")) {
		$response->header("Client-Warning" =>
				  "Unsupported authentication scheme '$scheme'");
		next CHALLENGE;
	    }
	    return $class->authenticate($self, $proxy, $challenge, $response,
					$request, $arg, $size);
	}
	return $response;
    }
    return $response;
}


sub get {
    require HTTP::Request::Common;
    my($self, @parameters) = @_;
    my @suff = $self->_process_colonic_headers(\@parameters,1);
    return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
}


sub post {
    require HTTP::Request::Common;
    my($self, @parameters) = @_;
    my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
    return $self->request( HTTP::Request::Common::POST( @parameters ), @suff );
}


sub head {
    require HTTP::Request::Common;
    my($self, @parameters) = @_;
    my @suff = $self->_process_colonic_headers(\@parameters,1);
    return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
}


sub _process_colonic_headers {
    my($self, $args, $start_index) = @_;

    my($arg, $size);
    for(my $i = $start_index; $i < @$args; $i += 2) {
	next unless defined $args->[$i];


	if($args->[$i] eq ':content_cb') {
	    $arg = $args->[$i + 1];
	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
	    Carp::croak("A :content_cb value must be a coderef")
		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
	    
	}
	elsif ($args->[$i] eq ':content_file') {
	    $arg = $args->[$i + 1];

	    Carp::croak("A :content_file value can't be undef")
		unless defined $arg;
	    Carp::croak("A :content_file value can't be a reference")
		if ref $arg;
	    Carp::croak("A :content_file value can't be \"\"")
		unless length $arg;

	}
	elsif ($args->[$i] eq ':read_size_hint') {
	    $size = $args->[$i + 1];

	}
	else {
	    next;
	}
	splice @$args, $i, 2;
	$i -= 2;
    }


    return             unless defined $arg;
    return $arg, $size if     defined $size;
    return $arg;
}

my @ANI = qw(- \ | /);

sub progress {
    my($self, $status, $m) = @_;
    return unless $self->{show_progress};

    local($,, $\);
    if ($status eq "begin") {
        print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
        $self->{progress_start} = time;
        $self->{progress_lastp} = "";
        $self->{progress_ani} = 0;
    }
    elsif ($status eq "end") {
        delete $self->{progress_lastp};
        delete $self->{progress_ani};
        print STDERR $m->status_line;
        my $t = time - delete $self->{progress_start};
        print STDERR " (${t}s)" if $t;
        print STDERR "\n";
    }
    elsif ($status eq "tick") {
        print STDERR "$ANI[$self->{progress_ani}++]\b";
        $self->{progress_ani} %= @ANI;
    }
    else {
        my $p = sprintf "%3.0f%%", $status * 100;
        return if $p eq $self->{progress_lastp};
        print STDERR "$p\b\b\b\b";
        $self->{progress_lastp} = $p;
    }
    STDERR->flush;
}


sub is_protocol_supported
{
    my($self, $scheme) = @_;
    if (ref $scheme) {
	$scheme = $scheme->scheme;
    }
    else {
	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
	    if $scheme =~ /\W/;
	$scheme = lc $scheme;
    }

    my $x;
    if(ref($self) and $x       = $self->protocols_allowed) {
      return 0 unless grep lc($_) eq $scheme, @$x;
    }
    elsif (ref($self) and $x = $self->protocols_forbidden) {
      return 0 if grep lc($_) eq $scheme, @$x;
    }

    local($SIG{__DIE__});  # protect against user defined die handlers
    $x = LWP::Protocol::implementor($scheme);
    return 1 if $x and $x ne 'LWP::Protocol::nogo';
    return 0;
}


sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }


sub redirect_ok
{


    my($self, $new_request, $response) = @_;
    my $method = $response->request->method;
    return 0 unless grep $_ eq $method,
      @{ $self->requests_redirectable || [] };
    
    if ($new_request->uri->scheme eq 'file') {
      $response->header("Client-Warning" =>
			"Can't redirect to a file:// URL!");
      return 0;
    }
    
    return 1;
}


sub credentials
{
    my $self = shift;
    my $netloc = lc(shift);
    my $realm = shift || "";
    my $old = $self->{basic_authentication}{$netloc}{$realm};
    if (@_) {
        $self->{basic_authentication}{$netloc}{$realm} = [@_];
    }
    return unless $old;
    return @$old if wantarray;
    return join(":", @$old);
}


sub get_basic_credentials
{
    my($self, $realm, $uri, $proxy) = @_;
    return if $proxy;
    return $self->credentials($uri->host_port, $realm);
}


sub timeout      { shift->_elem('timeout',      @_); }
sub local_address{ shift->_elem('local_address',@_); }
sub max_size     { shift->_elem('max_size',     @_); }
sub max_redirect { shift->_elem('max_redirect', @_); }
sub show_progress{ shift->_elem('show_progress', @_); }

sub parse_head {
    my $self = shift;
    if (@_) {
        my $flag = shift;
        my $parser;
        my $old = $self->set_my_handler("response_header", $flag ? sub {
               my($response, $ua) = @_;
               require HTML::HeadParser;
               $parser = HTML::HeadParser->new;
               $parser->xml_mode(1) if $response->content_is_xhtml;
               $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;

               push(@{$response->{handlers}{response_data}}, {
		   callback => sub {
		       return unless $parser;
		       unless ($parser->parse($_[3])) {
			   my $h = $parser->header;
			   my $r = $_[0];
			   for my $f ($h->header_field_names) {
			       $r->init_header($f, [$h->header($f)]);
			   }
			   undef($parser);
		       }
		   },
	       });

            } : undef,
            m_media_type => "html",
        );
        return !!$old;
    }
    else {
        return !!$self->get_my_handler("response_header");
    }
}

sub cookie_jar {
    my $self = shift;
    my $old = $self->{cookie_jar};
    if (@_) {
	my $jar = shift;
	if (ref($jar) eq "HASH") {
	    require HTTP::Cookies;
	    $jar = HTTP::Cookies->new(%$jar);
	}
	$self->{cookie_jar} = $jar;
        $self->set_my_handler("request_prepare",
            $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
        );
        $self->set_my_handler("response_done",
            $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
        );
    }
    $old;
}

sub default_headers {
    my $self = shift;
    my $old = $self->{def_headers} ||= HTTP::Headers->new;
    if (@_) {
	Carp::croak("default_headers not set to HTTP::Headers compatible object")
	    unless @_ == 1 && $_[0]->can("header_field_names");
	$self->{def_headers} = shift;
    }
    return $old;
}

sub default_header {
    my $self = shift;
    return $self->default_headers->header(@_);
}

sub _agent       { "libwww-perl/$LWP::VERSION" }

sub agent {
    my $self = shift;
    if (@_) {
	my $agent = shift;
        if ($agent) {
            $agent .= $self->_agent if $agent =~ /\s+$/;
        }
        else {
            undef($agent)
        }
        return $self->default_header("User-Agent", $agent);
    }
    return $self->default_header("User-Agent");
}

sub from {  # legacy
    my $self = shift;
    return $self->default_header("From", @_);
}


sub conn_cache {
    my $self = shift;
    my $old = $self->{conn_cache};
    if (@_) {
	my $cache = shift;
	if (ref($cache) eq "HASH") {
	    require LWP::ConnCache;
	    $cache = LWP::ConnCache->new(%$cache);
	}
	$self->{conn_cache} = $cache;
    }
    $old;
}


sub add_handler {
    my($self, $phase, $cb, %spec) = @_;
    $spec{line} ||= join(":", (caller)[1,2]);
    my $conf = $self->{handlers}{$phase} ||= do {
        require HTTP::Config;
        HTTP::Config->new;
    };
    $conf->add(%spec, callback => $cb);
}

sub set_my_handler {
    my($self, $phase, $cb, %spec) = @_;
    $spec{owner} = (caller(1))[3] unless exists $spec{owner};
    $self->remove_handler($phase, %spec);
    $spec{line} ||= join(":", (caller)[1,2]);
    $self->add_handler($phase, $cb, %spec) if $cb;
}

sub get_my_handler {
    my $self = shift;
    my $phase = shift;
    my $init = pop if @_ % 2;
    my %spec = @_;
    my $conf = $self->{handlers}{$phase};
    unless ($conf) {
        return unless $init;
        require HTTP::Config;
        $conf = $self->{handlers}{$phase} = HTTP::Config->new;
    }
    $spec{owner} = (caller(1))[3] unless exists $spec{owner};
    my @h = $conf->find(%spec);
    if (!@h && $init) {
        if (ref($init) eq "CODE") {
            $init->(\%spec);
        }
        elsif (ref($init) eq "HASH") {
            while (my($k, $v) = each %$init) {
                $spec{$k} = $v;
            }
        }
        $spec{callback} ||= sub {};
        $spec{line} ||= join(":", (caller)[1,2]);
        $conf->add(\%spec);
        return \%spec;
    }
    return wantarray ? @h : $h[0];
}

sub remove_handler {
    my($self, $phase, %spec) = @_;
    if ($phase) {
        my $conf = $self->{handlers}{$phase} || return;
        my @h = $conf->remove(%spec);
        delete $self->{handlers}{$phase} if $conf->empty;
        return @h;
    }

    return unless $self->{handlers};
    return map $self->remove_handler($_), sort keys %{$self->{handlers}};
}

sub handlers {
    my($self, $phase, $o) = @_;
    my @h;
    if ($o->{handlers} && $o->{handlers}{$phase}) {
        push(@h, @{$o->{handlers}{$phase}});
    }
    if (my $conf = $self->{handlers}{$phase}) {
        push(@h, $conf->matching($o));
    }
    return @h;
}

sub run_handlers {
    my($self, $phase, $o) = @_;
    if (defined(wantarray)) {
        for my $h ($self->handlers($phase, $o)) {
            my $ret = $h->{callback}->($o, $self, $h);
            return $ret if $ret;
        }
        return undef;
    }

    for my $h ($self->handlers($phase, $o)) {
        $h->{callback}->($o, $self, $h);
    }
}


sub use_eval   { shift->_elem('use_eval',  @_); }
sub use_alarm
{
    Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
	if @_ > 1 && $^W;
    "";
}


sub clone
{
    my $self = shift;
    my $copy = bless { %$self }, ref $self;  # copy most fields

    delete $copy->{handlers};
    delete $copy->{conn_cache};

    for my $k (qw(proxy no_proxy requests_redirectable)) {
        next unless $copy->{$k};
        if (ref($copy->{$k}) eq "ARRAY") {
            $copy->{$k} = [ @{$copy->{$k}} ];
        }
        elsif (ref($copy->{$k}) eq "HASH") {
            $copy->{$k} = { %{$copy->{$k}} };
        }
    }

    if ($self->{def_headers}) {
        $copy->{def_headers} = $self->{def_headers}->clone;
    }

    $copy->parse_head($self->parse_head);

    $copy->cookie_jar(undef);

    $copy;
}


sub mirror
{
    my($self, $url, $file) = @_;

    my $request = HTTP::Request->new('GET', $url);

    if ( -e $file ) {
        my ($mtime) = ( stat($file) )[9];
        if ($mtime) {
            $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
        }
    }
    my $tmpfile = "$file-$$";

    my $response = $self->request($request, $tmpfile);
    if ( $response->header('X-Died') ) {
	die $response->header('X-Died');
    }

    if ( $response->is_success ) {
        my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
        my $file_length = $stat[7];
        my ($content_length) = $response->header('Content-length');

        if ( defined $content_length and $file_length < $content_length ) {
            unlink($tmpfile);
            die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
        }
        elsif ( defined $content_length and $file_length > $content_length ) {
            unlink($tmpfile);
            die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
        }
        else {
            if ( -e $file ) {
                chmod 0777, $file;
                unlink $file;
            }
            rename( $tmpfile, $file )
                or die "Cannot rename '$tmpfile' to '$file': $!\n";

            if ( my $lm = $response->last_modified ) {
                utime $lm, $lm, $file;
            }
        }
    }
    else {
	unlink($tmpfile);
    }
    return $response;
}


sub _need_proxy {
    my($req, $ua) = @_;
    return if exists $req->{proxy};
    my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
    if ($ua->{no_proxy}) {
        if (my $host = eval { $req->uri->host }) {
            for my $domain (@{$ua->{no_proxy}}) {
                if ($host =~ /\Q$domain\E$/) {
                    return;
                }
            }
        }
    }
    $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
}


sub proxy
{
    my $self = shift;
    my $key  = shift;
    return map $self->proxy($_, @_), @$key if ref $key;

    Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
    my $old = $self->{'proxy'}{$key};
    if (@_) {
        my $url = shift;
        if (defined($url) && length($url)) {
            Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
            Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
        }
        $self->{proxy}{$key} = $url;
        $self->set_my_handler("request_preprepare", \&_need_proxy)
    }
    return $old;
}


sub env_proxy {
    my ($self) = @_;
    my($k,$v);
    while(($k, $v) = each %ENV) {
	if ($ENV{REQUEST_METHOD}) {
	    next if $k =~ /^HTTP_/;
	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
	}
	$k = lc($k);
	next unless $k =~ /^(.*)_proxy$/;
	$k = $1;
	if ($k eq 'no') {
	    $self->no_proxy(split(/\s*,\s*/, $v));
	}
	else {
            next unless $k =~ /^$URI::scheme_re\z/;
            next unless LWP::Protocol::implementor($k);
	    $self->proxy($k, $v);
	}
    }
}


sub no_proxy {
    my($self, @no) = @_;
    if (@no) {
	push(@{ $self->{'no_proxy'} }, @no);
    }
    else {
	$self->{'no_proxy'} = [];
    }
}


sub _new_response {
    my($request, $code, $message) = @_;
    my $response = HTTP::Response->new($code, $message);
    $response->request($request);
    $response->header("Client-Date" => HTTP::Date::time2str(time));
    $response->header("Client-Warning" => "Internal response");
    $response->header("Content-Type" => "text/plain");
    $response->content("$code $message\n");
    return $response;
}


1;

}
##} /usr/local/libdata/perl5/site_perl/LWP/UserAgent.pm
BEGIN { $INC{'HTML/Form.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/HTML/Form.pm
{
package HTML::Form;

use strict;
BEGIN { URI->import(); } # (added by utils/combine-perl.pl)
use Carp ();

use vars qw($VERSION $Encode_available);
$VERSION = "5.829";

eval { require Encode };
$Encode_available = !$@;

my %form_tags = map {$_ => 1} qw(input textarea button select option);

my %type2class = (
 text     => "TextInput",
 password => "TextInput",
 hidden   => "TextInput",
 textarea => "TextInput",

 "reset"  => "IgnoreInput",

 radio    => "ListInput",
 checkbox => "ListInput",
 option   => "ListInput",

 button   => "SubmitInput",
 submit   => "SubmitInput",
 image    => "ImageInput",
 file     => "FileInput",

 keygen   => "KeygenInput",
);


sub parse
{
    my $class = shift;
    my $html = shift;
    unshift(@_, "base") if @_ == 1;
    my %opt = @_;

    require HTML::TokeParser;
    my $p = HTML::TokeParser->new(ref($html) ? $html->decoded_content(ref => 1) : \$html);
    die "Failed to create HTML::TokeParser object" unless $p;

    my $base_uri = delete $opt{base};
    my $charset = delete $opt{charset};
    my $strict = delete $opt{strict};
    my $verbose = delete $opt{verbose};

    if ($^W) {
	Carp::carp("Unrecognized option $_ in HTML::Form->parse") for sort keys %opt;
    }

    unless (defined $base_uri) {
	if (ref($html)) {
	    $base_uri = $html->base;
	}
	else {
	    Carp::croak("HTML::Form::parse: No \$base_uri provided");
	}
    }
    unless (defined $charset) {
	if (ref($html) and $html->can("content_charset")) {
	    $charset = $html->content_charset;
	}
	unless ($charset) {
	    $charset = "UTF-8";
	}
    }

    my @forms;
    my $f;  # current form

    my %openselect; # index to the open instance of a select

    while (my $t = $p->get_tag) {
	my($tag,$attr) = @$t;
	if ($tag eq "form") {
	    my $action = delete $attr->{'action'};
	    $action = "" unless defined $action;
	    $action = URI->new_abs($action, $base_uri);
	    $f = $class->new($attr->{'method'},
			     $action,
			     $attr->{'enctype'});
            $f->accept_charset($attr->{'accept-charset'}) if $attr->{'accept-charset'};
	    $f->{default_charset} = $charset;
	    $f->{attr} = $attr;
	    $f->strict(1) if $strict;
            %openselect = ();
	    push(@forms, $f);
	    my(%labels, $current_label);
	    while (my $t = $p->get_tag) {
		my($tag, $attr) = @$t;
		last if $tag eq "/form";

		if(defined $current_label) {
		    $current_label = join " ",
		        grep { defined and length }
		        $current_label,
		        $p->get_phrase;
		}

		if ($tag eq "input") {
		    $attr->{value_name} =
		        exists $attr->{id} && exists $labels{$attr->{id}} ? $labels{$attr->{id}} :
			defined $current_label                            ?  $current_label      :
		        $p->get_phrase;
		}

		if ($tag eq "label") {
		    $current_label = $p->get_phrase;
		    $labels{ $attr->{for} } = $current_label
		        if exists $attr->{for};
		}
		elsif ($tag eq "/label") {
		    $current_label = undef;
		}
		elsif ($tag eq "input") {
		    my $type = delete $attr->{type} || "text";
		    $f->push_input($type, $attr, $verbose);
		}
                elsif ($tag eq "button") {
                    my $type = delete $attr->{type} || "submit";
                    $f->push_input($type, $attr, $verbose);
                }
		elsif ($tag eq "textarea") {
		    $attr->{textarea_value} = $attr->{value}
		        if exists $attr->{value};
		    my $text = $p->get_text("/textarea");
		    $attr->{value} = $text;
		    $f->push_input("textarea", $attr, $verbose);
		}
		elsif ($tag eq "select") {
		    for ("value", "value_name") {
			$attr->{"select_$_"} = delete $attr->{$_}
			    if exists $attr->{$_};
		    }
		    my $name = $attr->{name};
		    $name = "" unless defined $name;
		    $openselect{$name}++;

		    while ($t = $p->get_tag) {
			my $tag = shift @$t;
			last if $tag eq "/select";
			next if $tag =~ m,/?optgroup,;
			next if $tag eq "/option";
			if ($tag eq "option") {
			    my %a = %{$t->[0]};
			    for (keys %a) {
				next if $_ eq "value";
				$a{"option_$_"} = delete $a{$_};
			    }
			    while (my($k,$v) = each %$attr) {
				$a{$k} = $v;
			    }
			    $a{value_name} = $p->get_trimmed_text;
			    $a{value} = delete $a{value_name}
				unless defined $a{value};
			    $a{idx} = $openselect{$name};
			    $f->push_input("option", \%a, $verbose);
			}
			else {
			    warn("Bad <select> tag '$tag' in $base_uri\n") if $verbose;
			    if ($tag eq "/form" ||
				$tag eq "input" ||
				$tag eq "textarea" ||
				$tag eq "select" ||
				$tag eq "keygen")
			    {
				my $type = ($tag =~ s,^/,,) ? "E" : "S";
				$p->unget_token([$type, $tag, @$t]);
				last;
			    }
			}
		    }
		}
		elsif ($tag eq "keygen") {
		    $f->push_input("keygen", $attr, $verbose);
		}
	    }
	}
	elsif ($form_tags{$tag}) {
	    warn("<$tag> outside <form> in $base_uri\n") if $verbose;
	}
    }
    for (@forms) {
	$_->fixup;
    }

    wantarray ? @forms : $forms[0];
}

sub new {
    my $class = shift;
    my $self = bless {}, $class;
    $self->{method} = uc(shift  || "GET");
    $self->{action} = shift  || Carp::croak("No action defined");
    $self->{enctype} = lc(shift || "application/x-www-form-urlencoded");
    $self->{accept_charset} = "UNKNOWN";
    $self->{default_charset} = "UTF-8";
    $self->{inputs} = [@_];
    $self;
}


sub push_input
{
    my($self, $type, $attr, $verbose) = @_;
    $type = lc $type;
    my $class = $type2class{$type};
    unless ($class) {
	Carp::carp("Unknown input type '$type'") if $verbose;
	$class = "TextInput";
    }
    $class = "HTML::Form::$class";
    my @extra;
    push(@extra, readonly => 1) if $type eq "hidden";
    push(@extra, strict => 1) if $self->{strict};
    if ($type eq "file" && exists $attr->{value}) {
	$attr->{orig_value} = delete $attr->{value};
    }
    delete $attr->{type}; # don't confuse the type argument
    my $input = $class->new(type => $type, %$attr, @extra);
    $input->add_to_form($self);
}



BEGIN {
    for (qw(method action enctype accept_charset)) {
	my $m = $_;
	no strict 'refs';
	*{$m} = sub {
	    my $self = shift;
	    my $old = $self->{$m};
	    $self->{$m} = shift if @_;
	    $old;
	};
    }
    *uri = \&action;  # alias
}


sub attr {
    my $self = shift;
    my $name = shift;
    return undef unless defined $name;

    my $old = $self->{attr}{$name};
    $self->{attr}{$name} = shift if @_;
    return $old;
}


sub strict {
    my $self = shift;
    my $old = $self->{strict};
    if (@_) {
	$self->{strict} = shift;
	for my $input (@{$self->{inputs}}) {
	    $input->strict($self->{strict});
	}
    }
    return $old;
}



sub inputs
{
    my $self = shift;
    @{$self->{'inputs'}};
}



sub find_input
{
    my($self, $name, $type, $no) = @_;
    if (wantarray) {
	my @res;
	my $c;
	for (@{$self->{'inputs'}}) {
	    next if defined($name) && !$_->selected($name);
	    next if $type && $type ne $_->{type};
	    $c++;
	    next if $no && $no != $c;
	    push(@res, $_);
	}
	return @res;
	
    }
    else {
	$no ||= 1;
	for (@{$self->{'inputs'}}) {
	    next if defined($name) && !$_->selected($name);
	    next if $type && $type ne $_->{type};
	    next if --$no;
	    return $_;
	}
	return undef;
    }
}

sub fixup
{
    my $self = shift;
    for (@{$self->{'inputs'}}) {
	$_->fixup;
    }
}



sub value
{
    my $self = shift;
    my $key  = shift;
    my $input = $self->find_input($key);
    unless ($input) {
	Carp::croak("No such field '$key'") if $self->{strict};
	return undef unless @_;
	$input = $self->push_input("text", { name => $key, value => "" });
    }
    local $Carp::CarpLevel = 1;
    $input->value(@_);
}


sub param {
    my $self = shift;
    if (@_) {
        my $name = shift;
        my @inputs;
        for ($self->inputs) {
            my $n = $_->name;
            next if !defined($n) || $n ne $name;
            push(@inputs, $_);
        }

        if (@_) {
            die "No '$name' parameter exists" unless @inputs;
	    my @v = @_;
	    @v = @{$v[0]} if @v == 1 && ref($v[0]);
            while (@v) {
                my $v = shift @v;
                my $err;
                for my $i (0 .. @inputs-1) {
                    eval {
                        $inputs[$i]->value($v);
                    };
                    unless ($@) {
                        undef($err);
                        splice(@inputs, $i, 1);
                        last;
                    }
                    $err ||= $@;
                }
                die $err if $err;
            }

	    for (@inputs) {
		$_->value(undef);
	    }
        }
        else {
            my @v;
            for (@inputs) {
		if (defined(my $v = $_->value)) {
		    push(@v, $v);
		}
            }
            return wantarray ? @v : $v[0];
        }
    }
    else {
        my @n;
        my %seen;
        for ($self->inputs) {
            my $n = $_->name;
            next if !defined($n) || $seen{$n}++;
            push(@n, $n);
        }
        return @n;
    }
}



sub try_others
{
    my($self, $cb) = @_;
    my @try;
    for (@{$self->{'inputs'}}) {
	my @not_tried_yet = $_->other_possible_values;
	next unless @not_tried_yet;
	push(@try, [\@not_tried_yet, $_]);
    }
    return unless @try;
    $self->_try($cb, \@try, 0);
}

sub _try
{
    my($self, $cb, $try, $i) = @_;
    for (@{$try->[$i][0]}) {
	$try->[$i][1]->value($_);
	&$cb($self);
	$self->_try($cb, $try, $i+1) if $i+1 < @$try;
    }
}



sub make_request
{
    my $self = shift;
    my $method  = uc $self->{'method'};
    my $uri     = $self->{'action'};
    my $enctype = $self->{'enctype'};
    my @form    = $self->form;

    my $charset = $self->accept_charset eq "UNKNOWN" ? $self->{default_charset} : $self->accept_charset;
    if ($Encode_available) {
        foreach my $fi (@form) {
            $fi = Encode::encode($charset, $fi) unless ref($fi);
        }
    }

    if ($method eq "GET") {
	require HTTP::Request;
	$uri = URI->new($uri, "http");
	$uri->query_form(@form);
	return HTTP::Request->new(GET => $uri);
    }
    elsif ($method eq "POST") {
	require HTTP::Request::Common;
	return HTTP::Request::Common::POST($uri, \@form,
					   Content_Type => $enctype);
    }
    else {
	Carp::croak("Unknown method '$method'");
    }
}



sub click
{
    my $self = shift;
    my $name;
    $name = shift if (@_ % 2) == 1;  # odd number of arguments

    for (@{$self->{'inputs'}}) {
        next unless $_->can("click");
        next if $name && !$_->selected($name);
	next if $_->disabled;
	return $_->click($self, @_);
    }
    Carp::croak("No clickable input with name $name") if $name;
    $self->make_request;
}



sub form
{
    my $self = shift;
    map { $_->form_name_value($self) } @{$self->{'inputs'}};
}



sub dump
{
    my $self = shift;
    my $method  = $self->{'method'};
    my $uri     = $self->{'action'};
    my $enctype = $self->{'enctype'};
    my $dump = "$method $uri";
    $dump .= " ($enctype)"
	if $enctype ne "application/x-www-form-urlencoded";
    $dump .= " [$self->{attr}{name}]"
    	if exists $self->{attr}{name};
    $dump .= "\n";
    for ($self->inputs) {
	$dump .= "  " . $_->dump . "\n";
    }
    print STDERR $dump unless defined wantarray;
    $dump;
}


package HTML::Form::Input;


sub new
{
    my $class = shift;
    my $self = bless {@_}, $class;
    $self;
}

sub add_to_form
{
    my($self, $form) = @_;
    push(@{$form->{'inputs'}}, $self);
    $self;
}

sub strict {
    my $self = shift;
    my $old = $self->{strict};
    if (@_) {
	$self->{strict} = shift;
    }
    $old;
}

sub fixup {}



sub type
{
    shift->{type};
}


sub name
{
    my $self = shift;
    my $old = $self->{name};
    $self->{name} = shift if @_;
    $old;
}

sub id
{
    my $self = shift;
    my $old = $self->{id};
    $self->{id} = shift if @_;
    $old;
}

sub class
{
    my $self = shift;
    my $old = $self->{class};
    $self->{class} = shift if @_;
    $old;
}

sub selected {
    my($self, $sel) = @_;
    return undef unless defined $sel;
    my $attr =
        $sel =~ s/^\^// ? "name"  :
        $sel =~ s/^#//  ? "id"    :
        $sel =~ s/^\.// ? "class" :
	                  "name";
    return 0 unless defined $self->{$attr};
    return $self->{$attr} eq $sel;
}

sub value
{
    my $self = shift;
    my $old = $self->{value};
    $self->{value} = shift if @_;
    $old;
}


sub possible_values
{
    return;
}


sub other_possible_values
{
    return;
}


sub value_names {
    return
}


sub readonly {
    my $self = shift;
    my $old = $self->{readonly};
    $self->{readonly} = shift if @_;
    $old;
}


sub disabled {
    my $self = shift;
    my $old = $self->{disabled};
    $self->{disabled} = shift if @_;
    $old;
}


sub form_name_value
{
    my $self = shift;
    my $name = $self->{'name'};
    return unless defined $name;
    return if $self->disabled;
    my $value = $self->value;
    return unless defined $value;
    return ($name => $value);
}

sub dump
{
    my $self = shift;
    my $name = $self->name;
    $name = "<NONAME>" unless defined $name;
    my $value = $self->value;
    $value = "<UNDEF>" unless defined $value;
    my $dump = "$name=$value";

    my $type = $self->type;

    $type .= " disabled" if $self->disabled;
    $type .= " readonly" if $self->readonly;
    return sprintf "%-30s %s", $dump, "($type)" unless $self->{menu};

    my @menu;
    my $i = 0;
    for (@{$self->{menu}}) {
	my $opt = $_->{value};
	$opt = "<UNDEF>" unless defined $opt;
	$opt .= "/$_->{name}"
	    if defined $_->{name} && length $_->{name} && $_->{name} ne $opt;
	substr($opt,0,0) = "-" if $_->{disabled};
	if (exists $self->{current} && $self->{current} == $i) {
	    substr($opt,0,0) = "!" unless $_->{seen};
	    substr($opt,0,0) = "*";
	}
	else {
	    substr($opt,0,0) = ":" if $_->{seen};
	}
	push(@menu, $opt);
	$i++;
    }

    return sprintf "%-30s %-10s %s", $dump, "($type)", "[" . join("|", @menu) . "]";
}


package HTML::Form::TextInput;
@HTML::Form::TextInput::ISA=qw(HTML::Form::Input);


sub value
{
    my $self = shift;
    my $old = $self->{value};
    $old = "" unless defined $old;
    if (@_) {
        Carp::croak("Input '$self->{name}' is readonly")
	    if $self->{strict} && $self->{readonly};
        my $new = shift;
        my $n = exists $self->{maxlength} ? $self->{maxlength} : undef;
        Carp::croak("Input '$self->{name}' has maxlength '$n'")
	    if $self->{strict} && defined($n) && defined($new) && length($new) > $n;
	$self->{value} = $new;
    }
    $old;
}

package HTML::Form::IgnoreInput;
@HTML::Form::IgnoreInput::ISA=qw(HTML::Form::Input);


sub value { return }


package HTML::Form::ListInput;
@HTML::Form::ListInput::ISA=qw(HTML::Form::Input);


sub new
{
    my $class = shift;
    my $self = $class->SUPER::new(@_);

    my $value = delete $self->{value};
    my $value_name = delete $self->{value_name};
    my $type = $self->{type};

    if ($type eq "checkbox") {
	$value = "on" unless defined $value;
	$self->{menu} = [
	    { value => undef, name => "off", },
            { value => $value, name => $value_name, },
        ];
	$self->{current} = (delete $self->{checked}) ? 1 : 0;
	;
    }
    else {
	$self->{option_disabled}++
	    if $type eq "radio" && delete $self->{disabled};
	$self->{menu} = [
            {value => $value, name => $value_name},
        ];
	my $checked = $self->{checked} || $self->{option_selected};
	delete $self->{checked};
	delete $self->{option_selected};
	if (exists $self->{multiple}) {
	    unshift(@{$self->{menu}}, { value => undef, name => "off"});
	    $self->{current} = $checked ? 1 : 0;
	}
	else {
	    $self->{current} = 0 if $checked;
	}
    }
    $self;
}

sub add_to_form
{
    my($self, $form) = @_;
    my $type = $self->type;

    return $self->SUPER::add_to_form($form)
	if $type eq "checkbox";

    if ($type eq "option" && exists $self->{multiple}) {
	$self->{disabled} ||= delete $self->{option_disabled};
	return $self->SUPER::add_to_form($form);
    }

    die "Assert" if @{$self->{menu}} != 1;
    my $m = $self->{menu}[0];
    $m->{disabled}++ if delete $self->{option_disabled};

    my $prev = $form->find_input($self->{name}, $self->{type}, $self->{idx});
    return $self->SUPER::add_to_form($form) unless $prev;

    $prev->{current} = @{$prev->{menu}} if exists $self->{current};
    push(@{$prev->{menu}}, $m);
}

sub fixup
{
    my $self = shift;
    if ($self->{type} eq "option" && !(exists $self->{current})) {
	$self->{current} = 0;
    }
    $self->{menu}[$self->{current}]{seen}++ if exists $self->{current};
}

sub disabled
{
    my $self = shift;
    my $type = $self->type;

    my $old = $self->{disabled} || _menu_all_disabled(@{$self->{menu}});
    if (@_) {
	my $v = shift;
	$self->{disabled} = $v;
        for (@{$self->{menu}}) {
            $_->{disabled} = $v;
        }
    }
    return $old;
}

sub _menu_all_disabled {
    for (@_) {
	return 0 unless $_->{disabled};
    }
    return 1;
}

sub value
{
    my $self = shift;
    my $old;
    $old = $self->{menu}[$self->{current}]{value} if exists $self->{current};
    $old = $self->{value} if exists $self->{value};
    if (@_) {
	my $i = 0;
	my $val = shift;
	my $cur;
	my $disabled;
	for (@{$self->{menu}}) {
	    if ((defined($val) && defined($_->{value}) && $val eq $_->{value}) ||
		(!defined($val) && !defined($_->{value}))
	       )
	    {
		$cur = $i;
		$disabled = $_->{disabled};
		last unless $disabled;
	    }
	    $i++;
	}
	if (!(defined $cur) || $disabled) {
	    if (defined $val) {
		my $i = 0;
		my $cur_ignorecase;
		my $lc_val = lc($val);
		for (@{$self->{menu}}) {
		    if (defined $_->{name}) {
			if ($val eq $_->{name}) {
			    $disabled = $_->{disabled};
			    $cur = $i;
			    last unless $disabled;
			}
			if (!defined($cur_ignorecase) && $lc_val eq lc($_->{name})) {
			    $cur_ignorecase = $i;
			}
		    }
		    $i++;
		}
		unless (defined $cur) {
		    $cur = $cur_ignorecase;
		    if (defined $cur) {
			$disabled = $self->{menu}[$cur]{disabled};
		    }
		    elsif ($self->{strict}) {
			my $n = $self->name;
		        Carp::croak("Illegal value '$val' for field '$n'");
		    }
		}
	    }
	    elsif ($self->{strict}) {
		my $n = $self->name;
	        Carp::croak("The '$n' field can't be unchecked");
	    }
	}
	if ($self->{strict} && $disabled) {
	    my $n = $self->name;
	    Carp::croak("The value '$val' has been disabled for field '$n'");
	}
	if (defined $cur) {
	    $self->{current} = $cur;
	    $self->{menu}[$cur]{seen}++;
	    delete $self->{value};
	}
	else {
	    $self->{value} = $val;
	    delete $self->{current};
	}
    }
    $old;
}


sub check
{
    my $self = shift;
    $self->{current} = 1;
    $self->{menu}[1]{seen}++;
}

sub possible_values
{
    my $self = shift;
    map $_->{value}, grep !$_->{disabled}, @{$self->{menu}};
}

sub other_possible_values
{
    my $self = shift;
    map $_->{value}, grep !$_->{seen} && !$_->{disabled}, @{$self->{menu}};
}

sub value_names {
    my $self = shift;
    my @names;
    for (@{$self->{menu}}) {
	my $n = $_->{name};
	$n = $_->{value} unless defined $n;
	push(@names, $n);
    }
    @names;
}


package HTML::Form::SubmitInput;
@HTML::Form::SubmitInput::ISA=qw(HTML::Form::Input);



sub click
{
    my($self,$form,$x,$y) = @_;
    for ($x, $y) { $_ = 1 unless defined; }
    local($self->{clicked}) = [$x,$y];
    return $form->make_request;
}

sub form_name_value
{
    my $self = shift;
    return unless $self->{clicked};
    return $self->SUPER::form_name_value(@_);
}


package HTML::Form::ImageInput;
@HTML::Form::ImageInput::ISA=qw(HTML::Form::SubmitInput);

sub form_name_value
{
    my $self = shift;
    my $clicked = $self->{clicked};
    return unless $clicked;
    return if $self->{disabled};
    my $name = $self->{name};
    $name = (defined($name) && length($name)) ? "$name." : "";
    return ("${name}x" => $clicked->[0],
	    "${name}y" => $clicked->[1]
	   );
}

package HTML::Form::FileInput;
@HTML::Form::FileInput::ISA=qw(HTML::Form::TextInput);


sub file {
    my $self = shift;
    $self->value(@_);
}


sub filename {
    my $self = shift;
    my $old = $self->{filename};
    $self->{filename} = shift if @_;
    $old = $self->file unless defined $old;
    $old;
}


sub content {
    my $self = shift;
    my $old = $self->{content};
    $self->{content} = shift if @_;
    $old;
}


sub headers {
    my $self = shift;
    my $old = $self->{headers} || [];
    $self->{headers} = [@_] if @_;
    @$old;
}

sub form_name_value {
    my($self, $form) = @_;
    return $self->SUPER::form_name_value($form)
	if $form->method ne "POST" ||
	   $form->enctype ne "multipart/form-data";

    my $name = $self->name;
    return unless defined $name;
    return if $self->{disabled};

    my $file = $self->file;
    my $filename = $self->filename;
    my @headers = $self->headers;
    my $content = $self->content;
    if (defined $content) {
	$filename = $file unless defined $filename;
	$file = undef;
	unshift(@headers, "Content" => $content);
    }
    elsif (!defined($file) || length($file) == 0) {
	return;
    }

    if (ref($file) eq "ARRAY") {
	my $f = shift @$file;
	my $fn = shift @$file;
	push(@headers, @$file);
	$file = $f;
	$filename = $fn unless defined $filename;
    }

    return ($name => [$file, $filename, @headers]);
}

package HTML::Form::KeygenInput;
@HTML::Form::KeygenInput::ISA=qw(HTML::Form::Input);

sub challenge {
    my $self = shift;
    return $self->{challenge};
}

sub keytype {
    my $self = shift;
    return lc($self->{keytype} || 'rsa');
}

1;

}
##} /usr/local/libdata/perl5/site_perl/HTML/Form.pm
##{ /usr/local/libdata/perl5/site_perl/WWW/Mechanize.pm
{
package WWW::Mechanize;


our $VERSION = '1.71';


use strict;
use warnings;

BEGIN { HTTP::Request->import( 1.30); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { LWP::UserAgent->import( 5.827); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { HTML::Form->import( 1.00); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { HTML::TokeParser->import(); } # (added by utils/combine-perl.pl)

BEGIN { LWP::UserAgent->import(); } # (added by utils/combine-perl.pl)
use base 'LWP::UserAgent';

our $HAS_ZLIB;
BEGIN {
    $HAS_ZLIB = eval 'use Compress::Zlib (); 1;';
}


sub new {
    my $class = shift;

    my %parent_parms = (
        agent       => "WWW-Mechanize/$VERSION",
        cookie_jar  => {},
    );

    my %mech_parms = (
        autocheck   => ($class eq 'WWW::Mechanize' ? 1 : 0),
        onwarn      => \&WWW::Mechanize::_warn,
        onerror     => \&WWW::Mechanize::_die,
        quiet       => 0,
        stack_depth => 8675309,     # Arbitrarily humongous stack
        headers     => {},
        noproxy     => 0,
    );

    my %passed_parms = @_;

    while ( my($key,$value) = each %passed_parms ) {
        if ( exists $mech_parms{$key} ) {
            $mech_parms{$key} = $value;
        }
        else {
            $parent_parms{$key} = $value;
        }
    }

    my $self = $class->SUPER::new( %parent_parms );
    bless $self, $class;

    for my $parm ( keys %mech_parms ) {
        $self->{$parm} = $mech_parms{$parm};
    }
    $self->{page_stack} = [];
    $self->env_proxy() unless $mech_parms{noproxy};

    $self->{proxy} = {} unless defined $self->{proxy};
    push( @{$self->requests_redirectable}, 'POST' );

    $self->_reset_page();

    return $self;
}


my %known_agents = (
    'Windows IE 6'      => 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)',
    'Windows Mozilla'   => 'Mozilla/5.0 (Windows; U; Windows NT 5.0; en-US; rv:1.4b) Gecko/20030516 Mozilla Firebird/0.6',
    'Mac Safari'        => 'Mozilla/5.0 (Macintosh; U; PPC Mac OS X; en-us) AppleWebKit/85 (KHTML, like Gecko) Safari/85',
    'Mac Mozilla'       => 'Mozilla/5.0 (Macintosh; U; PPC Mac OS X Mach-O; en-US; rv:1.4a) Gecko/20030401',
    'Linux Mozilla'     => 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.4) Gecko/20030624',
    'Linux Konqueror'   => 'Mozilla/5.0 (compatible; Konqueror/3; Linux)',
);

sub agent_alias {
    my $self = shift;
    my $alias = shift;

    if ( defined $known_agents{$alias} ) {
        return $self->agent( $known_agents{$alias} );
    }
    else {
        $self->warn( qq{Unknown agent alias "$alias"} );
        return $self->agent();
    }
}


sub known_agent_aliases {
    return sort keys %known_agents;
}


sub get {
    my $self = shift;
    my $uri = shift;

    $uri = $uri->url if ref($uri) eq 'WWW::Mechanize::Link';

    $uri = $self->base
            ? URI->new_abs( $uri, $self->base )
            : URI->new( $uri );

    return $self->SUPER::get( $uri->as_string, @_ );
}


sub put {
    my $self = shift;
    my $uri = shift;

    $uri = $uri->url if ref($uri) eq 'WWW::Mechanize::Link';

    $uri = $self->base
            ? URI->new_abs( $uri, $self->base )
            : URI->new( $uri );

    return $self->_SUPER_put( $uri->as_string, @_ );
}


sub _SUPER_put {
    require HTTP::Request::Common;
    my($self, @parameters) = @_;
    my @suff = $self->_process_colonic_headers(\@parameters,1);
    return $self->request( HTTP::Request::Common::PUT( @parameters ), @suff );
}


sub reload {
    my $self = shift;

    return unless my $req = $self->{req};

    return $self->_update_page( $req, $self->_make_request( $req, @_ ) );
}


sub back {
    my $self = shift;

    my $stack = $self->{page_stack};
    return unless $stack && @{$stack};

    my $popped = pop @{$self->{page_stack}};
    my $req    = $popped->{req};
    my $res    = $popped->{res};

    $self->_update_page( $req, $res );

    return 1;
}


sub success {
    my $self = shift;

    return $self->res && $self->res->is_success;
}



sub uri {
    my $self = shift;
    return $self->response->request->uri;
}

sub res {           my $self = shift; return $self->{res}; }
sub response {      my $self = shift; return $self->{res}; }
sub status {        my $self = shift; return $self->{status}; }
sub ct {            my $self = shift; return $self->{ct}; }
sub content_type {  my $self = shift; return $self->{ct}; }
sub base {          my $self = shift; return $self->{base}; }
sub is_html {
    my $self = shift;
    return defined $self->ct &&
        ($self->ct eq 'text/html' || $self->ct eq 'application/xhtml+xml');
}


sub title {
    my $self = shift;

    return unless $self->is_html;

    if ( not defined $self->{title} ) {
        require HTML::HeadParser;
        my $p = HTML::HeadParser->new;
        $p->parse($self->content);
        $self->{title} = $p->header('Title');
    }
    return $self->{title};
}


sub content {
    my $self = shift;
    my $content = $self->{content};

    if ( $self->is_html ) {
        my %parms = @_;

        if ( exists $parms{base_href} ) {
            my $base_href = (delete $parms{base_href}) || $self->base;
            $content=~s/<head>/<head>\n<base href="$base_href">/i;
        }

        if ( my $format = delete $parms{format} ) {
            if ( $format eq 'text' ) {
                $content = $self->text;
            }
            else {
                $self->die( qq{Unknown "format" parameter "$format"} );
            }
        }

        $self->_check_unhandled_parms( %parms );
    }

    return $content;
}


sub text {
    my $self = shift;

    if ( not defined $self->{text} ) {
        require HTML::TreeBuilder;
        my $tree = HTML::TreeBuilder->new();
        $tree->parse( $self->content );
        $tree->eof();
        $tree->elementify(); # just for safety
        $self->{text} = $tree->as_text();
        $tree->delete;
    }

    return $self->{text};
}

sub _check_unhandled_parms {
    my $self  = shift;
    my %parms = @_;

    for my $cmd ( sort keys %parms ) {
        $self->die( qq{Unknown named argument "$cmd"} );
    }
}


sub links {
    my $self = shift;

    $self->_extract_links() unless $self->{links};

    return @{$self->{links}} if wantarray;
    return $self->{links};
}


sub follow_link {
    my $self = shift;
    my %parms = ( n=>1, @_ );

    if ( $parms{n} eq 'all' ) {
        delete $parms{n};
        $self->warn( q{follow_link(n=>"all") is not valid} );
    }

    my $link = $self->find_link(%parms);
    if ( $link ) {
        return $self->get( $link->url );
    }

    if ( $self->{autocheck} ) {
        $self->die( 'Link not found' );
    }

    return;
}


sub find_link {
    my $self = shift;
    my %parms = ( n=>1, @_ );

    my $wantall = ( $parms{n} eq 'all' );

    $self->_clean_keys( \%parms, qr/^(n|(text|url|url_abs|name|tag|id|class)(_regex)?)$/ );

    my @links = $self->links or return;

    my $nmatches = 0;
    my @matches;
    for my $link ( @links ) {
        if ( _match_any_link_parms($link,\%parms) ) {
            if ( $wantall ) {
                push( @matches, $link );
            }
            else {
                ++$nmatches;
                return $link if $nmatches >= $parms{n};
            }
        }
    } # for @links

    if ( $wantall ) {
        return @matches if wantarray;
        return \@matches;
    }

    return;
} # find_link

sub _match_any_link_parms {
    my $link = shift;
    my $p = shift;

    return 1 unless keys %$p;

    return if defined $p->{url}           && !($link->url eq $p->{url} );
    return if defined $p->{url_regex}     && !($link->url =~ $p->{url_regex} );
    return if defined $p->{url_abs}       && !($link->url_abs eq $p->{url_abs} );
    return if defined $p->{url_abs_regex} && !($link->url_abs =~ $p->{url_abs_regex} );
    return if defined $p->{text}          && !(defined($link->text) && $link->text eq $p->{text} );
    return if defined $p->{text_regex}    && !(defined($link->text) && $link->text =~ $p->{text_regex} );
    return if defined $p->{name}          && !(defined($link->name) && $link->name eq $p->{name} );
    return if defined $p->{name_regex}    && !(defined($link->name) && $link->name =~ $p->{name_regex} );
    return if defined $p->{tag}           && !($link->tag && $link->tag eq $p->{tag} );
    return if defined $p->{tag_regex}     && !($link->tag && $link->tag =~ $p->{tag_regex} );

    return if defined $p->{id}            && !($link->attrs->{id} && $link->attrs->{id} eq $p->{id} );
    return if defined $p->{id_regex}      && !($link->attrs->{id} && $link->attrs->{id} =~ $p->{id_regex} );
    return if defined $p->{class}         && !($link->attrs->{class} && $link->attrs->{class} eq $p->{class} );
    return if defined $p->{class_regex}   && !($link->attrs->{class} && $link->attrs->{class} =~ $p->{class_regex} );

    return 1;

}

sub _clean_keys {
    my $self = shift;
    my $parms = shift;
    my $rx_keyname = shift;

    for my $key ( keys %$parms ) {
        my $val = $parms->{$key};
        if ( $key !~ qr/$rx_keyname/ ) {
            $self->warn( qq{Unknown link-finding parameter "$key"} );
            delete $parms->{$key};
            next;
        }

        my $key_regex = ( $key =~ /_regex$/ );
        my $val_regex = ( ref($val) eq 'Regexp' );

        if ( $key_regex ) {
            if ( !$val_regex ) {
                $self->warn( qq{$val passed as $key is not a regex} );
                delete $parms->{$key};
                next;
            }
        }
        else {
            if ( $val_regex ) {
                $self->warn( qq{$val passed as '$key' is a regex} );
                delete $parms->{$key};
                next;
            }
            if ( $val =~ /^\s|\s$/ ) {
                $self->warn( qq{'$val' is space-padded and cannot succeed} );
                delete $parms->{$key};
                next;
            }
        }
    } # for keys %parms

    return;
} # _clean_keys()



sub find_all_links {
    my $self = shift;
    return $self->find_link( @_, n=>'all' );
}


sub find_all_inputs {
    my $self = shift;
    my %criteria = @_;

    my $form = $self->current_form() or return;

    my @found;
    foreach my $input ( $form->inputs ) { # check every pattern for a match on the current hash
        my $matched = 1;
        foreach my $criterion ( sort keys %criteria ) { # Sort so we're deterministic
            my $field = $criterion;
            my $is_regex = ( $field =~ s/(?:_regex)$// );
            my $what = $input->{$field};
            $matched = defined($what) && (
                $is_regex
                    ? ( $what =~ $criteria{$criterion} )
                    : ( $what eq $criteria{$criterion} )
                );
            last if !$matched;
        }
        push @found, $input if $matched;
    }
    return @found;
}


sub find_all_submits {
    my $self = shift;

    return $self->find_all_inputs( @_, type_regex => qr/^(submit|image)$/ );
}



sub images {
    my $self = shift;

    $self->_extract_images() unless $self->{images};

    return @{$self->{images}} if wantarray;
    return $self->{images};
}


sub find_image {
    my $self = shift;
    my %parms = ( n=>1, @_ );

    my $wantall = ( $parms{n} eq 'all' );

    $self->_clean_keys( \%parms, qr/^(n|(alt|url|url_abs|tag)(_regex)?)$/ );

    my @images = $self->images or return;

    my $nmatches = 0;
    my @matches;
    for my $image ( @images ) {
        if ( _match_any_image_parms($image,\%parms) ) {
            if ( $wantall ) {
                push( @matches, $image );
            }
            else {
                ++$nmatches;
                return $image if $nmatches >= $parms{n};
            }
        }
    } # for @images

    if ( $wantall ) {
        return @matches if wantarray;
        return \@matches;
    }

    return;
}

sub _match_any_image_parms {
    my $image = shift;
    my $p = shift;

    return 1 unless keys %$p;

    return if defined $p->{url}           && !($image->url eq $p->{url} );
    return if defined $p->{url_regex}     && !($image->url =~ $p->{url_regex} );
    return if defined $p->{url_abs}       && !($image->url_abs eq $p->{url_abs} );
    return if defined $p->{url_abs_regex} && !($image->url_abs =~ $p->{url_abs_regex} );
    return if defined $p->{alt}           && !(defined($image->alt) && $image->alt eq $p->{alt} );
    return if defined $p->{alt_regex}     && !(defined($image->alt) && $image->alt =~ $p->{alt_regex} );
    return if defined $p->{tag}           && !($image->tag && $image->tag eq $p->{tag} );
    return if defined $p->{tag_regex}     && !($image->tag && $image->tag =~ $p->{tag_regex} );

    return 1;
}



sub find_all_images {
    my $self = shift;
    return $self->find_image( @_, n=>'all' );
}


sub forms {
    my $self = shift;

    $self->_extract_forms() unless $self->{forms};

    return @{$self->{forms}} if wantarray;
    return $self->{forms};
}

sub current_form {
    my $self = shift;

    if ( !$self->{current_form} ) {
        $self->form_number(1);
    }

    return $self->{current_form};
}


sub form_number {
    my ($self, $form) = @_;

    my $forms = $self->forms;
    if ( $forms->[$form-1] ) {
        $self->{current_form} = $forms->[$form-1];
        return $self->{current_form};
    }

    return;
}


sub form_name {
    my ($self, $form) = @_;

    my $temp;
    my @matches = grep {defined($temp = $_->attr('name')) and ($temp eq $form) } $self->forms;

    my $nmatches = @matches;
    if ( $nmatches > 0 ) {
        if ( $nmatches > 1 ) {
            $self->warn( "There are $nmatches forms named $form.  The first one was used." )
        }
        return $self->{current_form} = $matches[0];
    }

    return;
}


sub form_id {
    my ($self, $formid) = @_;

    my $temp;
    my @matches = grep { defined($temp = $_->attr('id')) and ($temp eq $formid) } $self->forms;
    if ( @matches ) {
        $self->warn( 'There are ', scalar @matches, " forms with ID $formid.  The first one was used." )
            if @matches > 1;
        return $self->{current_form} = $matches[0];
    }
    else {
        $self->warn( qq{ There is no form with ID "$formid"} );
        return undef;
    }
}



sub form_with_fields {
    my ($self, @fields) = @_;
    die 'no fields provided' unless scalar @fields;

    my @matches;
    FORMS: for my $form (@{ $self->forms }) {
        my @fields_in_form = $form->param();
        for my $field (@fields) {
            next FORMS unless grep { $_ eq $field } @fields_in_form;
        }
        push @matches, $form;
    }

    my $nmatches = @matches;
    if ( $nmatches > 0 ) {
        if ( $nmatches > 1 ) {
            $self->warn( "There are $nmatches forms with the named fields.  The first one was used." )
        }
        return $self->{current_form} = $matches[0];
    }
    else {
        $self->warn( qq{There is no form with the requested fields} );
        return undef;
    }
}


sub field {
    my ($self, $name, $value, $number) = @_;
    $number ||= 1;

    my $form = $self->current_form();
    if ($number > 1) {
        $form->find_input($name, undef, $number)->value($value);
    }
    else {
        if ( ref($value) eq 'ARRAY' ) {
            $form->param($name, $value);
        }
        else {
            $form->value($name => $value);
        }
    }
}


sub select {
    my ($self, $name, $value) = @_;

    my $form = $self->current_form();

    my $input = $form->find_input($name);
    if (!$input) {
        $self->warn( qq{Input "$name" not found} );
        return;
    }

    if ($input->type ne 'option') {
        $self->warn( qq{Input "$name" is not type "select"} );
        return;
    }

    if (ref($value) eq 'HASH') {
        for (keys %$value) {
            $self->warn(qq{Unknown select value parameter "$_"})
              unless $_ eq 'n';
        }

        if (defined($value->{n})) {
            my @inputs = $form->find_input($name, 'option');
            my @values = ();
            if (@inputs == 1) {
                @values = $inputs[0]->possible_values();
            }
            else {
                foreach my $input (@inputs) {
                    my @possible = $input->possible_values();
                    push @values, pop @possible;
                }
            }

            my $n = $value->{n};
            if (ref($n) eq 'ARRAY') {
                $value = [];
                for (@$n) {
                    unless (/^\d+$/) {
                        $self->warn(qq{"n" value "$_" is not a positive integer});
                        return;
                    }
                    push @$value, $values[$_ - 1];  # might be undef
                }
            }
            elsif (!ref($n) && $n =~ /^\d+$/) {
                $value = $values[$n - 1];           # might be undef
            }
            else {
                $self->warn('"n" value is not a positive integer or an array ref');
                return;
            }
        }
        else {
            $self->warn('Hash value is invalid');
            return;
        }
    } # hashref

    if (ref($value) eq 'ARRAY') {
        $form->param($name, $value);
        return 1;
    }

    $form->value($name => $value);
    return 1;
}


sub set_fields {
    my $self = shift;
    my %fields = @_;

    my $form = $self->current_form or $self->die( 'No form defined' );

    while ( my ( $field, $value ) = each %fields ) {
        if ( ref $value eq 'ARRAY' ) {
            $form->find_input( $field, undef,
                         $value->[1])->value($value->[0] );
        }
        else {
            $form->value($field => $value);
        }
    } # while
} # set_fields()


sub set_visible {
    my $self = shift;

    my $form = $self->current_form;
    my @inputs = $form->inputs;

    my $num_set = 0;
    for my $value ( @_ ) {
        if ( ref $value eq 'ARRAY' ) {
            my ( $type, $value ) = @$value;
            while ( my $input = shift @inputs ) {
                next if $input->type eq 'hidden';
                if ( $input->type eq $type ) {
                    $input->value( $value );
                    $num_set++;
                    last;
                }
            } # while
        }
        else {
            while ( my $input = shift @inputs ) {
                next if $input->type eq 'hidden';
                $input->value( $value );
                $num_set++;
                last;
            } # while
        }
    } # for

    return $num_set;
} # set_visible()


sub tick {
    my $self = shift;
    my $name = shift;
    my $value = shift;
    my $set = @_ ? shift : 1;  # default to 1 if not passed

    my $index = 0;
    while ( my $input = $self->current_form->find_input( $name, 'checkbox', $index ) ) {
        foreach my $val ($input->possible_values()) {
            next unless defined $val;
            if ($val eq $value) {
                $input->value($set ? $value : undef);
                return;
            }
        }

        $index++;
    } # while

    $self->warn( qq{No checkbox "$name" for value "$value" in form} );
} # tick()


sub untick {
    shift->tick(shift,shift,undef);
}


sub value {
    my $self = shift;
    my $name = shift;
    my $number = shift || 1;

    my $form = $self->current_form;
    if ( $number > 1 ) {
        return $form->find_input( $name, undef, $number )->value();
    }
    else {
        return $form->value( $name );
    }
} # value


sub click {
    my ($self, $button, $x, $y) = @_;
    for ($x, $y) { $_ = 1 unless defined; }
    my $request = $self->current_form->click($button, $x, $y);
    return $self->request( $request );
}


sub click_button {
    my $self = shift;
    my %args = @_;

    for ( keys %args ) {
        if ( !/^(number|name|value|input|x|y)$/ ) {
            $self->warn( qq{Unknown click_button parameter "$_"} );
        }
    }

    for ($args{x}, $args{y}) {
        $_ = 1 unless defined;
    }

    my $form = $self->current_form or $self->die( 'click_button: No form has been selected' );

    my $request;
    if ( $args{name} ) {
        $request = $form->click( $args{name}, $args{x}, $args{y} );
    }
    elsif ( $args{number} ) {
        my $input = $form->find_input( undef, 'submit', $args{number} );
        $request = $input->click( $form, $args{x}, $args{y} );
    }
    elsif ( $args{input} ) {
        $request = $args{input}->click( $form, $args{x}, $args{y} );
    }
    elsif ( $args{value} ) {
        my $i = 1;
        while ( my $input = $form->find_input(undef, 'submit', $i) ) {
            if ( $args{value} && ($args{value} eq $input->value) ) {
                $request = $input->click( $form, $args{x}, $args{y} );
                last;
            }
            $i++;
        } # while
    } # $args{value}

    return $self->request( $request );
}


sub submit {
    my $self = shift;

    my $request = $self->current_form->make_request;
    return $self->request( $request );
}


sub submit_form {
    my( $self, %args ) = @_;

    for ( keys %args ) {
        if ( !/^(form_(number|name|fields|id)|(with_)?fields|button|x|y)$/ ) {
            $self->warn( qq{Unknown submit_form parameter "$_"} );
        }
    }

    my $fields;
    for (qw/with_fields fields/) {
        if ($args{$_}) {
            if ( ref $args{$_} eq 'HASH' ) {
                $fields = $args{$_};
            }
            else {
                die "$_ arg to submit_form must be a hashref";
            }
            last;
        }
    }

    if ( $args{with_fields} ) {
        $fields || die q{must submit some 'fields' with with_fields};
        $self->form_with_fields(keys %{$fields}) or die "There is no form with the requested fields";
    }
    elsif ( my $form_number = $args{form_number} ) {
        $self->form_number( $form_number ) or die "There is no form numbered $form_number";
    }
    elsif ( my $form_name = $args{form_name} ) {
        $self->form_name( $form_name ) or die qq{There is no form named "$form_name"};
    }
    elsif ( my $form_id = $args{form_id} ) {
        $self->form_id( $form_id ) or die qq{There is no form with ID "$form_id"};
    }
    else {
    }

    $self->set_fields( %{$fields} ) if $fields;

    my $response;
    if ( $args{button} ) {
        $response = $self->click( $args{button}, $args{x} || 0, $args{y} || 0 );
    }
    else {
        $response = $self->submit();
    }

    return $response;
}


sub add_header {
    my $self = shift;
    my $npairs = 0;

    while ( @_ ) {
        my $key = shift;
        my $value = shift;
        ++$npairs;

        $self->{headers}{$key} = $value;
    }

    return $npairs;
}


sub delete_header {
    my $self = shift;

    while ( @_ ) {
        my $key = shift;

        delete $self->{headers}{$key};
    }

    return;
}



sub quiet {
    my $self = shift;

    $self->{quiet} = $_[0] if @_;

    return $self->{quiet};
}


sub stack_depth {
    my $self = shift;
    $self->{stack_depth} = shift if @_;
    return $self->{stack_depth};
}


sub save_content {
    my $self = shift;
    my $filename = shift;

    open( my $fh, '>', $filename ) or $self->die( "Unable to create $filename: $!" );
    binmode $fh unless $self->content_type =~ m{^text/};
    print {$fh} $self->content or $self->die( "Unable to write to $filename: $!" );
    close $fh or $self->die( "Unable to close $filename: $!" );

    return;
}



sub dump_headers {
    my $self = shift;
    my $fh   = shift || \*STDOUT;

    print {$fh} $self->response->headers_as_string;

    return;
}



sub dump_links {
    my $self = shift;
    my $fh = shift || \*STDOUT;
    my $absolute = shift;

    for my $link ( $self->links ) {
        my $url = $absolute ? $link->url_abs : $link->url;
        $url = '' if not defined $url;
        print {$fh} $url, "\n";
    }
    return;
}


sub dump_images {
    my $self = shift;
    my $fh = shift || \*STDOUT;
    my $absolute = shift;

    for my $image ( $self->images ) {
        my $url = $absolute ? $image->url_abs : $image->url;
        $url = '' if not defined $url;
        print {$fh} $url, "\n";
    }
    return;
}


sub dump_forms {
    my $self = shift;
    my $fh = shift || \*STDOUT;

    for my $form ( $self->forms ) {
        print {$fh} $form->dump, "\n";
    }
    return;
}


sub dump_text {
    my $self = shift;
    my $fh = shift || \*STDOUT;
    my $absolute = shift;

    print {$fh} $self->text, "\n";

    return;
}



sub clone {
    my $self  = shift;
    my $clone = $self->SUPER::clone();

    $clone->cookie_jar( $self->cookie_jar );

    return $clone;
}



sub redirect_ok {
    my $self = shift;
    my $prospective_request = shift;
    my $response = shift;

    my $ok = $self->SUPER::redirect_ok( $prospective_request, $response );
    if ( $ok ) {
        $self->{redirected_uri} = $prospective_request->uri;
    }

    return $ok;
}



sub request {
    my $self = shift;
    my $request = shift;

    $request = $self->_modify_request( $request );

    if ( $request->method eq 'GET' || $request->method eq 'POST' ) {
        $self->_push_page_stack();
    }

    return $self->_update_page($request, $self->_make_request( $request, @_ ));
}


sub update_html {
    my $self = shift;
    my $html = shift;

    $self->_reset_page;
    $self->{ct} = 'text/html';
    $self->{content} = $html;

    return;
}


sub credentials {
    my $self = shift;

    if (@_ == 4 || (@_ == 2 && $_[0] =~ /:\d+$/)) {
        return $self->SUPER::credentials(@_);
    }

    @_ == 2
        or $self->die( 'Invalid # of args for overridden credentials()' );

    return @$self{qw( __username __password )} = @_;
}


sub get_basic_credentials {
    my $self = shift;
    my @cred = grep { defined } @$self{qw( __username __password )};
    return @cred if @cred == 2;
    return $self->SUPER::get_basic_credentials(@_);
}


sub clear_credentials {
    my $self = shift;
    delete @$self{qw( __username __password )};
}


sub _update_page {
    my ($self, $request, $res) = @_;

    $self->{req} = $request;
    $self->{redirected_uri} = $request->uri->as_string;

    $self->{res} = $res;

    $self->{status}  = $res->code;
    $self->{base}    = $res->base;
    $self->{ct}      = $res->content_type || '';

    if ( $res->is_success ) {
        $self->{uri} = $self->{redirected_uri};
        $self->{last_uri} = $self->{uri};
    }

    if ( $res->is_error ) {
        if ( $self->{autocheck} ) {
            $self->die( 'Error ', $request->method, 'ing ', $request->uri, ': ', $res->message );
        }
    }

    $self->_reset_page;

    my $content = $res->decoded_content();
    $content = $res->content if (not defined $content);

    $content .= _taintedness();

    if ($self->is_html) {
        $self->update_html($content);
    }
    else {
        $self->{content} = $content;
    }

    return $res;
} # _update_page

our $_taintbrush;

sub _taintedness {
    return $_taintbrush if defined $_taintbrush;

    $_taintbrush = substr("$0$^X", 0, 0);
    return $_taintbrush if _is_tainted( $_taintbrush );

    $_taintbrush = substr(join('', grep { defined } @ARGV, %ENV), 0, 0);
    return $_taintbrush if _is_tainted( $_taintbrush );

    for my $filename ( qw(/dev/null / . ..), values %INC, $0, $^X ) {
        if ( open my $fh, '<', $filename ) {
            my $data;
            if ( defined sysread $fh, $data, 1 ) {
                $_taintbrush = substr( $data, 0, 0 );
                last if _is_tainted( $_taintbrush );
            }
        }
    }

    die "Our taintbrush should have zero length!" if length $_taintbrush;

    return $_taintbrush;
}

sub _is_tainted {
    no warnings qw(void uninitialized);

    return !eval { join('', shift), kill 0; 1 };
} # _is_tainted



sub _modify_request {
    my $self = shift;
    my $req = shift;

    if (not $req->header( 'Accept-Encoding' ) ) {
        $req->header( 'Accept-Encoding', $HAS_ZLIB ? 'gzip' : 'identity' );
    }

    my $last = $self->{last_uri};
    if ( $last ) {
        $last = $last->as_string if ref($last);
        $req->header( Referer => $last );
    }
    while ( my($key,$value) = each %{$self->{headers}} ) {
        if ( defined $value ) {
            $req->header( $key => $value );
        }
        else {
            $req->remove_header( $key );
        }
    }

    return $req;
}



sub _make_request {
    my $self = shift;
    return $self->SUPER::request(@_);
}


sub _reset_page {
    my $self = shift;

    $self->{links}        = undef;
    $self->{images}       = undef;
    $self->{forms}        = undef;
    $self->{current_form} = undef;
    $self->{title}        = undef;
    $self->{text}         = undef;

    return;
}


my %link_tags = (
    a      => 'href',
    area   => 'href',
    frame  => 'src',
    iframe => 'src',
    link   => 'href',
    meta   => 'content',
);

sub _extract_links {
    my $self = shift;


    $self->{links} = [];
    if ( defined $self->{content} ) {
        my $parser = HTML::TokeParser->new(\$self->{content});
        while ( my $token = $parser->get_tag( keys %link_tags ) ) {
            my $link = $self->_link_from_token( $token, $parser );
            push( @{$self->{links}}, $link ) if $link;
        } # while
    }

    return;
}


my %image_tags = (
    img   => 'src',
    input => 'src',
);

sub _extract_images {
    my $self = shift;

    $self->{images} = [];

    if ( defined $self->{content} ) {
        my $parser = HTML::TokeParser->new(\$self->{content});
        while ( my $token = $parser->get_tag( keys %image_tags ) ) {
            my $image = $self->_image_from_token( $token, $parser );
            push( @{$self->{images}}, $image ) if $image;
        } # while
    }

    return;
}

sub _image_from_token {
    my $self = shift;
    my $token = shift;
    my $parser = shift;

    my $tag = $token->[0];
    my $attrs = $token->[1];

    if ( $tag eq 'input' ) {
        my $type = $attrs->{type} or return;
        return unless $type eq 'image';
    }

    require WWW::Mechanize::Image;
    return
        WWW::Mechanize::Image->new({
            tag     => $tag,
            base    => $self->base,
            url     => $attrs->{src},
            name    => $attrs->{name},
            height  => $attrs->{height},
            width   => $attrs->{width},
            alt     => $attrs->{alt},
        });
}

sub _link_from_token {
    my $self = shift;
    my $token = shift;
    my $parser = shift;

    my $tag = $token->[0];
    my $attrs = $token->[1];
    my $url = $attrs->{$link_tags{$tag}};

    my $text;
    my $name;
    if ( $tag eq 'a' ) {
        $text = $parser->get_trimmed_text("/$tag");
        $text = '' unless defined $text;

        my $onClick = $attrs->{onclick};
        if ( $onClick && ($onClick =~ /^window\.open\(\s*'([^']+)'/) ) {
            $url = $1;
        }
    } # a


    $name = $attrs->{name};

    if ( $tag eq 'meta' ) {
        my $equiv = $attrs->{'http-equiv'};
        my $content = $attrs->{'content'};
        return unless $equiv && (lc $equiv eq 'refresh') && defined $content;

        if ( $content =~ /^\d+\s*;\s*url\s*=\s*(\S+)/i ) {
            $url = $1;
            $url =~ s/^"(.+)"$/$1/ or $url =~ s/^'(.+)'$/$1/;
        }
        else {
            undef $url;
        }
    } # meta

    return unless defined $url;   # probably just a name link or <AREA NOHREF...>

    require WWW::Mechanize::Link;
    return
        WWW::Mechanize::Link->new({
            url  => $url,
            text => $text,
            name => $name,
            tag  => $tag,
            base => $self->base,
            attrs => $attrs,
        });
} # _link_from_token


sub _extract_forms {
    my $self = shift;

    my @forms = HTML::Form->parse( $self->content, $self->base );
    $self->{forms} = \@forms;
    for my $form ( @forms ) {
        for my $input ($form->inputs) {
             if ($input->type eq 'file') {
                 $input->value( undef );
             }
        }
    }

    return;
}


sub _push_page_stack {
    my $self = shift;

    my $req = $self->{req};
    my $res = $self->{res};

    return unless $req && $res && $self->stack_depth;

    my $stack = $self->{page_stack} ||= [];
    if ( @{$stack} >= $self->stack_depth ) {
        shift @{$stack};
    }
    push( @{$stack}, { req => $req, res => $res } );

    return 1;
}


sub warn {
    my $self = shift;

    return unless my $handler = $self->{onwarn};

    return if $self->quiet;

    return $handler->(@_);
}


sub die {
    my $self = shift;

    return unless my $handler = $self->{onerror};

    return $handler->(@_);
}


sub _warn {
    require Carp;
    return &Carp::carp; ## no critic
}

sub _die {
    require Carp;
    return &Carp::croak; ## no critic
}

1; # End of module

}
##} /usr/local/libdata/perl5/site_perl/WWW/Mechanize.pm
BEGIN { $INC{'FlashVideo/Downloader.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Site.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site.pm
{
package FlashVideo::Site;

use strict;


sub debug {
  $App::get_flash_videos::opt{debug};
}

sub action {
  $App::get_flash_videos::opt{play} ? "play" : "download";
}

sub player {
  $App::get_flash_videos::opt{player};
}

sub yes {
  $App::get_flash_videos::opt{yes};
}

sub quiet {
  $App::get_flash_videos::opt{quiet};
}

1;
}
##} blib/lib/FlashVideo/Site.pm
##{ blib/lib/FlashVideo/Downloader.pm
{
package FlashVideo::Downloader;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *get_win_codepage = \&FlashVideo::Utils::get_win_codepage; *get_terminal_width = \&FlashVideo::Utils::get_terminal_width; }

BEGIN { FlashVideo::Site->import(); } # (added by utils/combine-perl.pl)
use base "FlashVideo::Site";

sub new {
  my $class = shift;

  my $self = {
    has_readkey => scalar eval { require Term::ReadKey }
  };

  bless $self, $class;
  return $self;
}

sub play {
  my ($self, $url, $file, $browser) = @_;

  $self->{stream} = sub {
    $self->{stream} = undef;

    if ($^O =~ /MSWin/i and $self->player eq "VLC") {
      if (my $vlc_binary = FlashVideo::Utils::get_vlc_exe_from_registry()) {
        require Win32::Process;
        require File::Basename;
        require File::Spec;
        $file = File::Spec->rel2abs($file);

        my $binary_no_path = File::Basename::basename $vlc_binary;

        my $binary_just_path = File::Basename::dirname $vlc_binary; 

        my $process;
        Win32::Process::Create(
          $process,
          $vlc_binary,
          "$binary_no_path $file",
          1,
          32, # NORMAL_PRIORITY_CLASS
          $binary_just_path,
        ) or info "Couldn't launch VLC ($vlc_binary): " . Win32::GetLastError();
      }
    }
    else {
      my $pid = fork;
      die "Fork failed" unless defined $pid;
      if(!$pid) {
        exec $self->replace_filename($self->player, $file);
        die "Exec failed\n";
      }
    }
  };

  $self->download($url, $file, $browser);
}

sub download {
  my ($self, $url, $file, $browser) = @_;

  $self->{printable_filename} = $file;

  $file = $self->get_filename($file);

  my $mode = (-e $file) ? '>>' : '>';
  my $offset;
  if ($file ne '-' && -e $file) {
    $offset = -s $file;

    my $response = $browser->head($url);

    if ($offset == $response->header('Content-Length')) {
      error "File $self->{printable_filename} has been fully downloaded.";
      $self->{stream}->() if defined $self->{stream};
      return;
    }

    info "File $self->{printable_filename} already exists, seeing if resuming is supported.";
    if (!$response->header('Accept-Ranges')) {
      if(!$self->yes) {
        error "This server doesn't explicitly support resuming.\n" .
                   "Do you want to try resuming anyway (y/n)?";
        chomp(my $answer = <STDIN>);
        if (!$answer or lc($answer) eq 'n') {
          undef $offset;
          $mode = '>';
        }
      }
    }
    else {
      info "Server supports resuming, attempting to resume.";
    }
  }

  my $video_fh;
  if($file eq '-') {
    $video_fh = \*STDOUT;
  } else {
    open $video_fh, $mode, $file or die $!;
  }

  binmode $video_fh;
  $self->{fh} = $video_fh;

  info "Downloading $url...";
  if ($offset) {
    $browser->add_header("Range", "bytes=$offset-");
  }
  my $response = $browser->get($url,
    ':content_cb' => sub {
        my ($data, $response) = @_;

        if (!$self->{content_length}) {
          $self->{content_length} = $response->header('Content-Length')
                                    + $offset;

          if($response->header('Content-encoding') =~ /gzip/i) {
            eval { require Compress::Zlib; } or do {
              error "Must have Compress::Zlib installed to download from this site.\n";
              exit 1;
            };

            my($inflate, $status) = Compress::Zlib::inflateInit(
              -WindowBits => -Compress::Zlib::MAX_WBITS());
            error "inflateInit failed: $status" if $status;

            $self->{filter} = sub {
              my($data) = @_;

              if(!$self->{downloaded}) {
                Compress::Zlib::_removeGzipHeader(\$data);
              }

              my($output, $status) = $inflate->inflate($data);
              return $output;
            }
          }
        }

        if ($offset and !$response->header('Content-Range')) {
          error "Resuming failed - please delete $self->{printable_filename} and restart.";
          exit 1;
        }
        else {
          $self->{downloaded} = $offset unless $self->{downloaded};
        }

        my $len = length $data;

        if($self->{filter}) {
          $data = $self->{filter}->($data);
        }

        return unless $data;

        my $fh = $self->{fh};
        print $fh $data || die "Unable to write to '$self->{printable_filename}': $!\n";

        if(defined $self->{stream}) {
          if($self->{downloaded} > 300_000) {
            $self->{stream}->();
          }
        }

        if(!$self->{downloaded} && length $data > 16) {
          if(!$self->check_magic($data)) {
            error "Sorry, file does not look like a media file, aborting.";
            exit 1;
          }
        }

        $self->{downloaded} += $len;
        $self->progress;
    }, ':read_size_hint' => 16384);

  if($browser->response->header("X-Died")) {
    error $browser->response->header("X-Died");
  }

  close $self->{fh} || die "Unable to write to '$self->{printable_filename}': $!";

  if ($browser->success) {
    return $self->{downloaded} - $offset;
  } else {
    unlink $file unless -s $file;
    error "Couldn't download $url: " .  $browser->response->status_line;
    return 0;
  }
}

sub progress {
  my($self) = @_;

  return unless -t STDERR;
  return if $self->quiet;

  my $progress_text;

  if ($self->{content_length}) {
    my $percent = int(
      ($self->{downloaded} / $self->{content_length}) * 100
    );
    if ($percent != $self->{percent} || time != $self->{last_time}) {
      my $downloaded_kib = _bytes_to_kib($self->{downloaded});
      my $total_kib      = _bytes_to_kib($self->{content_length});
      $progress_text = ": $percent% ($downloaded_kib / $total_kib KiB)";
      $self->{last_time} = time;
      $self->{percent} = $percent;
    }
  } else {
    my $data_transferred = _bytes_to_kib($self->{downloaded});
    if ($data_transferred != $self->{data_transferred}) {
      $progress_text = ": $data_transferred KiB";
    }
  }

  if($progress_text) {
    my $width = get_terminal_width();

    my $filename = $self->{printable_filename};
    my $filename_len = $width - length($progress_text);

    if($filename_len < length $filename) {
      my $rem = 3 + length($filename) - $filename_len;
      my $pos = length($filename) - $rem - 12;
      $pos = 0 if $pos < 0;
      substr($filename, $pos, $rem) = "...";
    }

    syswrite STDERR, "\r$filename$progress_text";
  }
}

sub _bytes_to_kib {
  return sprintf '%0.2f', ($_[0] / 1024)
}

sub replace_filename {
  my($self, $string, $filename) = @_;
  $string .= " %s" unless $string =~ /%s/;
  my $esc = $self->shell_escape($filename);
  $string =~ s/['"]?%s['"]?/$esc/g;
  return $string;
}

sub shell_escape {
  my($self, $file) = @_;

  $file =~ s/'/'\\''/g;
  return "'$file'";
}

sub check_file {
  my($self, $file) = @_;

  open my $fh, "<", $file;
  binmode $fh;
  my $data;
  read $fh, $data, 16;

  return $self->check_magic($data);
}

sub check_magic {
  my($self, $data) = @_;


  if(substr($data, 0, 3) eq 'FLV') {
    return 1;
  } elsif(substr($data, 0, 3) eq 'ID3') {
    return 1;
  } elsif(substr($data, 0, 4) eq "\x30\x26\xb2\x75") {
    return 1;
  } elsif(substr($data, 4, 4) eq 'ftyp') {
    return 1;
  } elsif(substr($data, 4, 4) =~ /moov|mdat|wide|free|pnot|skip/) {
    return 1;
  } elsif(substr($data, 0, 4) eq 'OggS') {
    return 1;
  } elsif(substr($data, 0x1F, 4) eq 'webm') {
    return 1;
  } elsif(substr($data, 0, 4) eq 'RIFF') {
    return 1;
  }

  return 0;
}

sub get_filename {
  my($self, $file) = @_;

  if($^O =~ /MSWin/i) {
    $file = Encode::encode(get_win_codepage(), $file);
    $file =~ s/\?/_/g;
  }

  return $file;
}

1;

}
##} blib/lib/FlashVideo/Downloader.pm
##{ blib/lib/FlashVideo/Mechanize.pm
{
package FlashVideo::Mechanize;
BEGIN { WWW::Mechanize->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Downloader->import(); } # (added by utils/combine-perl.pl)
use Encode ();

use strict;
BEGIN { WWW::Mechanize->import(); } # (added by utils/combine-perl.pl)
use base "WWW::Mechanize";

sub new {
  my $class = shift;
  my $browser = $class->SUPER::new(autocheck => 0);
  $browser->agent_alias("Windows Mozilla");

  my $proxy = $App::get_flash_videos::opt{proxy};

  if ($proxy) {
    if ($proxy =~ /^(\w+):?(\d+)?$/) {
      my ($host, $port) = ($1, $2);

      $port ||= 1080; # socks by default

      $proxy = "socks://$host:$port";

      print STDERR "Using proxy server $proxy\n"
        if $App::get_flash_videos::opt{debug};

      $browser->proxy([qw[http https]] => $proxy);
    }
  }

  if($browser->get_socks_proxy) {
    if(!eval { require LWP::Protocol::socks }) {
      die "LWP::Protocol::socks is required for SOCKS support, please install it\n";
    }
  }

  return $browser;
}

sub redirect_ok {
  my($self) = @_;

  return $self->{redirects_ok};
}

sub allow_redirects {
  my($self) = @_;
  $self->{redirects_ok} = 1;
}

sub get {
  my($self, @rest) = @_;

  print STDERR "-> GET $rest[0]\n" if $App::get_flash_videos::opt{debug};

  my $r = $self->SUPER::get(@rest);

  if($App::get_flash_videos::opt{debug}) {
    my $text = join " ", $self->response->code,
      $self->response->header("Content-type"), "(" . length($self->content) . ")";
    $text .= ": " . DBI::data_string_desc($self->content) if eval { require DBI };

    print STDERR "<- $text\n";
  }

  return $r;
}

sub update_html {
  my($self, $html) = @_;

  my $charset = _parse_charset($self->response->header("Content-type"));

  if($LWP::UserAgent::VERSION < 5.827
    && (!$charset || !Encode::is_utf8($html))) {

    $html = Encode::encode("iso-8859-1", $html) if Encode::is_utf8($html);

    if(!FlashVideo::Downloader->check_magic($html)) {
      my $p = HTML::TokeParser->new(\$html);
      while(my $token = $p->get_tag("meta")) {
        my($tag, $attr) = @$token;
        if($tag eq 'meta' && $attr->{"http-equiv"} =~ /Content-type/i) {
          $charset ||= _parse_charset($attr->{content});
        }
      }

      if($charset) {
        eval { $html = Encode::decode($charset, $html) };
        FlashVideo::Utils::error("Failed decoding as $charset: $@") if $@;
      }
    }
  }

  return $self->SUPER::update_html($html);
}

sub _parse_charset {
  my($field) = @_;
  return(($field =~ /;\s*charset=([-_.:a-z0-9]+)/i)[0]);
}

sub get_socks_proxy {
  my $self = shift;
  my $proxy = $self->proxy("http");

  if(defined $proxy && $proxy =~ m!^socks://(.*?):(\d+)!) {
    return "$1:$2";
  }

  return "";
}

1;
}
##} blib/lib/FlashVideo/Mechanize.pm
##{ blib/lib/FlashVideo/Site/Googlevideosearch.pm
{
package FlashVideo::Site::Googlevideosearch;

use strict;
no warnings 'uninitialized';
BEGIN { FlashVideo::Mechanize->import(); } # (added by utils/combine-perl.pl)

sub search {
  my($self, $search, $type) = @_;

  my $browser = FlashVideo::Mechanize->new;
  
  $browser->get('http://video.google.com/');

  $browser->submit_form(
    with_fields => {
      q => $search,
    }
  );

  return unless $browser->success;

  my @links = map  { 
                     chomp(my $name = $_->text);
                     { name => $name, url => $_->url_abs->as_string }
              }
              grep { 
                $_->attrs->{onclick} =~ /return resultClick/
                || $_->attrs->{onmousedown} =~ /video_result/
                || $_->attrs->{class} eq 'l'
              }
              $browser->find_all_links(text_regex => qr/.+/);

  return @links;
}

1;
}
##} blib/lib/FlashVideo/Site/Googlevideosearch.pm
BEGIN { $INC{'FlashVideo/Site/Grindtv.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Grindtv.pm
{
package FlashVideo::Site::Grindtv;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

my %sites = (
  Grindtv => "http://videos.grindtv.com/1/",
  Stupidvideos => "http://videos.stupidvideos.com/2/",
  Ringtv => "http://videos.ringtv.com/7/"
);

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $site = ($self =~ /::([^:]+)$/)[0];
  my $base = $sites{$site};

  my $id;
  if($browser->content =~ /(?:baseID|video(?:ID)?)\s*=\s*['"]?(\d+)/) {
    $id = $1;
  }
  die "No ID found\n" unless $id;

  my $title = ($browser->content =~ /name="title" content="([^"]+)/i)[0];
  $title = extract_title($browser) unless $title;

  my $filename = title_to_filename($title);

  $browser->allow_redirects;

  my $str = sprintf "%08d", $id;
  my $url = $base . join("/", map { substr $str, $_*2, 2 } 0 .. 3) . "/$id.flv";

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Grindtv.pm
BEGIN { $INC{'FlashVideo/Site/Ima.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Ima.pm
{
package FlashVideo::Site::Ima;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my($id) = $browser->uri =~ /id=(\d+)/;
  die "ID not found" unless $id;

  my $rpc = "http://www.ima.umn.edu/videos/video_rpc.php?id=$id";
  $browser->get($rpc);

  my($title) = $browser->content =~ m{<video_title>(.*)</video_title>};
  my($instance) = $browser->content =~ m{<video_instance>(.*)</video_instance>};
  my($file) = $browser->content =~ m{<video_file>(.*)</video_file>};

  return {
    rtmp => "rtmp://reel.ima.umn.edu/ima/$instance/$file",
    flv  => title_to_filename($title)
  };
}

sub can_handle {
  my($self, $browser) = @_;

  return $browser->uri->host =~ /ima\.umn\.edu/i;
}

1;
}
##} blib/lib/FlashVideo/Site/Ima.pm
BEGIN { $INC{'FlashVideo/Site/Itv.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Itv.pm
{
package FlashVideo::Site::Itv;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *swfhash = \&FlashVideo::Utils::swfhash; }
use HTML::Entities;

my $resolutions = {
  "16x9" => {
    "400" => [412, 232],
    "600" => [512, 288],
    "800" => [640, 360],
    "1200" => [704, 396],
  },
  "4x3" => {
    "400" => [320, 240],
    "600" => [384, 288],
    "800" => [480, 360],
    "1200" => [528, 396],
  },
};

sub find_video {
  my ($self, $browser, $page_url, $prefs) = @_;

  my($id) = $browser->uri =~ /Filter=(\d+)/;
  die "No id (filter) found in URL\n" unless $id;

  $browser->post("http://mercury.itv.com/PlaylistService.svc",
    Content_Type => "text/xml; charset=utf-8",
    Referer      => "http://www.itv.com/mercury/Mercury_VideoPlayer.swf?v=1.5.309/[[DYNAMIC]]/2",
    SOAPAction   => '"http://tempuri.org/PlaylistService/GetPlaylist"',
    Content      => <<EOF);
<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <SOAP-ENV:Body>
    <tem:GetPlaylist xmlns:tem="http://tempuri.org/" xmlns:itv="http://schemas.datacontract.org/2004/07/Itv.BB.Mercury.Common.Types" xmlns:com="http://schemas.itv.com/2009/05/Common">
      <tem:request>
        <itv:RequestGuid>FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF</itv:RequestGuid>
        <itv:Vodcrid>
          <com:Id>$id</com:Id>
          <com:Partition>itv.com</com:Partition>
        </itv:Vodcrid>
      </tem:request>
      <tem:userInfo>
        <itv:GeoLocationToken>
          <itv:Token/>
        </itv:GeoLocationToken>
        <itv:RevenueScienceValue>scc=true; svisit=1; sc4=Other</itv:RevenueScienceValue>
      </tem:userInfo>
      <tem:siteInfo>
        <itv:AdvertisingRestriction>None</itv:AdvertisingRestriction>
        <itv:AdvertisingSite>ITV</itv:AdvertisingSite>
        <itv:Area>ITVPLAYER.VIDEO</itv:Area>
        <itv:Platform>DotCom</itv:Platform>
        <itv:Site>ItvCom</itv:Site>
      </tem:siteInfo>
    </tem:GetPlaylist>
  </SOAP-ENV:Body>
</SOAP-ENV:Envelope>
EOF

  debug $browser->content;
  die "Unable to find <Video> in XML" unless $browser->content =~ m{<Video timecode[^>]+>(.*?)</Video>}s;
  my $video = $1;

  my(@formats);
  while ($video =~ m/(mp4:[^\]]+_[A-Z]+([0-9]{3,4})_(16[-x]9|4[-x]3).mp4)/gi)
  {
    push @formats, { video => $video, playpath => $1, resolution => $resolutions->{$3}->{$2}};
  }
  while ($video =~ m/(mp4:[^\]]+-([0-9]{3,4})kbps.mp4)/gi)
  {
    push @formats, { video => $video, playpath => $1, resolution => $resolutions->{"16x9"}->{$2}};
  }
  while ($video =~ m/(mp4:[^\]]+-([0-9]{3,4})kbps.\d+.mp4)/gi)
  {
    push @formats, { video => $video, playpath => $1, resolution => $resolutions->{"16x9"}->{$2}};
  }

  my $format = $prefs->quality->choose(@formats);

  $video = $format->{"video"};
  my $rtmp = decode_entities($video =~ /base="(rtmp[^"]+)/);
  my($playpath) = $format->{"playpath"};
  my($flv) = $playpath =~ m{/([^/]+)$};

  return {
    rtmp => $rtmp,
    playpath => $playpath,
    flv => $flv,
    swfhash($browser, "http://www.itv.com/mercury/Mercury_VideoPlayer.swf")
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Itv.pm
BEGIN { $INC{'FlashVideo/Site/Joemonster.pm'}++; }
# Author: paczesiowa@gmail.com
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
#
# This plugin works for videos from www.joemonster.org using 'Monster Player'
#
# Most (~70%) of them are single embedded youtube videos:
# http://www.joemonster.org/filmy/28773/Sposob_na_Euro_2012
# This plugin doesn't directly support them,
# so get_flash_videos fallbacks to youtube method, which works just fine.
# Pages with multiple youtube videos are also supported by youtube method,
# but only the first embedded video is downloaded:
# http://www.joemonster.org/filmy/4551/Terapia_masazem
#
# This plugin claims to support a page when it contains at least one video
# embedded with Monster Player.
# Pages with mixed providers, like this (Monster Player+youtube):
# http://www.joemonster.org/filmy/5496/Kolo_Smierci
# only downloads Monster Player movies, the rest is discarded,
# because I don't know how to provide links AND fallback to a different method.
#
# There are two versions of Monster Player:
# * old/fat
# http://www.joemonster.org/filmy/28784/Genialny_wystep_mlodego_iluzjonisty_w_Mam_talent (single video)
# http://www.joemonster.org/filmy/28693/Dave_Chappelle_w_San_Francisco_ (multi videos)
#
# * new/slim
# http://www.joemonster.org/filmy/28372/Wszyscy_kochamy_Polske_czesc_ (single video)
#
# Currently multiple videos are unsupported, only the first one is downloaded,
# I have no idea how to return multiple links
#
# About 5% of videos are embedded from external providers (different than youtube),
# they should work if get_flash_videos has appropriate method.

BEGIN { $INC{'URI/QueryParam.pm'}++; }
##{ /usr/local/libdata/perl5/site_perl/URI/QueryParam.pm
{
package URI::QueryParam;

use strict;

sub URI::_query::query_param {
    my $self = shift;
    my @old = $self->query_form;

    if (@_ == 0) {
	my %seen;
	my @keys;
	for (my $i = 0; $i < @old; $i += 2) {
	    push(@keys, $old[$i]) unless $seen{$old[$i]}++;
	}
	return @keys;
    }

    my $key = shift;
    my @i;

    for (my $i = 0; $i < @old; $i += 2) {
	push(@i, $i) if $old[$i] eq $key;
    }

    if (@_) {
	my @new = @old;
	my @new_i = @i;
	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
	while (@new_i > @vals) {
	    splice(@new, pop(@new_i), 2);
	}
	while (@vals > @new_i) {
	    my $i = @new_i ? $new_i[-1] + 2 : @new;
	    splice(@new, $i, 0, $key => pop(@vals));
	}
	for (@vals) {
	    $new[shift(@new_i)+1] = $_;
	}

	$self->query_form(\@new);
    }

    return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
}

sub URI::_query::query_param_append {
    my $self = shift;
    my $key = shift;
    $self->query_form($self->query_form, $key => \@_);  # XXX
    return;
}

sub URI::_query::query_param_delete {
    my $self = shift;
    my $key = shift;
    my @old = $self->query_form;
    my @vals;

    for (my $i = @old - 2; $i >= 0; $i -= 2) {
	next if $old[$i] ne $key;
	push(@vals, (splice(@old, $i, 2))[1]);
    }
    $self->query_form(\@old) if @vals;
    return wantarray ? reverse @vals : $vals[-1];
}

sub URI::_query::query_form_hash {
    my $self = shift;
    my @old = $self->query_form;
    if (@_) {
	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
    }
    my %hash;
    while (my($k, $v) = splice(@old, 0, 2)) {
	if (exists $hash{$k}) {
	    for ($hash{$k}) {
		$_ = [$_] unless ref($_) eq "ARRAY";
		push(@$_, $v);
	    }
	}
	else {
	    $hash{$k} = $v;
	}
    }
    return \%hash;
}

1;

}
##} /usr/local/libdata/perl5/site_perl/URI/QueryParam.pm
##{ blib/lib/FlashVideo/Site/Joemonster.pm
{
package FlashVideo::Site::Joemonster;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { URI::QueryParam->import(); } # (added by utils/combine-perl.pl)


my $new_monster_player_regex = "<\\s*embed\\s*src\\s*=\\s*\"\\s*(http:\\/\\/www\\.joemonster\\.org\\/flvplayer\\.swf\\?file=.*?)\\s*\"";

sub is_new_monster_player {
    my($self, $browser) = @_;
    return $browser->content =~ m/$new_monster_player_regex/;
}

sub get_new_monster_player_url {
    my($self, $browser) = @_;
    $browser->content =~ m/$new_monster_player_regex/;
    return URI->new($1)->query_param('file') or die "no file key in player link";
}

my $old_monster_player_regex = "<\\s*embed\\s*src\\s*=\\s*\"\\s*(http:\\/\\/www\\.joemonster\\.org\\/emb\\/.*?)\\s*\"";

sub is_old_monster_player {
    my($self, $browser) = @_;
    return $browser->content =~ m/$old_monster_player_regex/;
}


sub get_old_monster_player_url {
    my($self, $browser) = @_;
    $browser->content =~ m/$old_monster_player_regex/;
    my $embedded_url = $1;
    $browser->get($embedded_url);
    my $url = $browser->uri;
    return URI->new($url)->query_param('file') or die "no file key in player link";
}

sub can_handle {
    my($self, $browser, $url) = @_;
    return $self->is_new_monster_player($browser) || $self->is_old_monster_player($browser);
}

sub find_video {
    my($self, $browser, $url) = @_;
    my $real_url;

    if ($self->is_new_monster_player($browser)) {
	$real_url = $self->get_new_monster_player_url($browser);
    }
    else {
	$real_url = $self->get_old_monster_player_url($browser);
    }

    my $title;
    if ($browser->title =~ m/(.*) - Joe Monster/ ) {
	$title = $1;
    } else {
	$title = $browser->title;
    }

    return $real_url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Joemonster.pm
BEGIN { $INC{'FlashVideo/Site/Kanal5play.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Kanal5play.pm
{
package FlashVideo::Site::Kanal5play;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

my $widths = {
     "low" => 480,
     "medium" => 640, 
     "high" => 1024 };

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  my $has_amf_conn = eval { require AMF::Connection };
  if (!$has_amf_conn) {
    die "Must have AMF::Connection installed";
  }
  my $player_id = "811317479001";
  my $video_id = ($browser->content =~ /videoPlayer" value="(.*?)"/)[0];
  if ($video_id eq ''){die "Could not find video_id";}
  info "found video_id: $video_id";
  debug "$prefs->{quality}";
  my @dump = $self->amfgateway($browser, $player_id, $video_id,$prefs);

  my $width = 0;
  my $rtmp;
  my $playpath;
  my $new_width;

  foreach (@dump) {
    $new_width = int($_->{width});
    if(($new_width > $width) and (($widths->{$prefs->{quality}}) >= $new_width)){
        $width = int($_->{width});
        $rtmp = $_->{rtmp};
        $playpath = $_->{mp4};
    }
  };

  my @rtmpdump_commands;
  my $title = ($browser->content =~ /property="og:title" content="(.*?)"/)[0];
  my $flv_filename = title_to_filename($title, "flv");
  my $args = {
      rtmp => $rtmp,
      swfVfy => "http://admin.brightcove.com/viewer/us1.25.04.01.2011-05-24182704/connection/ExternalConnection_2.swf",
      playpath => $playpath,
      flv => $flv_filename
  };
  push @rtmpdump_commands, $args;
  return \@rtmpdump_commands;
}

sub amfgateway {
  my($self, $browser, $player_id, $videoId, $prefs) = @_;

  my $endpoint = 'http://c.brightcove.com/services/amfgateway';
  my $service = 'com.brightcove.templating.TemplatingFacade';
  my $method = 'getContentForTemplateInstance';
  my $client = new AMF::Connection( $endpoint );
  my $params = [
		$player_id,	# param 1 - playerId
		{
		 'fetchInfos' => [
				  {
				   'fetchLevelEnum' => '1',
				   'contentType' => 'VideoLineup',
				   'childLimit' => '100'
				  },
				  {
				   'fetchLevelEnum' => '3',
				   'contentType' => 'VideoLineupList',
				   'grandchildLimit' => '100',
				   'childLimit' => '100'
				  }
				 ],
		 'optimizeFeaturedContent' => 1,
		 'lineupRefId' => undef,
		 'lineupId' => undef,
		 'videoRefId' => undef,
		 'videoId' => $videoId, # param 2 - videoId
		 'featuredLineupFetchInfo' => {
					       'fetchLevelEnum' => '4',
					       'contentType' => 'VideoLineup',
					       'childLimit' => '100'
					      }
		}
	       ];

  my $response = $client->call( $service.'.'.$method, $params );
  my @dump;
  if ( $response->is_success ) {
    my $count = 0;
    for ($count = 0; $count < 3; $count++){
      my $defaultURL = $response->{data}[0]->{data}->{videoDTO}->{renditions}[$count]->{defaultURL};
      my $mp4 = reverse(((reverse($defaultURL)) =~ m/(.*?)&/)[0]);
      my $width = $response->{data}[0]->{data}->{videoDTO}->{renditions}[$count]->{frameWidth};
      my $rtmp = ($defaultURL =~ m/(.*?)&/)[0];
      @dump[$count] = { 'rtmp' => $rtmp,
			'width' => $width,
			'mp4' => $mp4
		      };
      
    }
  } else {
    die "Can not send remote request for $service.$method method with params on $endpoint using AMF".$client->getEncoding()." encoding.\n";
  };
  return @dump;
}
1;
}
##} blib/lib/FlashVideo/Site/Kanal5play.pm
BEGIN { $INC{'FlashVideo/Site/Kidswb.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/JSON.pm'}++; }
##{ blib/lib/FlashVideo/JSON.pm
{
package FlashVideo::JSON;

use strict;
use Exporter;use base 'Exporter';
our @EXPORT = qw(from_json);

my $number = qr{(?:-?\b(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\b)};
my $oneChar = qr{(?:[^\0-\x08\x0a-\x1f\"\\]|\\(?:["/\\bfnrt]|u[0-9A-Fa-f]{4}))};
my $string = qr{(?:"$oneChar*")};
my $jsonToken = qr{(?:false|true|null|[\{\}\[\]]|$number|$string)};
my $escapeSequence = qr{\\(?:([^u])|u(.{4}))};

my %escapes = (
  '\\' => '\\',
  '"' => '"',
  '/' => '/',
  'b' => "\b",
  'f' => "\f",
  'n' => "\xA",
  'r' => "\xD",
  't' => "\t"
);

sub from_json {
  my($in) = @_;

  my @tokens = $in =~ /$jsonToken/go;
  my $result = $tokens[0] eq '{' ? {} : [];
  shift @tokens if $tokens[0] =~ /^[\[\{]/;

  my $key; # key to use for next value
  my @stack = $result;
  for my $t(@tokens) {
    my $ft = substr $t, 0, 1;
    my $cont = $stack[0];

    if($ft eq '"') {
      my $s = substr $t, 1, length($t) - 2;
      $s =~ s/$escapeSequence/$1 ? $escapes{$1} : chr hex $2/geo;
      if(!defined $key) {
        if(ref $cont eq 'ARRAY') {
          $cont->[@$cont] = $s;
        } else {
          $key = $s;
          next; # need to save $key
        }
      } else {
        $cont->{$key} = $s;
      }
    } elsif($ft eq '[' || $ft eq '{') {
      unshift @stack,
        (ref $cont eq 'ARRAY' ? $cont->[@$cont] : $cont->{$key}) = $ft eq '[' ? [] : {};
    } elsif($ft eq ']' || $ft eq '}') {
      shift @stack;
    } else {
      (ref $cont eq 'ARRAY' ? $cont->[@$cont] : $cont->{$key}) =
          $ft eq 'f' ? 0 # false
        : $ft eq 'n' ? undef # null
        : $ft eq 't' ? 1 # true
        : $t; # sign or digit
    }
    undef $key;
  }

  return $result;
}

1;
}
##} blib/lib/FlashVideo/JSON.pm
##{ blib/lib/FlashVideo/Site/Kidswb.pm
{
package FlashVideo::Site::Kidswb;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_json = \&FlashVideo::JSON::from_json; }

sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;

  my $config_url = "http://staticswf.kidswb.com/franchise/digitalsmiths/wbkidsvideoplayer.xml";
  my $mediaKey;
  if ($browser->uri->as_string =~ /\/video#.*\/([^\/]*)$/) {
    $mediaKey = $1;
  } else {
    die "Couldn't find flashvars param in " . $browser->uri->as_string;
  }

  $browser->allow_redirects;
  $browser->get($config_url);
  if (!$browser->success) {
    die "Couldn't download config.xml $config_url: " . $browser->response->status_line;
  }

  my $xml = from_xml($browser);
  my $domain = $xml->{mfs}->{url};
  my $version = "v2";
  my $account = $xml->{mfs}->{account};
  my $partner = $xml->{mfs}->{partnerid};

  my $asset_url = "$domain/$version/$account/assets/$mediaKey/partner/$partner?format=json";
  $browser->get($asset_url);
  if (!$browser->success) {
    die "Couldn't download asset file $asset_url: " . $browser->response->status_line;
  }

  my $asset_data = from_json($browser->content);
  my $videos = $asset_data->{videos};

  my $title = title_to_filename($asset_data->{assetFields}->{seriesName} . " - " . $asset_data->{assetFields}->{title});

  my $video = $videos->{limelight700};

  my $rtmp = $video->{uri};

  return {
    flv => $title,
    rtmp => $rtmp,
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Kidswb.pm
BEGIN { $INC{'FlashVideo/Site/Last.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Last.pm
{
package FlashVideo::Site::Last;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my($artist, $id) = $embed_url =~ m{/([^/]+)/\+videos/(\d+)};
  my($title) = $browser->content =~ /<h1>([^<]+)/;

  die "No video ID found" unless $id;

  $browser->get("http://ext.last.fm/1.0/video/getplaylist.php?&vid=$id&artist=$artist");

  return $browser->content =~ /<location>([^<]+)/, title_to_filename($title);
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $url =~ /last\.fm/ && $url =~ m{\+video/\d{2,}};
}

1;
}
##} blib/lib/FlashVideo/Site/Last.pm
BEGIN { $INC{'FlashVideo/Site/Liveleak.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Liveleak.pm
{
package FlashVideo::Site::Liveleak;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $file_embed_tag;
  if ($browser->content =~ /file_embed_tag(?:%3D|=)(\w+)\W/) {
    $file_embed_tag = $1; 
  }
  else {
    die "Unable to get file_embed_tag";
  }

  $browser->get("http://www.liveleak.com/playlist_new.php?file_embed_tag=$file_embed_tag");

  if (!$browser->success) {
    die "Couldn't download LiveLeak playlist: " . $browser->response->status_line();
  }

  my $video_url;
  if ($browser->content =~ m'<location>(http://.*?)</location>') {
    $video_url = $1;
  }
  else {
    die "Unable to extract LiveLeak video URL";
  }

  if (my $redirected_url = $browser->head($video_url)->header('Location')) {
    $video_url = $redirected_url;
  }

  $browser->back();

  my $title;
  if ($browser->content =~ m'<h4 id="s_hd">(.*?)</h4>') {
    $title = $1;
  }
  else {
    $title = extract_title($browser);
  }

  return $video_url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Liveleak.pm
BEGIN { $INC{'FlashVideo/Site/Megaporn.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Site/Megavideo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Megavideo.pm
{
package FlashVideo::Site::Megavideo;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

my %sites = (
  Megavideo => "megavideo.com",
  Megaporn  => "megaporn.com/video",
);

sub find_video {
  my ($self, $browser) = @_;

  my $site = $sites{($self =~ /::([^:]+)$/)[0]};

  my $v;
  if ($browser->content =~ /\.v\s*=\s*['"]([^"']+)/
      || $browser->uri =~ /v=([^&]+)/
      || $browser->response->header("Location") =~ /v=([^&]+)/) {
    $v = $1;
  } else {
    die "Couldn't extract video ID from page";
  }

  my $xml = "http://www.$site/xml/videolink.php?v=$v";
  $browser->get($xml);

  die "Unable to get video infomation" unless $browser->response->is_success;

  my $k1 = ($browser->content =~ /k1="(\d+)/)[0];
  my $k2 = ($browser->content =~ /k2="(\d+)/)[0];
  my $un = ($browser->content =~ /un="([^"]+)/)[0];
  my $s  = ($browser->content =~ /\ss="(\d+)/)[0];

  my $title = uri_unescape(($browser->content =~ /title="([^"]+)/)[0]);
  my $filename = title_to_filename($title);

  my $url = "http://www$s.$site/files/" . _decrypt($un, $k1, $k2) . "/";

  return $url, $filename;
}

sub _decrypt {
  my($un, $k1, $k2) = @_;

  my @c = split //, join "",
    map { substr unpack("B8", pack "h", $_), 4 } split //, $un;

  my @iv;
  my $i = 0;
  while($i < 384) {
    $k1 = ($k1 * 11 + 77213) % 81371;
    $k2 = ($k2 * 17 + 92717) % 192811;
    $iv[$i] = ($k1 + $k2) % 128;
    $i++;
  }

  $i = 256;
  while($i >= 0) {
    my $a = $iv[$i];
    my $b = $i-- % 128;

    ($c[$a], $c[$b]) = ($c[$b], $c[$a]);
  }

  $i = 0;
  while($i < 128) {
    $c[$i] ^= $iv[$i + 256] & 1;
    $i++;
  }

  $i = 0;
  my $c = "";
  while($i < @c) {
    $c .= unpack "h", pack "B8", "0000" . join "", @c[$i .. ($i + 4)];
    $i += 4;
  }

  return $c;
}

1;
}
##} blib/lib/FlashVideo/Site/Megavideo.pm
##{ blib/lib/FlashVideo/Site/Megaporn.pm
{
package FlashVideo::Site::Megaporn;

use strict;
BEGIN { FlashVideo::Site::Megavideo->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Megavideo';

1;
}
##} blib/lib/FlashVideo/Site/Megaporn.pm
BEGIN { $INC{'FlashVideo/Site/Metacafe.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Metacafe.pm
{
package FlashVideo::Site::Metacafe;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  if ($browser->response->header("Location") =~ /Openx/) {
    my $filter = "http://www.metacafe.com/f/index.php?inputType=filter&controllerGroup=user&filters=0&prevURL=" . $browser->uri->path;
    debug "Disabling family filter by getting $filter";

    $browser->allow_redirects;
    $browser->get($filter);
  }

  my $url;
  if ($browser->content =~ m'mediaURL=(http.+?)&') {
    $url = uri_unescape($1);
  } else {
    die "Couldn't find mediaURL parameter.";
  }

  if ($browser->content =~ m'gdaKey=(.+?)&') {
    $url .= "?__gda__=" . uri_unescape($1);
  } else {
  }

  my $filename = title_to_filename(extract_title($browser));

  return ($url, $filename);
}

1;
}
##} blib/lib/FlashVideo/Site/Metacafe.pm
BEGIN { $INC{'FlashVideo/Site/Mitworld.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Mitworld.pm
{
package FlashVideo::Site::Mitworld;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my($title) = $browser->content =~ m{id="video-meta">\s*<h2>(.*?)</h2>}s;
  if(!$title) {
    $title = extract_title($browser);
    $title =~ s/\|.*//;
  }

  my($host) = $browser->content =~ m{host:\s*"(.*?)"};
  my($flv) = $browser->content =~ m{flv:\s*"(.*?)"};

  return {
    rtmp => "rtmp://$host/ondemand/ampsflash/$flv?_fcs_vhost=$host",
    flv  => title_to_filename($title)
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Mitworld.pm
BEGIN { $INC{'FlashVideo/Site/Mofosex.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Mofosex.pm
{
package FlashVideo::Site::Mofosex;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $filename = title_to_filename($browser->content =~ /<title>(.*?)<\//);
  
  $browser->allow_redirects;

  my $playlist = ($browser->content =~ /videoPath=(.+?)%26page/)[0];
  $browser->get($playlist);
   
  my $url = ($browser->content =~ /<url>(.+?)<\/url>/)[0];
    
  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Mofosex.pm
BEGIN { $INC{'FlashVideo/Site/Msn.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Msn.pm
{
package FlashVideo::Site::Msn;

use strict;
BEGIN { FlashVideo::Site::Bing->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Bing';

1;
}
##} blib/lib/FlashVideo/Site/Msn.pm
BEGIN { $INC{'FlashVideo/Site/Msnbc.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Msnbc.pm
{
package FlashVideo::Site::Msnbc;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  $browser->allow_redirects;

  my $id;
  my $location;
  if ($embed_url =~ /(.+\/id\/)([0-9]+)\/vp\/.+#([0-9]+)/) {
    $location = $1;
    $id = $3;
  } elsif ($embed_url =~ /(.+\/id\/)([0-9]+)\/vp\/([0-9]+)/) {
    $location = $1;
    $id = $3;
  } elsif ($embed_url =~ /(.+\/id\/)([0-9]+)\/.+#([0-9]+)/) {
    $location = $1;
    $id = $3;
  } elsif ($embed_url =~ /(.+\/id\/)([0-9]+)\/#([0-9]+)/) {
    $location = $1;
    $id = $3;
  }
  die "Unable to find location and videoid" unless $location and $id;

  $browser->get($location . $id . '/displaymode/1219/'); # http://today.msnbc.msn.com/id/$id/displaymode/1219/

  my $xml = from_xml($browser->content);

  my $title;
  my $url;
  if ($xml->{video}->{docid} eq $id) {
    $title = $xml->{video}->{title};
    foreach my $media (@{$xml->{video}->{media}}) {
      if ($media->{type} =~ /flashVideo$/i) {
        $url = $media->{content};
        last; #prefer http get over rtmp
      } elsif ($media->{type} =~ /flashVideoStream$/i) {
        $browser->get($media->{content});
        if ($browser->content =~ /<FlashLink>(.+)<\/FlashLink>/i) {
          $url = $1; #rtmp
        }
      }
    }
  }
  die "Unable to extract video url" unless $url;

  if ($url =~ /^rtmp/i) {
    return {
      rtmp => $url,
      flv => title_to_filename($title)
    };
  }

  return $url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Msnbc.pm
BEGIN { $INC{'FlashVideo/Site/Mtvnservices.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Mtvnservices.pm
{
package FlashVideo::Site::Mtvnservices;


use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *swfhash = \&FlashVideo::Utils::swfhash; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

my $MTVN_URL = qr{http://\w+.mtvnservices.com/(?:\w+/)?mgid:[a-z0-9:.\-_]+};
my $MTVN_ALT_URL = qr{mgid:[a-z0-9:.\-_]+};

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $page_url = $browser->uri->as_string;

  if($embed_url !~ $MTVN_URL) {
    if($browser->content =~ m!($MTVN_URL)!) {
      $embed_url = $1;
    } elsif($browser->content =~ m!($MTVN_ALT_URL)!) {
      $embed_url = "http://media.mtvnservices.com/$1";
    } else {
      die "Unable to find embedding URL";
    }
  }

  $browser->get($embed_url);
  die "Unable to get embed URL" unless $browser->response->code =~ /^30\d$/;

  my %param;
  my $location = $browser->response->header("Location");
  for(split /&/, (split /\?/, $location)[-1]) {
    my($n, $v) = split /=/;
    $param{$n} = uri_unescape($v);
  }

  die "No config_url/id found\n" unless $param{CONFIG_URL};

  $browser->get($param{CONFIG_URL});
  my $xml = from_xml_urlfix($browser);

  if($xml->{player}->{feed} && !ref $xml->{player}->{feed}) {
    my $feed = uri_unescape($xml->{player}->{feed});
    $feed =~ s/\{([^}]+)\}/$param{$1}/g;

    $browser->get($feed);

    return $self->handle_feed($browser->content, $browser, $page_url, $param{uri});
  } elsif(ref $xml->{player}->{feed}->{rss}) {
    return $self->handle_feed($xml->{player}->{feed}->{rss}, $browser, $page_url, $param{uri});
  } else {
    die "Unable to find feed\n";
  }
}

sub handle_full_episode {
  my($self, $items, $filename, $browser, $page_url, $uri) = @_;

  my @rtmpdump_commands;

  debug "Handling full episode";

  foreach (@$items) {
    my $item = $_;

    my $affect_counters = (grep { $_->{scheme} eq "urn:mtvn:affect_counters" } @{$item->{"media:group"}->{"media:category"}})[0];
    my $iscommercial = 0;
    if (defined $affect_counters && $affect_counters->{content} eq 'false') {
      $iscommercial = 1;
    }

    if (!$iscommercial) {
      my $mediagen_url = $item->{"media:group"}->{"media:content"}->{url};
      die "Unable to find mediagen URL\n" unless $mediagen_url;

      $browser->get($mediagen_url);
      my $xml = from_xml_urlfix($browser);

      my $rendition = (grep { $_->{rendition} } ref $xml->{video}->{item} eq 'ARRAY'
        ?  @{$xml->{video}->{item}} : $xml->{video}->{item})[0]->{rendition};
      $rendition = [ $rendition ] unless ref $rendition eq 'ARRAY';

      my $url = (sort { $b->{bitrate} <=> $a->{bitrate} } @$rendition)[0]->{src};

      my $mediagen_id;
      if($mediagen_url =~ /mediaGenEntertainment\.jhtml\?uri=([^&]+).*$/){
        $mediagen_id = $1;
      } else {
        $mediagen_id = $mediagen_url;
      }

      $browser->allow_redirects;

      push @rtmpdump_commands, {
        flv => title_to_filename($item->{"media:group"}->{"media:title"}),
        rtmp => $url,
        pageUrl => $item->{"link"},
        swfhash($browser, "http://media.mtvnservices.com/" . $mediagen_id)
      };
    }
  }

  return \@rtmpdump_commands;
}

sub handle_clip {
  my($self, $items, $filename, $browser, $page_url, $uri) = @_;

  debug "Handling clip";

  my $item = ref $items eq 'ARRAY' ?
    (grep { $_->{guid}->{content} eq $uri } @$items)[0] :
    $items;

  my $mediagen_url = $item->{"media:group"}->{"media:content"}->{url};
  die "Unable to find mediagen URL\n" unless $mediagen_url;

  $browser->get($mediagen_url);
  my $xml = from_xml_urlfix($browser);

  my $rendition = (grep { $_->{rendition} } ref $xml->{video}->{item} eq 'ARRAY'
    ?  @{$xml->{video}->{item}} : $xml->{video}->{item})[0]->{rendition};
  $rendition = [ $rendition ] unless ref $rendition eq 'ARRAY';

  my $url = (sort { $b->{bitrate} <=> $a->{bitrate} } @$rendition)[0]->{src};

  my $mediagen_id;
  if($mediagen_url =~ /mediaGenEntertainment\.jhtml\?uri=([^&]+).*$/){
    $mediagen_id = $1;
  } else {
    $mediagen_id = $mediagen_url;
  }

  $browser->allow_redirects;

  if($url =~ /^rtmpe?:/) {
    return {
      flv => $filename,
      rtmp => $url,
      pageUrl => $page_url,
      swfhash($browser, "http://media.mtvnservices.com/" . $mediagen_id)
    };
  } else {
    return $url, $filename;
  }
}

sub handle_feed {
  my($self, $feed, $browser, $page_url, $uri) = @_;

  my $xml = ref $feed ? $feed : from_xml_urlfix($feed);

  my $filename = title_to_filename($xml->{channel}->{title});

  my $items = $xml->{channel}->{item};
  my $categories = ref $items eq 'ARRAY' ? @$items[0]->{"media:group"}->{"media:category"} : $items->{"media:group"}->{"media:category"};

  if (ref $categories eq 'ARRAY' && (
      (grep { $_->{scheme} eq "urn:mtvn:display:seo" } @$categories)[0]->{content} eq "" ||
      (grep { $_->{scheme} eq "urn:mtvn:content_type" } @$categories)[0]->{content} eq "Full Episode" ||
      (grep { $_->{scheme} eq "urn:mtvn:content_type" } @$categories)[0]->{content} eq "full_episode_segment")) {
    return $self->handle_full_episode($items, $filename, $browser, $page_url, $uri);
  } else {
    return $self->handle_clip($items, $filename, $browser, $page_url, $uri);
  }
}

sub can_handle {
  my($self, $browser) = @_;

  return $browser->content =~ /mtvnservices\.com/i;
}


sub from_xml_urlfix {
  my($xmltext) = @_;
  $xmltext =~ s/&(?!amp;)/&amp;/g;  # too lax?
  return from_xml($xmltext);
}

1;
}
##} blib/lib/FlashVideo/Site/Mtvnservices.pm
BEGIN { $INC{'FlashVideo/Site/Muzu.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Muzu.pm
{
package FlashVideo::Site::Muzu;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use HTML::Entities;

sub find_video {
  my ($self, $browser) = @_;

  if ($browser->response->code == 302) {
    $browser->allow_redirects;
    $browser->get($browser->response->header('Location'))
  }

  $browser->content =~ /id="trackHeading">(.*?)</;
  my $title = $1;

  if (!$title) {
    $browser->content =~ /id="videosPageMainTitleH1">(.*?)</s;
    $title = $1;
  }
  
  my $filename = title_to_filename(decode_entities($title));

  my $flashvars = ($browser->content =~ m'flashvars:(?:\s+getPlayerData\(\)\s+\+\s+)?"([^"]+)')[0];
  die "Unable to extract flashvars" unless $flashvars;

  my %map = (
    networkId    => "id",
    assetId      => "assetId",
    vidId        => "assetId",
    startChannel => "playlistId",
  );

  my $playAsset = "http://www.muzu.tv/player/playAsset/?";
  for(split /&/, $flashvars) {
    my($n, $v) = split /=/;
    $playAsset .= "$map{$n}=$v&" if exists $map{$n};
  }

  $browser->get($playAsset);
  die "Unable to get $playAsset" if $browser->response->is_error;

  my $url = ($browser->content =~ /src="([^"]+)/)[0];
  $url = decode_entities($url);
  die "Unable to find video URL" unless $url;

  if($url =~ /^rtmp:/) {
    my($playpath) = $url =~ m{/([^/]+)$};

    return {
      flv => $filename,
      rtmp => $url,
      playpath => $playpath,
      $url =~ /live/ ? (live => 1) : ()
    };

  } else {
    return $url, $filename;
  }
}

1;
}
##} blib/lib/FlashVideo/Site/Muzu.pm
BEGIN { $INC{'FlashVideo/Site/Mylifetime.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Mylifetime.pm
{
package FlashVideo::Site::Mylifetime;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { FlashVideo::Site::Brightcove->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Brightcove';

my $JS_RE = qr/displayFlash\(/;

sub find_video {
  my($self, $browser, $embed_url) = @_;

  my($player_id, $video_id) = $browser->content =~ /$JS_RE\s*"(\d+)",\s*"(\d+)"/;
  die "Unable to extract video ids" unless $video_id;

  return $self->amfgateway($browser, $player_id, { videoId => $video_id });
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->content =~ $JS_RE; 
}

1;
}
##} blib/lib/FlashVideo/Site/Mylifetime.pm
BEGIN { $INC{'FlashVideo/Site/Myvideo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Myvideo.pm
{
package FlashVideo::Site::Myvideo;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_url;

  if ($browser->content =~ m{<link rel='image_src' href='(http://[^'"]+)'}) {
    $video_url = $1;
  }

  $video_url =~ s|thumbs/||;
  $video_url =~ s|_\d\.jpg$|.flv|;

  my $title = (split /\//, $browser->uri->as_string)[-1];

  return $video_url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Myvideo.pm
BEGIN { $INC{'FlashVideo/Site/Nbc.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Nbc.pm
{
package FlashVideo::Site::Nbc;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
use MIME::Base64;

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $has_amf_packet = eval { require Data::AMF::Packet };
  if (!$has_amf_packet) {
    die "Must have Data::AMF::Packet installed to download Nbc videos";
  }


  my $video_id;
  if ($browser->uri->as_string =~ /\/([0-9]+)\//) {
    $video_id = $1;
  }

  my $packet = Data::AMF::Packet->deserialize(decode_base64("AAAAAAABABZnZXRDbGlwSW5mby5nZXRDbGlwQWxsAAIvMQAAAB8KAAAABAIABzEyMjc2MTECAAJVUwIAAzYzMgIAAi0xCg=="));

  $packet->messages->[0]->{value}->[0] = $video_id;

  if($self->debug) {
    require Data::Dumper;
    debug Data::Dumper::Dumper($packet);
  }

  my $data = $packet->serialize;

  $browser->post(
    "http://video.nbcuni.com/amfphp/gateway.php",
    Content_Type => "application/x-amf",
    Content => $data
  );

  die "Failed to post to Nbc AMF gateway"
    unless $browser->response->is_success;

  debug $browser->content;


  my($clipurl) = $browser->content =~ /clipurl.{0,5}(nbc[^\0]+)/;

  my($title) = $browser->content =~ /headline.{1,3}([^\0]+)/;

  debug $clipurl;
  debug $title;

  $browser->get("http://video.nbcuni.com/$clipurl");
  my $xml = from_xml($browser);
  my $video_path = $xml->{body}->{switch}->{ref}->{src};

  $browser->get("http://videoservices.nbcuni.com/player/config?configId=17010&clear=true"); # I don't know what configId means but it seems to be generic
  my $xml = from_xml($browser);
  my $app = $xml->{akamaiAppName};
  my $host = $xml->{akamaiHostName};

  $browser->get("http://$host/fcs/ident");
  my $xml = from_xml($browser);
  my $ip = $xml->{ip};
  my $port = "1935";

  my $rtmpurl = "rtmp://$ip:$port/$app/$video_path";

  return {
    rtmp => $rtmpurl,
    swfUrl => "http://www.nbc.com/[[IMPORT]]/video.nbcuni.com/outlet/extensions/inext_video_player/video_player_extension.swf?4.5.3",
    tcUrl => "rtmp://$ip:$port/$app?_fcs_vhost=$host", 
    flv => title_to_filename($title)
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Nbc.pm
BEGIN { $INC{'FlashVideo/Site/Nfb.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
# Except the CCR bits, thanks to Fogerty for those.
##{ blib/lib/FlashVideo/Site/Nfb.pm
{
package FlashVideo::Site::Nfb;


use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use MIME::Base64;

sub find_video {
  my ($self, $browser) = @_;

  my($mid) = $browser->content =~ /mID=(\w+)/;

  if (!eval { require Data::AMF::Packet; }) {
    die "Must have Data::AMF installed to download NFB videos";
  }

  my $packet = decode_base64(<<EOF);
AAAAAAADABFnZXRfbW92aWVfcGFja2FnZQACLzEAAAAiCgAAAAMCAAVBREFBUwIACElET0JKMjYw
AgAHZGVmYXVsdAAJc2V0X3N0YXRzAAIvMgAAAEkKAAAAAwIAC3Rlc3RfZmxpZ2h0AgAISURPQkoy
NjACAChpbmZvczogZmxhc2hQbGF5ZXJWZXJzaW9uPUxOWCAxMCwwLDMyLDE4AAlzZXRfc3RhdHMA
Ai8zAAAASQoAAAADAgALdGVzdF9mbGlnaHQCAAhJRE9CSjI2MAIAKGluZm9zIDpzY3JlZW5SZXNv
bHV0aW9uPTEwMjQsNzY4LCBkcGk9OTY=
EOF

  my $data = Data::AMF::Packet->new->deserialize($packet);
   
  $data->messages->[0]->{value}->[1] = $data->messages->[1]->{value}->[1] = $mid;

  $data = $data->serialize;

  $browser->post(
    "http://www.nfb.ca/gwplayer/",
    Content_Type => "application/x-amf",
    Content => $data,
  );

  if (!$browser->success) {
    die "Posting AMF to NFB failed: " . $browser->response->status_line();
  }

  $data = $browser->content;

 
  my($title) = $data =~ m'title.{3}([^\0]+)';


  my @rtmp_urls = sort { _get_quality_from_url($b) <=> _get_quality_from_url($a) }
                  ($data =~ m'(rtmp://.*?)\0'g);

  if (!@rtmp_urls) {
    die "Didn't find any rtmp URLs in the packet, our hacky 'parsing' " .
        "code has probably broken";
  }

  my $rtmp_url = $rtmp_urls[0];
  my($host, $app, $playpath) = $rtmp_url =~ m'rtmp://([^/]+)/(\w+)(/[^?]+)';

  if($host eq 'flash.onf.ca') {
    $playpath =~ s{^(/[^/]+)/}{};
    $app .= $1;
    $playpath =~ s{\.\w+$}{};
  } else {
    $playpath = "mp4:$playpath";
  }

  return {
    flv => title_to_filename($title),
    rtmp => $rtmp_url,
    app => $app,
    playpath => $playpath
  };
}

sub _get_quality_from_url {
  my($url) = @_;

  if ($url =~ m'/streams/[A-Z](\d+)([A-Z])') {
    my ($size, $units) = ($1, $2);

    $size *= 1024 if $units eq 'M';

    return $size;
  }
}

1;
}
##} blib/lib/FlashVideo/Site/Nfb.pm
BEGIN { $INC{'FlashVideo/Site/Nick.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Nick.pm
{
package FlashVideo::Site::Nick;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *swfhash = \&FlashVideo::Utils::swfhash; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;


  my $page_url = $browser->uri->as_string;

  my $title;
  if($browser->content =~ /<span content=["']([\w \.:]+)["'] property=["']media:title["']\/>/) {
    $title = $1;
  } else {
    $title = "nothing";
  }

  my $cmsId;
  if($browser->content =~ /KIDS\.add\("cmsId", "(\d+)"\);/) {
    $cmsId = $1;
  } else {
    die "Couldn't get the cmsId.";
  }

  my $site;
  if($browser->content =~ /KIDS\.add\(["']site["'], ["']([\w\.]+)["']\);/) {
    $site = lc($1);
  } else {
    die "Couldn't get the site.";
  }

  my $type;
  if($browser->content =~ /KIDS\.add\(["']type["'], ["']([a-z]+)["']\);/) {
    $type = $1;
  } else {
    $type = "video";
  }

  my $uri = "mgid:cms:$type:$site:$cmsId";

  $browser->get("http://www.nick.com/dynamo/video/data/mediaGen.jhtml?mgid=$uri");
  my $xml = from_xml($browser->content);
  my $rtmp_url = $xml->{video}->{item}[0]->{rendition}[0]->{src};

  return {
    rtmp => $rtmp_url,
    flv => title_to_filename($title),
    pageUrl => $page_url,
    swfhash($browser, "http://media.nick.com/" . $uri)
  };
}

sub can_handle {
  my($self, $browser) = @_;
  return $browser->content =~ /<script src=["']http:\/\/media.nick.com\/player\/scripts\/mtvn_player_control\.1\.0\.1\.js["']/;
}

1;
}
##} blib/lib/FlashVideo/Site/Nick.pm
BEGIN { $INC{'FlashVideo/Site/Nicovideo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Nicovideo.pm
{
package FlashVideo::Site::Nicovideo;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;
  my $id = ($embed_url =~ /([ns]m\d+)/)[0];
  die "No ID found\n" unless $id;

  my $base = "http://ext.nicovideo.jp/thumb_watch/$id";

  if($embed_url !~ /ext\.nicovideo\.jp\/thumb_watch/) {
    $embed_url = "$base?w=472&h=374&n=1";
  }

  $browser->get($embed_url);
  my $playkey = ($browser->content =~ /thumbPlayKey: '([^']+)/)[0];
  die "No playkey found\n" unless $playkey;

  my $title = ($browser->content =~ /title: '([^']+)'/)[0];
  $title =~ s/\\u([a-f0-9]{1,5})/chr hex $1/eg;

  $browser->get($base . "/$playkey");
  my $url = uri_unescape(($browser->content =~ /url=([^&]+)/)[0]);

  return $url, title_to_filename($title, $id =~ /^nm/ ? "swf" : "flv");
}

1;
}
##} blib/lib/FlashVideo/Site/Nicovideo.pm
BEGIN { $INC{'FlashVideo/Site/Pbs.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Pbs.pm
{
package FlashVideo::Site::Pbs;

use strict;
use warnings;

BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
use MIME::Base64 qw(decode_base64);


sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  die "Must have Crypt::Rijndael installed to download from PBS"
    unless eval { require Crypt::Rijndael };

  my ($media_id) = $browser->uri->as_string =~ m[
    ^http://video\.pbs\.org/video/(\d+)
  ]x;
  unless (defined $media_id) {
    ($media_id) = $browser->content =~ m[
      http://video\.pbs\.org/widget/partnerplayer/(\d+)
    ]x;
  }
  unless (defined $media_id) {
    ($media_id) = $browser->content =~ m[
      /embed-player[^"]+\bepisodemediaid=(\d+)
    ]x;
  }
  unless (defined $media_id) {
    ($media_id) = $browser->content =~ m[var videoUrl = "([^"]+)"];
  }
  unless (defined $media_id) {
    my ($pap_id, $youtube_id) = $browser->content =~ m[
      \bDetectFlashDecision\ \('([^']+)',\ '([^']+)'\);
    ]x;
    if ($youtube_id) {
      debug "Youtube ID found, delegating to Youtube plugin\n";
      my $url = "http://www.youtube.com/v/$youtube_id";
      require FlashVideo::Site::Youtube;
      return FlashVideo::Site::Youtube->find_video($browser, $url, $prefs);
    }
  }
  die "Couldn't find media_id\n" unless defined $media_id;
  debug "media_id: $media_id\n";

  $browser->get("http://video.pbs.org/videoPlayerInfo/$media_id");

  my $xml = $browser->content;
  $xml =~ s/&/&amp;/g;
  my $href = from_xml($xml);
  my $file = $href->{videoInfo}->{title};
  my $release_url = $href->{releaseURL};

  unless ($release_url =~ m[^https?://]) {
    debug "encrypted release url: $release_url\n";
    my ($type, $iv, $ciphertext) = split '\$', $release_url, 3;
    $release_url = undef;

    my $key = 'RPz~i4p*FQmx>t76';

    my $cipher = Crypt::Rijndael->new($key, Crypt::Rijndael->MODE_CBC);
    $iv = pack 'H*', $iv if 32 == length $iv;
    $cipher->set_iv($iv);

    $release_url = $cipher->decrypt(decode_base64($ciphertext));
    $release_url =~ s/\s+$//;
  }
  debug "unencrypted release url: $release_url\n";

  $browser->get($release_url);

  my $rtmp_url = $browser->res->header('location')
    || from_xml($browser->content)->{choice}{url}
    || die "Couldn't find stream url\n";
  $rtmp_url =~ s/<break>//;

  if(!$file) {
    ($file) = $rtmp_url =~ m{([^/\?]+)$};
  }

  return {
    rtmp    => $rtmp_url,
    pageUrl => $embed_url,
    swfUrl  => 'http://www-tc.pbs.org/video/media/swf/PBSPlayer.swf?18809',
    flv     => title_to_filename($file),
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Pbs.pm
BEGIN { $INC{'FlashVideo/Site/Redbull.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Redbull.pm
{
package FlashVideo::Site::Redbull;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI->import(); } # (added by utils/combine-perl.pl)
use HTML::Entities;

sub find_video {
  my ($self, $browser, $page_url) = @_;

  my $video_info_url;
  my $host = $browser->uri->host; 

  if ( ($browser->content =~ /data_url:\s+'([^']+)'/) or
       ($browser->content =~ m{displayVideoPlayer\('([^']+)'\)})) {
    $video_info_url = $1;

    $video_info_url = "http://$host$video_info_url";
  }

  if (!$video_info_url) {
    die "Couldn't find video info URL";
  }

  $browser->get($video_info_url);

  if ($browser->response->is_redirect) {
    $browser->get($browser->response->header('Location'));
  }

  if (!$browser->success) {
    die "Couldn't download Red Bull video info XML: " .
      $browser->response->status_line;
  }
  
  my $xml = $browser->content;
  $xml =~ s/&amp;//g;
  $xml = decode_entities($xml);

  my $video_info = from_xml($xml);

  my $file_type = "flv";
  
  if ($video_info->{high_video_url} =~ /\.mp4$/) {
    $file_type = "mp4";
  }

  return {
    flv  => title_to_filename($video_info->{title}, $file_type),
    rtmp => $video_info->{high_video_url}, 
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Redbull.pm
BEGIN { $INC{'FlashVideo/Site/Redtube.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Redtube.pm
{
package FlashVideo::Site::Redtube;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my($self, $browser, $embed_url) = @_;

  my($title) = $browser->content =~ /<h1 class="videoTitle">([^<]+)</;

  my($url) = $browser->content =~ /hashlink=([^&"]+)/;
  $url = uri_unescape($url);

  $browser->allow_redirects;
  return $url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Redtube.pm
BEGIN { $INC{'FlashVideo/Site/Ringtv.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Ringtv.pm
{
package FlashVideo::Site::Ringtv;

use strict;
BEGIN { FlashVideo::Site::Grindtv->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Grindtv';

1;
}
##} blib/lib/FlashVideo/Site/Ringtv.pm
BEGIN { $INC{'FlashVideo/Site/Sapo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Sapo.pm
{
package FlashVideo::Site::Sapo;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my ($video_url, $type);
  
  if ($browser->content =~ m{flvplayer-sapo\.swf\?file=(http://[^&"]+)}) {
    $video_url = $1;

    if ($video_url =~ m{/mov}) {
      $type = "mp4";
    }
  }
  else {
    die "Couldn't extract Sapo video URL";
  }

  (my $title = extract_title($browser)) =~ s/ - SAPO V\x{ed}deos//;

  my $filename = title_to_filename($title, $type);

  $browser->allow_redirects(1);

  return $video_url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Sapo.pm
BEGIN { $INC{'FlashVideo/Site/Sbs.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Sbs.pm
{
package FlashVideo::Site::Sbs;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
use File::Basename;
use HTML::Entities;
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  my $smil;
  my $baseurl;

  my($id) = $browser->content =~ /firstVidId = '([^']*)';/;
  ($smil) = decode_entities($browser->content =~ /player\.releaseUrl = "([^"]*)";/);

  if( $id ){

    ($baseurl) = $browser->content =~ m{so\.addVariable\("nielsenLaunchURL", *"([^"]*)"\);}s ;
    my($menu) = $browser->content =~ m{loadVideo\('([^']*)', '', [^\)]\);}s ;
    if( !$menu ){ $menu = $baseurl . '/video/menu/inline/id/' . $id; }
    else { $menu = 'http://www.sbs.com.au' . $menu; }
    $menu =~ s/' *\+ *firstVidId *\+ *'/$id/g;

    die "No menu URL found" unless $menu;

    $browser->get($menu);

    ($smil) = $browser->content =~ m{<video *name="[^"]*" *id="[^"]*" *src="([^"]*)">}s ;
  }

  die "no smil" unless $smil;

  $browser->get($smil);

  ($baseurl) = decode_entities($browser->content =~ m'<meta base="([^"]*)"/>'s);

  my @tmp = $browser->content =~ m'<video src="([^"]*)" system-bitrate="([^"]*)"/>'gs;
  my %tmp = reverse @tmp;
  my $filename;
  my $q = $prefs->{quality};
  if( grep {$_ eq $q || $_ == $q || $_ == ($q * 100000)} keys(%tmp) ){
    $filename = decode_entities($tmp{$q});
    if(!$filename){
      my @bitrates = grep {$_ == $q || $_ == ($q * 100000)} keys(%tmp);
      $filename = decode_entities($tmp{$bitrates[0]});
    }
  } else {
    my @filenames = ();
    foreach (sort { $a <=> $b } keys(%tmp) )
      { push @filenames, $tmp{$_}; }
    my $cnt = @filenames;
    my $num = {high => int($cnt/3)*2, medium => int($cnt/3)*1, low => int($cnt/3)*0}->{$q};
    $filename = decode_entities($filenames[$num]);
  }

  die "no filenames" unless $filename;

  if( $baseurl =~ /^rtmp:/ ){
    my($flvname) = $filename =~ m'[^/]*/(.*)'s;
    return {
      rtmp => $baseurl,
      playpath => $filename,
      flv => $flvname,
      swfUrl => 'http://www.sbs.com.au/vod/theplatform/core/4_4_3/swf/flvPlayer.swf',
    };
  } elsif ($baseurl) {
    my $url = $baseurl . $filename;
    return $url, $filename;
  } else {
    return $filename, File::Basename::basename($filename);
  }
}

1;
}
##} blib/lib/FlashVideo/Site/Sbs.pm
BEGIN { $INC{'FlashVideo/Site/Scivee.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Scivee.pm
{
package FlashVideo::Site::Scivee; # horrible casing :(


use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *extract_info = \&FlashVideo::Utils::extract_info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use HTML::Entities;
sub find_video {

  my ($self, $browser) = @_;
  
  my $title;
  if ($browser->content =~ /title\>([^\|]+)/) {
    $title = $1;
  }
  else {
    $title = extract_info($browser)->{title};
  }
  my $filename = title_to_filename($title);
  my $vid;
  if ($browser->content =~ /\/ratings\/(\d+)/) {
    $vid = $1;
  }
  elsif ($browser->content =~ /flashvars="id=(\d+)/) {
    $vid = $1;
  }
  else {
    die "Could not find video!";
  }
  my $url = "http://www.scivee.tv/asset/video/$vid";

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Scivee.pm
BEGIN { $INC{'FlashVideo/Site/Seesaw.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Seesaw.pm
{
package FlashVideo::Site::Seesaw;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *json_unescape = \&FlashVideo::Utils::json_unescape; *convert_sami_subtitles_to_srt = \&FlashVideo::Utils::convert_sami_subtitles_to_srt; }
use HTML::Entities qw(decode_entities);
BEGIN { URI::Escape->import( qw(uri_escape)); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_escape = \&URI::Escape::uri_escape; }

my @res = (
  { name => "lowResUrl",  resolution => [ 512, 288 ] },
  { name => "stdResUrl",  resolution => [ 672, 378 ] },
  { name => "highResUrl", resolution => [ 1024, 576 ] }
);

sub find_video {
  my ($self, $browser, $page_url, $prefs) = @_;

  my $player_info = ($browser->content =~ m{(/videoplayerinfo/\d+[^"]+)"})[0];

  (my $content = $browser->content) =~ s{\\/}{/}g;

  my %seen; # avoid duplication in filenames
  
  my %metadata = map { $_ => '' } qw(brandTitle seriesTitle programmeTitle);
 
  my ($series, $episode);

  ($series, $episode) = ($browser->content =~ /Series (\d+) - Ep(?:isode)?\.? (\d+)/);

  if (!$series and !$episode) {
    ($series, $episode) = ($browser->content =~ /series_number: ["']?(\d+)["']?,\s+ep_number: ['"]?(\d+)['"]/);
  }

  if ($series and $episode) {
    $metadata{series_and_episode} = sprintf "S%02dE%02d", $series, $episode;
  }

  foreach my $metadata_item (keys %metadata) {
    if (my $value = ($content =~ m{<$metadata_item>(.*?)</$metadata_item>}isg)[0]) {
      $value = decode_entities($value);

      next if $seen{$value};

      $seen{$value}++;

      $metadata{$metadata_item} = $value;
    }
  }

  my @metadata_items;

  if ( (grep length, values %metadata) == 2 and
       $metadata{series_and_episode}) {
    @metadata_items = ((grep { $_ ne 'series_and_episode' } keys %metadata), 'series_and_episode');
  }
  elsif (!$metadata{brandTitle}) {
    @metadata_items = qw(seriesTitle series_and_episode programmeTitle);
  }
  else {
    @metadata_items = qw(brandTitle series_and_episode seriesTitle programmeTitle);
  }

  my $title = join "-", map { trim($_) }
                        grep length,
                        @metadata{@metadata_items};

  $browser->get($player_info);

  debug "Got player info URL $player_info";

  if (!$browser->success) {
    die "Couldn't get player info: " . $browser->response->status_line;
  }

  my @urls;
  for my $res(@res) {
    if($browser->content =~ /$res->{name}":\["([^"]+)/) {
      push @urls, { %$res, url => $1 };
    }
  }

  die "No video URLs found" unless @urls;

  my $rtmp = $prefs->quality->choose(@urls);

  my($app, $playpath, $query) = $rtmp->{url} =~ m{^\w+://[^/]+/(\w+/\w+)(/[^?]+)(\?.*)};
  my $prefix = "mp4";
  $prefix = "flv" if $playpath =~ /\.flv$/;

  if ($prefs->subtitles) {
    if ($browser->content =~ m{"subtitleLocation":\["([^"]+)"\]}) {
      my $subtitles_url = $1;
      
      if ($subtitles_url =~ m{^/}) {
        $subtitles_url = "http://www.seesaw.com$subtitles_url";
      }

      debug "Got Seesaw subtitles URL: $subtitles_url";

      $browser->get($subtitles_url);

      if ($browser->success) {
        my $srt_filename = title_to_filename($title, "srt"); 

        convert_sami_subtitles_to_srt($browser->content, $srt_filename);

        info "Wrote subtitles to $srt_filename";
      }
      else {
        info "Couldn't download subtitles: " . $browser->response->status_line;
      }
    }
    else {
      debug "No Seesaw subtitles available (or couldn't extract URL)";
    }
  }

  return {
    flv      => title_to_filename($title, $prefix),
    rtmp     => $rtmp->{url},
    app      => $app,
    playpath => "$prefix:$playpath$query"
  }
}

sub search {
  my($self, $search, $type) = @_;

  my $series  = $search =~ s/(?:series |\bs)(\d+)//i ? int $1 : "";
  my $episode = $search =~ s/(?:episode |\be)(\d+)//i ? int $1 : "";

  my $browser = FlashVideo::Mechanize->new;

  _update_with_content($browser,
    "http://www.seesaw.com/start.layout.searchsuggest:inputtextevent?search="
    . uri_escape($search));

  my @urls = map  {
    chomp(my $name = $_->text);
    { name => $name, url => $_->url_abs->as_string }
  } $browser->find_all_links(text_regex => qr/.+/);

  my @words = split " ", $search;
  @urls = grep { my $a = $_; @words == grep { $a->{name} =~ /\Q$_\E/i } @words } @urls;

  if(@urls == 1) {
    $browser->get($urls[0]->{url});
    my $main_title = ($browser->content =~ m{<h1>(.*?)</h1>}s)[0];
    $main_title =~ s/<[^>]+>//g;
    $main_title =~ s/\s+/ /g;

    my $cur_series = ($browser->content =~ /<li class="current">.*?>\w+ (\d+)/i)[0];
    if($main_title =~ s/\s*series (\d+)\s*//i && !$cur_series) {
      $cur_series = $1;
    }

    my %series = reverse(
      ($browser->content =~ m{<ul class="seriesList">(.*?)</ul>}i)[0]
      =~ /<li.*?href="\?([^"]+)".*?>\s*(?:series\s*)?([^<]+)/gi);

    my $episode_list;
    if($series && $cur_series ne $series) {
      if(!$series{$series}) {
        error "No such series number ($series).";
        return;
      }
      _update_with_content($browser, $series{$series});
      $episode_list = $browser->content;
      $cur_series = $series;

    } elsif(!$series && keys %series > 1) {
      my @series = sort { $a <=> $b } map { s/series\s+//i; $_ } keys %series;
      info "Viewing series $cur_series; series " . join(", ", @series) . " also available.";
      info "Search for 'seesaw $main_title series $series[0]' to view a specific series.";
    }

    if(!$episode_list) {
      $episode_list = ($browser->content
        =~ m{<table id="episodeListTble">(.*?)</table>}is)[0];
    }

    @urls = ();
    for my $episode_html($episode_list =~ m{<tr.*?</tr>}gis) {
      my %info;
      for(qw(number date title action)) {
        my $class = "episode" . ucfirst;
        $episode_html =~ m{<td class=['"]$class['"]>(.*?)</td>}gis
          && ($info{$_} = $1);
      }

      $info{number}   = ($info{number} =~ /ep\.?\w*\s*(\d+)/i)[0];
      $info{date}     = ($info{date}   =~ />(\w+[^<]+)/)[0];
      $info{number} ||= ($info{title}  =~ /ep\.?\w*\s*(\d+)/i)[0];
      $info{title}    = ($info{title}  =~ />\s*([^<].*?)\s*</s)[0];
      $info{url}      = ($info{action} =~ /href=['"]([^'"]+)/)[0];

      my $title = join " - ", $main_title,
        ($cur_series
          ? sprintf("S%02dE%02d", $cur_series, $info{number})
          : $info{number} ? sprintf("E%02d", $info{number})
        : ()), $info{title};

      my $result = {
        name => $title,
        url  => URI->new_abs($info{url}, $browser->uri)
      };

      if($episode && $info{number} == $episode) {
        return $result;
      }

      push @urls, $result;
    }
  } else {
    info "Please specify a more specific title to download a particular programme." if @urls > 1;
  }

  return @urls;
}

sub _update_with_content {
  my($browser, $url) = @_;

  $browser->get($url,
    X_Requested_With => 'XMLHttpRequest',
    X_Prototype_Version => '1.6.0.3');

  my($content) = $browser->content =~ /content":\s*"(.*?)"\s*}/;
  $content = json_unescape($content);
  debug "Content is '$content'";
  $browser->update_html($content);
}

sub trim {
  local $_ = shift;

  s/^\s+|\s+$//g;

  return $_;
}

1;
}
##} blib/lib/FlashVideo/Site/Seesaw.pm
BEGIN { $INC{'FlashVideo/Site/Sevenload.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Sevenload.pm
{
package FlashVideo::Site::Sevenload;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
use HTML::Entities;
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  die "Could not find configPath" unless $browser->content =~ /configPath=([^"']+)/;
  my $configpath = uri_unescape(decode_entities($1));
  $browser->get($configpath);

  my $config = from_xml($browser);
  
  my($title, $location);

  eval {
    my $item = $config->{playlists}->{playlist}->{items}->{item};
    $title = title_to_filename($item->{title});

    my $streams = $item->{videos}->{video}->{streams}->{stream};
    $streams = [ $streams ] unless ref $streams eq 'ARRAY';

    $location = (sort { $b->{width} <=> $a->{width} } @$streams)[0]
      ->{locations}->{location}->{content};
  };

  return $location, $title if $location;

  die "Unable to get stream location" . ($@ ? ": $@" : "");
}

1;
}
##} blib/lib/FlashVideo/Site/Sevenload.pm
BEGIN { $INC{'FlashVideo/Site/Slashcontrol.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Slashcontrol.pm
{
package FlashVideo::Site::Slashcontrol;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_json = \&FlashVideo::JSON::from_json; }

sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;

  my $config;
  my $mediaKey;
  if ($browser->content =~ /<param name="flashvars" value="config=([^&]*)&mediaKey=([^"]*)"\/>/) {
    $config = $1;
    $mediaKey = $2;
  } else {
    die "Couldn't find flashvars param in " . $browser->uri->as_string;
  }
  my $root;
  if ($browser->content =~ /<embed src="(.*)\/[^\/]*\.swf"/) {
    $root = $1;
  } else {
    die "Couldn't find embeded swf " . $browser->uri->as_string;
  }
  my $config_url;
  $config_url = $1 . "/" . $config;

  $browser->allow_redirects;
  $browser->get($config_url);
  if (!$browser->success) {
    die "Couldn't download config.xml $config_url: " . $browser->response->status_line;
  }

  my $xml = from_xml($browser);
  my $domain = $xml->{mfs}->{mfsUrl};
  my $version = $xml->{mfs}->{mfsVersion};
  my $account = $xml->{mfs}->{mfsAccount};
  my $partner = $xml->{mfs}->{mfsPartnerId};

  my $asset_url = "$domain/$version/$account/assets/$mediaKey/partner/$partner?format=json";
  $browser->get($asset_url);
  if (!$browser->success) {
    die "Couldn't download asset file $asset_url: " . $browser->response->status_line;
  }

  my $asset_data = from_json($browser->content);
  my $videos = $asset_data->{videos};

  my $title = title_to_filename($asset_data->{assetFields}->{seriesName} . " - " . $asset_data->{assetFields}->{title});

  my $video = $videos->{limelight700};

  my $rtmp = $video->{uri};

  return {
    flv => $title,
    rtmp => $rtmp,
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Slashcontrol.pm
BEGIN { $INC{'FlashVideo/Site/Spiegel.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Spiegel.pm
{
package FlashVideo::Site::Spiegel;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  my ($video_id, $xmlurl, $filename, $videourl, $quality);

  debug "Spiegel::find_video called, embed_url = \"$embed_url\"\n";
  
  $quality = {
      high => '.mp4',
      medium => 'VP6_928.flv',
      low => 'VP6_576.flv'}->{$prefs->{quality}};

  if($embed_url =~ /.*?www.spiegel.de\/video\/video-(\d*).html/) {
    $video_id = $1;
    $xmlurl = "http://video.spiegel.de/flash/$video_id.xml";
  } else {
    die "Only works for http://www.spiegel/de/video/video... urls\n";
  }

  if($browser->content =~ /<title>(.*?) -Video/) {
    $filename = "Spiegel_$1_${video_id}_$quality";
    $filename = title_to_filename($filename, $quality);
    $filename =~ s/__/_/g;
  } else {
    die "Unable to find <title> on page $embed_url\n";
  }

  $browser->get($xmlurl);

  if($browser->content =~ /<filename>(.*?$quality)<\/filename>/) {
    $videourl = "http://video.spiegel.de/flash/$1";
  } else {
    die "could not find video url\n";
  }

  return $videourl, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Spiegel.pm
BEGIN { $INC{'FlashVideo/Site/Spike.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Spike.pm
{
package FlashVideo::Site::Spike;

use strict;
BEGIN { FlashVideo::Site::Mtvnservices->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Mtvnservices';

BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $page_url = $browser->uri->as_string;

  my $config_url;
  if($browser->content =~ /config_url\s*=\s*["']([^"']+)/) {
    $config_url = $1;
  } elsif($browser->content =~ /(?:ifilmId|flvbaseclip)=(\d+)/) {
    $config_url = "/ui/xml/mediaplayer/config.groovy?ifilmId=$1";
  }
  die "No config_url/id found\n" unless $config_url;

  $browser->get(uri_unescape($config_url));
  my $xml = from_xml($browser);

  my $feed = uri_unescape($xml->{player}->{feed});
  die "Unable to find feed URL\n" unless $feed;

  $browser->get($feed);

  return $self->handle_feed($browser->content, $browser, $page_url);
}

1;
}
##} blib/lib/FlashVideo/Site/Spike.pm
BEGIN { $INC{'FlashVideo/Site/Stagevu.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Stagevu.pm
{
package FlashVideo::Site::Stagevu;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my($title) = $browser->content =~ /<title>(.*?)<\/title>/;
  $title =~ s/\s*-\s*Stagevu.*?$//;

  my($url) = FlashVideo::Generic->find_video($browser);

  return $url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Stagevu.pm
BEGIN { $INC{'FlashVideo/Site/Starwars.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Starwars.pm
{
package FlashVideo::Site::Starwars;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_id;
  if ($browser->uri->as_string =~ /view\/([0-9]+)\.html$/) {
    $video_id = $1;
  }

  my $page_url = $browser->uri->as_string;

  $browser->get("http://starwars.com/webapps/video/item/$video_id");
  my $xml = from_xml($browser);

  my $items = $xml->{channel}->{item};
  my $item = ref $items eq 'ARRAY' ?
    (grep { $_->{link}->{content} eq "/video/view/" . $video_id . ".html" } @$items)[0] :
    $items;

  debug $item->{enclosure}->{url};

  my $rtmpurl = $item->{enclosure}->{url};
  $rtmpurl =~ s/^rtmp:/rtmpe:/; # for some reason it only works with rtmpe

  my $title = $item->{title}; # is there a way to unencrypt <CDATA> tags? or does the xml handler do this for us?

  return {
    flv => $title,
    rtmp => title_to_filename($rtmpurl),
    playpath => $item->{content}->{url}
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Starwars.pm
BEGIN { $INC{'FlashVideo/Site/Stickam.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Stickam.pm
{
package FlashVideo::Site::Stickam;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *swfhash = \&FlashVideo::Utils::swfhash; }

sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;

  my $perfomer_id;

  if ($browser->content =~ /profileUserId=(\d+)/) {
    $perfomer_id = $1;  
  }
  else {
    die "Can't get performer ID";
  }

  my $filename;
  if ($browser->content =~ /userName=([^&]+)/) {
    $filename = $1;
  }
  else {
    $filename = $perfomer_id;
  }

  my $stream_info_url = sprintf
    "http://player.stickam.com/servlet/flash/getChannel?" .
    "type=join&performerID=%d", $perfomer_id;

  $browser->get($stream_info_url);

  if (!$browser->success) {
    die "Couldn't get stream info: " . $browser->response->status_line;
  }

  my %stream_info;

  foreach my $pair (split /&/, $browser->content) {
    my ($name, $value) = split /=/, $pair;

    if ($name eq 'freeServerIP') {
      $value = (split /,/, $value)[0];
    }
    
    $stream_info{$name} = $value;
  }

  if ($stream_info{errorCode}) {
    die "Stickam returned error $stream_info{errorCode}: $stream_info{errorMessage}";
  }

  my $rtmp_stream_url = sprintf
    "rtmp://%s/video_chat2_stickam_peep/%d/public/mainHostFeed",
    $stream_info{freeServerIP},
    $stream_info{channelID};

  return {
    rtmp => $rtmp_stream_url,
    flv => title_to_filename($filename),
    live => '',
    conn => [
      'O:1',
      "NS:channel:$perfomer_id",
      'O:1',
    ],
    swfhash($browser,
      "http://player.stickam.com/flash/stickam/stickam_simple_video_player.swf")
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Stickam.pm
BEGIN { $INC{'FlashVideo/Site/Stupidvideos.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Stupidvideos.pm
{
package FlashVideo::Site::Stupidvideos;

use strict;
BEGIN { FlashVideo::Site::Grindtv->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Grindtv';

1;
}
##} blib/lib/FlashVideo/Site/Stupidvideos.pm
BEGIN { $INC{'FlashVideo/Site/Svtplay.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Svtplay.pm
{
package FlashVideo::Site::Svtplay;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

my $encode_rates = {
     "ultralow" => 320,
     "low" => 850,
     "medium" => 1400, 
     "high" => 2400 };

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  my @rtmpdump_commands;
  my $url;
  my $low;
  my $ultralow;
  my $medium;
  my $high;
  my $data = ($browser->content =~ /dynamicStreams=(.*?)&/)[0];
  my @values = split(/\|/, $data); 
  foreach my $val (@values) {
    if (($val =~ m/url:(.*?),bitrate:2400/)){
       $high = ($val =~ /url:(.*?),bitrate:2400/)[0];
       debug "Found " . "$high";
    } elsif (($val =~ m/url:(.*?),bitrate:1400/)){
       $medium = ($val =~ /url:(.*?),bitrate:1400/)[0];
       debug "Found " . "$medium";
    }elsif (($val =~ m/url:(.*?),bitrate:850/)){
       $low = ($val =~ /url:(.*?),bitrate:850/)[0];
       debug "Found " . "$low";
    }elsif(($val =~ m/url:(.*?),bitrate:320/)){
       $ultralow = ($val =~ /url:(.*?),bitrate:320/)[0];
       debug "Found " . "$ultralow";
    }
  }

  my $encode_rate = $encode_rates->{$prefs->{quality}};
  if ($encode_rate == 2400 && defined $high) {
    $url = $high;
  } elsif ($encode_rate == 1400 && defined $medium) {
    $url = $medium;
  } elsif ($encode_rate == 850 && defined $low) {
    $url = $low;
  } elsif ($encode_rate == 320 && defined $ultralow) {
    $url = $ultralow;
  } elsif (defined $high){
    $url = $high;
    debug "Using high"
  } elsif (defined $medium) {
    $url = $medium;
    debug "Using medium"
  } elsif (defined $low) {
    $url = $low;
    debug "Using low"
  } elsif (defined $ultralow) {
    $url = $ultralow;
    debug "Using ultralow"
  }
  
  info "Using rtmp-url: $url";
  my $sub = ($browser->content =~ /subtitle=(.*?)&/)[0];
  my $videoid = ($browser->content =~ /videoId:'(.*?)'}/)[0];
  debug "videoid:$videoid";
  $browser->get("http://svtplay.se/popup/lasmer/v/" . "$videoid");
  my $title = ($browser->content =~ /property="og:title" content="(.*?)" \/>/)[0];
  my $flv_filename = title_to_filename($title, "flv");

  if ($prefs->{subtitles} == 1) {
    if ($sub) {
      info "Found subtitles: $sub";
      $browser->get("$sub");
      my $srt_filename = title_to_filename($title, "srt"); 
      my $srt_content = $browser->content;
      open (SRT, '>>',$srt_filename) 
        or die "Can't open subtitles file $srt_filename: $!";
      binmode SRT, ':utf8';
      print SRT $srt_content;
      close SRT;
    } else {
      info "No subtitles found!";
    }
  }
  my $args = {
      rtmp => "$url",
      flv => "$flv_filename",
  };
  push @rtmpdump_commands, $args;
  return \@rtmpdump_commands;

}

1;
}
##} blib/lib/FlashVideo/Site/Svtplay.pm
BEGIN { $INC{'FlashVideo/Site/Tbs.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tbs.pm
{
package FlashVideo::Site::Tbs;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $oid;
  if ($browser->uri->as_string =~ /oid=([0-9]*)/) {
    $oid = $1;
  }

  $browser->get("http://www.tbs.com/video/cvp/videoData.jsp?oid=$oid");

  my $xml = from_xml($browser);

  my $headline = $xml->{headline};

  my $akamai;
  if ($xml->{akamai}->{src} =~ /[^,]*,([^,]*)/){
    $akamai = $1;
  }

  my $files = $xml->{files}->{file};
  my $file = ref $files eq 'ARRAY' ?
    (grep { $_->{type} eq "standard" } @$files)[0] :
    $files;

  if($akamai) {
    my $rtmpurl = $akamai . $file->{content};
    die "Unable to find RTMP URL\n" unless $rtmpurl;

    return {
      flv => title_to_filename($headline),
      rtmp => $rtmpurl
    };
  } else {
    return $file->{content}, title_to_filename($headline);
  }
}

1;
}
##} blib/lib/FlashVideo/Site/Tbs.pm
BEGIN { $INC{'FlashVideo/Site/Techcast.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Techcast.pm
{
package FlashVideo::Site::Techcast;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use HTML::Entities;

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my($clip_url) = $browser->content =~ /clip:\s*{\s*url:\s*['"]([^"']+)/;
  die "Unable to extract clip URL" unless $clip_url;
  $clip_url = URI->new_abs($clip_url, $browser->uri);

  my($talk) = $browser->content =~ /class="lecture_archive"[^>]+>([^<]+)/i;
  $talk = decode_entities($talk);

  my($author) = $browser->content =~ /class="speaker_archive"[^>]+>([^<]+)/i;
  $author = decode_entities($author);

  return $clip_url, title_to_filename($talk ? "$author - $talk" : $clip_url);
}

1;
}
##} blib/lib/FlashVideo/Site/Techcast.pm
BEGIN { $INC{'FlashVideo/Site/Ted.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Ted.pm
{
package FlashVideo::Site::Ted;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my $url;
  if($browser->content =~ m{<param name="flashvars" value="vu=http://video.ted.com/[^"]*talk=([^&;]+);}) {
    my $embed_url = "http://www.ted.com/talks/$1.html";
    $browser->get($embed_url);
  }
  if($browser->content =~ m{<a href="(/talks[^"]+)">Watch high-res video}) {
    $url = URI->new_abs($1, $browser->uri);
    $browser->allow_redirects;
  } else {
    die "Unable to find download link";
  }


  my $title = extract_title($browser);
  $title =~ s/\s*\|.*//;
  my $filename = title_to_filename($title, "mp4");

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Ted.pm
BEGIN { $INC{'FlashVideo/Site/Theonion.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Theonion.pm
{
package FlashVideo::Site::Theonion; # horrible casing :(

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *extract_info = \&FlashVideo::Utils::extract_info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  if ($browser->response->is_redirect) {
    $browser->get( $browser->response->header('Location') );

    if (!$browser->success) {
      die "Couldn't follow Onion redirect: " .
        $browser->response->status_line;
    }
  }

  my $title;
  if ($browser->content =~ /var video_title = "([^"]+)"/) {
    $title = $1;
  }
  else {
    $title = extract_info($browser)->{meta_title};
  }

  my $filename = title_to_filename($title);

  my $url = (FlashVideo::Generic->find_video($browser, $browser->uri))[0];

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Theonion.pm
BEGIN { $INC{'FlashVideo/Site/Thirteen.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Thirteen.pm
{
package FlashVideo::Site::Thirteen;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_json = \&FlashVideo::JSON::from_json; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  my $iframe;
  if ($browser->content =~ /<iframe src="([^"]*)" /) {
    $iframe = $1;
  } else {
    die "Couln't find iframe in " . $browser->uri->as_string;
  }

  my $url = 'http://www.thirteen.org' . $iframe;
  $browser->get($url);
  if (!$browser->success) {
    die "Couldn't download iframe $url: " . $browser->response->status_line;
  }



  my $pid;
  if ($browser->content =~ /var pid = "([^"]*)";/) {
    $pid = $1;
  } elsif ($browser->uri->as_string =~ /&pid=([^&]*)&/) {
    $pid = $1;
  } else {
    die "Could not find pid for $url";
  }

  my $release_url;
  if ($browser->content =~ /so.addVariable\("releaseURL", "([^"]*)"+pid+"([^"]*)"\);/) {
    $release_url = $1 . $pid . $2;
  } else {
    $release_url = "http://release.theplatform.com/content.select?pid=" . $pid . "&amp;format=SMIL&amp;Tracking=true";
  }

  $browser->get($release_url);
  my $rtmp_url;
  if ($browser->response->is_redirect) {
    $rtmp_url = $browser->response->header("Location");
  } else {
    die "No redirect found for $release_url";
  }

  $rtmp_url =~ s/<break>//;

  my $filename;
  if ($rtmp_url =~ /mp4:(.*)\.mp4$/) {
    $filename = title_to_filename($1);
  } else {
    $filename = title_to_filename("");
  }


  return {
    rtmp => $rtmp_url,
    flv => $filename,
  };
}

1;
}
##} blib/lib/FlashVideo/Site/Thirteen.pm
BEGIN { $INC{'FlashVideo/Site/Todaysbigthing.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Todaysbigthing.pm
{
package FlashVideo::Site::Todaysbigthing;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

my $base = "http://www.todaysbigthing.com/betamax";

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $id;
  if($browser->content =~ /item_id=(\d+)/) {
    $id = $1;
  } elsif($embed_url =~ m![/:](\d+)!) {
    $id = $1;
  }
  die "No ID found\n" unless $id;

  $browser->get("$base:$id");

  my $xml = from_xml($browser);

  my $title = $xml->{title};
  $title = extract_title($browser) if ref $title;
  my $filename = title_to_filename($title);

  my $url = $xml->{flv};
  die "No FLV location" unless $url;

  return $url, $filename;
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->content =~ $base;
}

1;
}
##} blib/lib/FlashVideo/Site/Todaysbigthing.pm
BEGIN { $INC{'FlashVideo/Site/Tou.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
# tou.tv
#
#	Reverse-engineering details at http://store-it.appspot.com/tou/tou.html
#	by Sylvain Fourmanoit
#
#	un grand merci a Sylvain qui a tout debrousaille!
#
#	Stavr0
#
##{ blib/lib/FlashVideo/Site/Tou.pm
{
package FlashVideo::Site::Tou;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_escape = \&URI::Escape::uri_escape; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  my $video_id;
  if ($browser->content =~ /,"pid":"(\w+)"/i) {
    $video_id = $1;
  }
  debug "Video ID = " . $video_id;

  die "Couldn't find TOU.TV video ID" unless $video_id;

  my $filename;
  if ($browser->content =~ /,"titleId":"([^"]+)"/i) {
    $filename =  $1 ;
  }
  debug "Filename = " . $filename;

  $browser->get("http://release.theplatform.com/content.select?pid=$video_id");

  die "Couldn't download TOU.TV XML: " . $browser->response->status_line
    if !$browser->success;

  my $url;
  if ($browser->content =~ /(rtmp:[^\<]+)/i) {
    $url = uri_unescape($1);
  }
  debug "URL = " . $url;

  my $auth;
  if ($url =~ /auth=([^&]+)/i) {
    $auth = uri_unescape($1);
  }
  debug "AUTH = " . $auth;

  my $app;
  if ($url =~ /(ondemand\/.+)/i) {
    $app = uri_unescape($1);
  }
  debug "APP = " . $app;

  my $playpath;
  if ($url =~ /&lt;break&gt;(.+)/i) {
    $playpath = uri_unescape($1);
  }
  debug "PLAYPATH = " . $playpath;


  return {
      app => $app,
      pageUrl => $url,
      swfUrl => "http://static.tou.tv/lib/ThePlatform/4.1.2/swf/flvPlayer.swf",
      tcUrl => $url,
      auth => $auth,
      rtmp => $url,
      playpath => $playpath,
      flv => "$filename.flv",
  };
}

sub search {
  my($self, $search, $type) = @_;

  my $browser = FlashVideo::Mechanize->new;
  $browser->get("http://www.tou.tv/recherche?q=" . uri_escape($search));
  return unless $browser->success;

  my $results = $browser->content;

  my @emissions;
  my @links;

  while($results =~ /<a\s+href="([^"]+)"\s+id="[^"]+"\s+class="([^"]+)/g) {
    debug $1;
    if($2 eq "tousEpisodes") {
      push @emissions, $1;
    }
  }

  for my $emission (@emissions) {
    $browser->get($emission);
    my $liste = $browser->content;

    while($liste =~ /<a.+class="episode".+href="([^"]+)".+>(.+)<\/a>/g) {
      push @links, { name => $1, url => "http://www.tou.tv$1", description => $2 };
    }
  }

  return @links;
}

1;
}
##} blib/lib/FlashVideo/Site/Tou.pm
BEGIN { $INC{'FlashVideo/Site/Traileraddict.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Traileraddict.pm
{
package FlashVideo::Site::Traileraddict;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser) = @_;

  my $video_id;
  if ($browser->content =~ m'/em[db]/(\d+)') {
    $video_id = $1;
  }
  else {
    die "Unable to get Traileraddict video ID";
  }

  my $video_info_url = "http://www.traileraddict.com/fvar.php?tid=$video_id";

  $browser->get($video_info_url);

  if (!$browser->success) {
    die "Couldn't download Traileraddict video info URL: " .
        $browser->response->status_line;
  }

  my %info = parse_video_info($browser->content);

  die "Couldn't find Traileraddict video URL" unless $info{fileurl};

  $browser->head($info{fileurl});
  if ($browser->response->is_redirect()) {
    $info{fileurl} = $browser->response->header('Location');
  }

  my $type = $info{fileurl} =~ /\.mp4/i ? 'mp4' : 'flv';
  
  return $info{fileurl}, title_to_filename($info{title}, $type);
}

sub parse_video_info {
  my $raw_video_info = shift;

  my %info;

  foreach my $pair (split /&/, $raw_video_info) {
    $pair = uri_unescape($pair);

    my ($name, $value) = split /=/, $pair;

    $info{$name} = $value;
  }

  return %info;
}

1;
}
##} blib/lib/FlashVideo/Site/Traileraddict.pm
BEGIN { $INC{'FlashVideo/Site/Truveo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Truveo.pm
{
package FlashVideo::Site::Truveo;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *url_exists = \&FlashVideo::Utils::url_exists; }

sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;

  my($videourl) = $browser->content =~ /var videourl = "(.*?)"/;

  $videourl = $embed_url
    if !$videourl && $browser->uri->host eq 'xml.truveo.com';

  die "videourl not found" unless $videourl;

  $browser->get($videourl);

  if($browser->content =~ /url=(http:.*?)["']/) {
    my $redirect = url_exists($browser, $1);

    $browser->get($redirect);

    my($package, $possible_url) = FlashVideo::URLFinder->find_package($redirect, $browser);

    die "Recursion detected" if $package eq __PACKAGE__;

    return $package->find_video($browser, $possible_url, $prefs);
  } else {
    die "Redirect URL not found";
  }
}

1;
}
##} blib/lib/FlashVideo/Site/Truveo.pm
BEGIN { $INC{'FlashVideo/Site/Tudou.pm'}++; }
##{ blib/lib/FlashVideo/Site/Tudou.pm
{
package FlashVideo::Site::Tudou;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $check_response = sub {
    my ( $message ) = @_;
    return if $browser->success;
    die sprintf $message, $browser->response->code;
  };


  my $videoID = 0;

  if ( $embed_url =~ m`hd.tudou.com/program/\w+` )
  {
    ( $videoID ) = ( $browser->content =~ /iid: "(\w+)"/ );
  }

  else
  {
    if ( $embed_url =~ m`tudou.com/programs/view/(.+)$` )
    {
      $embed_url = sprintf "http://www.tudou.com/v/%s", $1;
      $browser->get( $embed_url );
    }

    if ( $browser->response->code eq 302 and $embed_url =~ m`tudou.com/v/(.+)$` )
    {
      $embed_url = $browser->response->header( 'Location' );
    }

    ( $videoID ) = ( $embed_url =~ m`tudou.com/player/outside/player_outside.swf\?iid=(\d+)` );
  }

  die "Couldn't extract video ID, we are out probably out of date" unless $videoID;
  debug "Using video ID $videoID";

  $browser->get(
    sprintf "http://v2.tudou.com/v2/kili?safekey=%s&id=%s&noCatch=%d",
    'YouNeverKnowThat', $videoID, rand( 10000 ) );

  if ( not $browser->success )
  {
    debug 'Using fallback tudou link for video info';
    $browser->get(
      sprintf "http://v2.tudou.com/v2/cdn?safekey=%s&id=%s&noCatch=%d",
      'YouNeverKnowThat', $videoID, rand( 10000 ) );
  }
  $check_response->( "Couldn't grab video informaton from tudou, server response was %s" );

  return parse_video_info( $browser->content );
}

sub parse_video_info {
  my ( $raw_xml ) = @_;


  my $xml = from_xml($raw_xml, forcearray => [ 'f' ] );

  my %streams;
  foreach my $file ( @{$xml->{b}->{f}} )
  {
    my $url = $file->{content};

    my ( $format ) = ( $url =~ m`http://[^/]+/([^/]+)/` );
    debug "Unable to extract file format for $url" and next
      unless $format;

    push @{$streams{$format}{urls}}, $url;
    $streams{$format}{size} = $file->{size};
  }

  my $stream
    = ( exists $streams{mp4} ? 'mp4'
      : exists $streams{m4v} ? 'm4v'
      : exists $streams{flv} ? 'flv'
      : exists $streams{wwwFlv} ? 'wwwFlv'
      : exists $streams{f4v} ? 'f4v'
      : exists $streams{phoneMp4} ? 'phoneMp4'
      : '' );

  my $stream_formats = join ', ', ( keys %streams );
  die "Video is only available in unknown file formats ($stream_formats)",
    unless $stream;

  debug "Choosing to use the $stream stream (available: $stream_formats)";
  my $stream_choice = int rand( 1 + $#{$streams{$stream}{urls}} );
  my $url = @{$streams{$stream}{urls}}[$stream_choice];

  my $sourceID = ( $stream eq 'flv' ? '11000' : '18000' );
  $url =~ s/\?key=/?$sourceID&key=/;

  my $title = $xml->{title};
  my $filename = title_to_filename( $title, 'flv' );

  my $stream_duration = $xml->{time};
  my $stream_size = $streams{$stream}{size};
  debug sprintf
    "%s, %d seconds, %s bytes",
    $title, $stream_duration / 1000, $stream_size
      if ( $title and $stream_duration and $stream_size );

  return ( $url, $filename );
}

1;
}
##} blib/lib/FlashVideo/Site/Tudou.pm
BEGIN { $INC{'FlashVideo/Site/Tv.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tv.pm
{
package FlashVideo::Site::Tv;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;


  my $pid;
  if ($browser->content =~ /so.addVariable\("pid", "([^"]*)"\);/) {
    $pid = $1;
  } else {
    die "Could not find PID for video! " . $browser->uri->as_string;
  }

  my $url = "http://release.theplatform.com/content.select?format=SMIL&Tracking=true&balance=true&pid=$pid";
  $browser->get($url);
  if (!$browser->success) {
    die "Couldn't download content.select $url: " . $browser->response->status_line;
  }

  my $xml = from_xml($browser);
  my $items = $xml->{body}->{ref};
  my $item = ref $items eq 'ARRAY' ?
    (grep { $_->{src} =~ /^rtmp:\/\// } @$items)[0] :
    $items;

  my $filename = title_to_filename($item->{title});

  my $playpath = "";
  my $rtmpurl = $item->{src};

  $rtmpurl =~ s/<break>.*//;

  return {
    flv => $filename,
    rtmp => $rtmpurl,
  };
}

sub can_handle {
  my($self, $browser, $url) = @_;
  return $browser->uri->host =~ /(^|\.)tv\.com$/;
}

1;
}
##} blib/lib/FlashVideo/Site/Tv.pm
BEGIN { $INC{'FlashVideo/Site/Tv3play.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tv3play.pm
{
package FlashVideo::Site::Tv3play;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *convert_sami_subtitles_to_srt = \&FlashVideo::Utils::convert_sami_subtitles_to_srt; }


sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  return $self->find_video_viasat($browser,$embed_url,$prefs);
}

sub find_video_viasat {
  my ($self, $browser, $embed_url, $prefs) = @_;
  my $video_id = ($browser->content =~ /id:([0-9]*),/)[0];
  info "Got video_id: $video_id";
  my $info_url = "http://viastream.viasat.tv/PlayProduct/$video_id";
  $browser->get($info_url);
  my $variable = $browser->content;
  $variable =~ s/\n//g;
  my $title = ($variable =~ /<Title><!\[CDATA\[(.*?)\]\]><\/Title>/)[0];
  my $flv_filename = title_to_filename($title, "flv");



  my @urls;
  my $count = 0;
  my $base = ($variable =~ /<Videos>(.*)<\/Videos>/)[0];
  for ($count = 0; $count < 3; $count++){
    my $video = ($base =~ /<Video>(.+)<\/Video>/p)[0];
    if ($video eq ''){last;};
    $base = ${^POSTMATCH};    
    my $bitrate = ($video =~ /<BitRate>([0-9]*)<\/BitRate>/)[0];
    my $url = ($video =~ /<Url><!\[CDATA\[(.*)]]><\/Url>/)[0];
    if (not (($url =~ /http:\/\//)[0] eq '')){
      $browser->get($url);
      $variable = $browser->content;
      $variable =~ s/\n//g;
      $url = ($variable =~ /<Url>(.*)<\/Url>/)[0];
    }
    
    $urls[$count++] = { 'bitrate' => $bitrate,
		      'rtmp' => $url
		    };
  }
  my $bitrate = 0;
  my $rtmp;
  my $new_bitrate;

  foreach (@urls) {
    $new_bitrate = int($_->{bitrate});
    if($new_bitrate > $bitrate){
        $bitrate = int($_->{bitrate});
        $rtmp = $_->{rtmp};
    }
  };

  my @rtmpdump_commands;
  my $args = {
      rtmp => $rtmp,
      swfVfy => "http://flvplayer-viastream-viasat-tv.origin.vss.viasat.tv/play/swf/player110420.swf",
      flv => $flv_filename
  };
  push @rtmpdump_commands, $args;
  return \@rtmpdump_commands;

}

1;
}
##} blib/lib/FlashVideo/Site/Tv3play.pm
BEGIN { $INC{'FlashVideo/Site/Tv4play.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tv4play.pm
{
package FlashVideo::Site::Tv4play;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *convert_sami_subtitles_to_srt = \&FlashVideo::Utils::convert_sami_subtitles_to_srt; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  my $vid = ($embed_url =~ /videoid=([0-9]*)/)[0];
  my $smi_url = "http://premium.tv4play.se/api/web/asset/$vid/play";
 
  my $title = ($browser->content =~ /property="og:title" content="(.*?)"/)[0];
  my $flv_filename = title_to_filename($title, "flv");

  $browser->get($smi_url);
  my $content = from_xml($browser);
  my $i = 0;
  my @dump;
  my $subtitle_url;
  for ($i = 0; $i < 5; $i++){
    my $format = $content->{items}->{item}[$i]->{mediaFormat};
    my $bitrate = $content->{items}->{item}[$i]->{bitrate};
    my $rtmp = $content->{items}->{item}[$i]->{base};
    my $mp4 = $content->{items}->{item}[$i]->{url};
    @dump[$i] = { 'rtmp' => $rtmp,
		  'bitrate' => $bitrate,
		  'mp4' => $mp4,
		  'format' => $format
		};
  }  
  foreach (@dump) {
    if($_->{format} eq 'smi'){ $subtitle_url = $_->{mp4};}
  }
  debug "Subtitle_url: $subtitle_url";

  my @rtmpdump_commands; 
  my $args = {
      rtmp => $dump[0]->{rtmp},
      swfVfy => "http://www.tv4play.se/flash/tv4playflashlets.swf",
      playpath =>  $dump[0]->{mp4},
      flv => $flv_filename
  };
  push @rtmpdump_commands, $args;
  return \@rtmpdump_commands;
}

1;
}
##} blib/lib/FlashVideo/Site/Tv4play.pm
BEGIN { $INC{'FlashVideo/Site/Tv6play.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tv6play.pm
{
package FlashVideo::Site::Tv6play;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { FlashVideo::Site::Tv3play->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Tv3play';


sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  return $self->find_video_viasat($browser,$embed_url,$prefs);
}
1;
}
##} blib/lib/FlashVideo/Site/Tv6play.pm
BEGIN { $INC{'FlashVideo/Site/Tv8play.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tv8play.pm
{
package FlashVideo::Site::Tv8play;
use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }
BEGIN { FlashVideo::Site::Tv3play->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Tv3play';


sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  return $self->find_video_viasat($browser,$embed_url,$prefs);
}
1;
}
##} blib/lib/FlashVideo/Site/Tv8play.pm
BEGIN { $INC{'FlashVideo/Site/Tva.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Tva.pm
{
package FlashVideo::Site::Tva;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; }
BEGIN { FlashVideo::Site::Brightcove->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Brightcove';

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $video_id  = ($browser->content =~ /player.SetVideo.(\d+)/i)[0];
  my $player_id = ($browser->content =~ /player.SetPlayer.(\d+)/i)[0];

  debug "Extracted playerId: $player_id, videoId: $video_id"
    if $player_id or $video_id;

  if(!$video_id) {
    my $video_offset = ($browser->content =~ /player.SetVideo.\w+\[(\d+)/i)[0];
    $video_id = ($browser->content =~ /videos\[$video_offset\].+'(\d+)'\s*\]/)[0];
  }

  die "Unable to extract Brightcove IDs from page"
    unless $player_id and $video_id;

  return $self->amfgateway($browser, $player_id, { videoId => $video_id, } );
}

sub can_handle {
  my($self, $browser, $url) = @_;

  return $browser->content =~ /player = CanoeVideoStandalone\.create\(\);/i;
}

1;
}
##} blib/lib/FlashVideo/Site/Tva.pm
BEGIN { $INC{'FlashVideo/Site/Ustream.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Ustream.pm
{
package FlashVideo::Site::Ustream;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
use MIME::Base64;

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  unless(eval { require Data::AMF::Packet }) {
    die "Must have Data::AMF::Packet installed to download ustream videos";
  }

  my $packet = Data::AMF::Packet->deserialize(decode_base64(<<EOF));
AAAAAAABAA9WaWV3ZXIuZ2V0VmlkZW8AAi8xAAAAiAoAAAABAwAIYXV0b3BsYXkBAQAEcnBpbgIA
GHJwaW4uMC4xODM2MDk4NTkzMTY0Njg5OAAHdmlkZW9JZAIABzIzNTU3MzYAB3BhZ2VVcmwCACZo
dHRwOi8vd3d3LnVzdHJlYW0udHYvcmVjb3JkZWQvMjM1NTczNgAHYnJhbmRJZAIAATEAAAkK
EOF

  my($title) = $browser->content =~ /<h2[^>]*>([^<]+)/;

  my($video_id) = $browser->uri =~ m{recorded/(\d+)};
  $video_id ||= $browser->content =~ m{vid\s*=\s*["']?(\d+)};

  $packet->messages->[0]->{value}->[0]->{videoId} = $video_id;

  my $data = $packet->serialize;

  $browser->post(
    "http://216.52.240.138/gateway.php",
    Content_Type => "application/x-amf",
    Content => $data
  );

  die "Failed to post to Ustream AMF gateway"
    unless $browser->response->is_success;

  my($flv_url) = $browser->content =~ /flv.{3,5}(http:[^\0]+)/;

  return $flv_url, title_to_filename($title);
}

1;
}
##} blib/lib/FlashVideo/Site/Ustream.pm
BEGIN { $INC{'FlashVideo/Site/Videobb.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Videobb.pm
{
package FlashVideo::Site::Videobb;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_json = \&FlashVideo::JSON::from_json; }
use MIME::Base64;

sub find_video {
  my ($self, $browser) = @_;

  if($browser->status == 302) {
    $browser->allow_redirects;
    $browser->get;
  }
  my $flash_settings_b64 = ($browser->content =~ /<param value="setting=([^"]+)" name="FlashVars">/s)[0];
  my $flash_settings = decode_base64($flash_settings_b64);

  $browser->get($flash_settings);

  if (!$browser->success) {
    die "Couldn't download video settings: " . $browser->response->status_line;
  }

  my $settings_data = from_json($browser->content);

  my $url = decode_base64($settings_data->{settings}{res}->[-1]->{u});
  
  my $title  = $settings_data->{settings}{video_details}{video}{title};
  my $filename = title_to_filename($title);

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Videobb.pm
BEGIN { $INC{'FlashVideo/Site/Videojug.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Videojug.pm
{
package FlashVideo::Site::Videojug;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

my $playlist_url = "http://www.videojug.com/views/film/playlist.aspx?items=&userName=&ar=16_9&id=";

sub find_video {
  my ($self, $browser) = @_;

  my $interview_clip;

  if ($browser->uri->as_string =~ m'/interview/'i) {
    $playlist_url =
      "http://www.videojug.com/views/interview/playlist.aspx?ar=16_9&id=";

    $interview_clip = $browser->uri->fragment; 
  }

  my $video_id;
  
  if ($browser->content =~
    /<meta name=["']video-id["'] content="([A-F0-9a-f\-]+)"/) {
    $video_id = $1;
  } else {
    die "Couldn't find video ID in Videojug page";
  }

  $browser->get($playlist_url . $video_id);


  my($video_url, $filename);
  eval {
    my $xml = from_xml($browser);

    my $shape = $xml->{Shapes}->{Shape}->[-1];
    my $location = (grep { $shape->{Locations} =~ /\Q$_->{Name}\E/ }
      @{$xml->{Locations}->{Location}})[0];

    my ($prefix, $title);

    if ($interview_clip) {
      ($prefix, $title) = get_prefix_and_title($xml, $interview_clip); 
    }
    else {
      $prefix = $xml->{Items}->{Media}->{Prefix};
      $title = $xml->{Items}->{Media}->{Title};
    }

    $video_url = sprintf "%s%s__%sENG.flv",
      $location->{Url}, $prefix, $shape->{Code};

    $filename = title_to_filename($title);
  };
  die "Unable to retrieve/parse Videojug playlist. $@" if $@;

  die "Couldn't find video URL" unless $video_url;

  return $video_url, $filename;
}

sub get_prefix_and_title {
  my ($xml, $video_name) = @_;

  foreach my $media (@{ $xml->{Items}->{Media} }) {
    my $title = lc $media->{Title};
    $title =~ s/ /-/g;
    $title =~ s/[^a-z0-9\-]//g;

    if ($title eq $video_name) {
      return $media->{Prefix}, $media->{Title};
    }
  }

  die "Couldn't find prefix for video '$video_name'";
}

1;
}
##} blib/lib/FlashVideo/Site/Videojug.pm
BEGIN { $INC{'FlashVideo/Site/Videolectures.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Videolectures.pm
{
package FlashVideo::Site::Videolectures;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my $author = ($browser->content =~ /author:\s*<\/span><a [^>]+>([^<]+)/s)[0];
  my $title  = ($browser->content =~ /<h2>([^<]+)/)[0];

  my $streamer = ($browser->content =~ /clip\.netConnectionUrl\s*=\s*["']([^"']+)/)[0];
  my $playpath = ($browser->content =~ /clip\.url\s*=\s*["']([^"']+)/)[0];
  $playpath =~ s/\.flv$//;

  my $data = {
    app      => (split m{/}, $streamer)[-1],
    rtmp     => $streamer,
    playpath => $playpath,
    flv      => title_to_filename("$author - $title")
  };

  return $data;
}

1;
}
##} blib/lib/FlashVideo/Site/Videolectures.pm
BEGIN { $INC{'FlashVideo/Site/Vimeo.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Vimeo.pm
{
package FlashVideo::Site::Vimeo;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;
  my $base = "http://vimeo.com/moogaloop";

  my $id;
  if($embed_url =~ /clip_id=(\d+)/) {
    $id = $1;
  } elsif($embed_url =~ m!/(\d+)!) {
    $id = $1;
  }
  die "No ID found\n" unless $id;

  $browser->get("$base/load/clip:$id/embed?param_fullscreen=1&param_clip_id=$id&param_show_byline=0&param_server=vimeo.com&param_color=cc6600&param_show_portrait=0&param_show_title=1");

  my $xml = from_xml($browser);
  my $filename = title_to_filename($xml->{video}->{caption});
  my $request_signature = $xml->{request_signature};
  my $request_signature_expires = $xml->{request_signature_expires};
  my $isHD = $xml->{video}->{isHD};

  $browser->allow_redirects;
  
  my $url = "$base/play/clip:$id/$request_signature/$request_signature_expires/?q=hd&type=embed";
  if ($isHD == '1') { 
      return $url, $filename;
  };
  $url = "$base/play/clip:$id/$request_signature/$request_signature_expires/?q=sd&type=embed";
  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Vimeo.pm
BEGIN { $INC{'FlashVideo/Site/Vrak.pm'}++; }
##{ blib/lib/FlashVideo/Site/Vrak.pm
{
package FlashVideo::Site::Vrak;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *from_xml = \&FlashVideo::Utils::from_xml; }
no strict 'refs';



sub find_video {
  my($self, $browser, $embed_url, $prefs) = @_;

  my $check_response = sub {
    my ( $message ) = @_;
    return if $browser->success;
    die sprintf $message, $browser->response->code;
  };


  my $videoID = 0;

  ( $videoID ) = ( $browser->content =~ /var\s+videoId\s*=\s*(\d+)\s*;/i );
  debug "VIDEOID = " . $videoID;
  
  die "No Vrak Video ID found" unless  $videoID;
  
  my $title;
  ( $title ) = ( $browser->content =~ /var\s+videoTitle\s*=\s*"([^"]+)/i );
  
  debug "TITLE = " . $title . " " . title_to_filename($title, 'flv');
 
  my $xmlurl = 'http://www.vrak.tv/webtele/_dyn/getVideoDataXml.jsp?videoId=' . $videoID;
  $browser->get($xmlurl);
  my $xml = from_xml($browser);
  
  my $url;
  if ( $prefs->{quality} == "high" ) {
        $url = $xml->{video}->{highFlvUrl};
  } else {              
        $url = $xml->{video}->{lowFlvUrl};
  }
  debug "URL = " . $url;
  
  my $ext;
  ( $ext ) = ( $url =~ /\.(.+)$/i );

  die "No (high|low)FlvUrl found in XML ". $xmlurl unless $url;
  
  return $url, title_to_filename($title);
  
 }

1;

}
##} blib/lib/FlashVideo/Site/Vrak.pm
BEGIN { $INC{'FlashVideo/Site/Wat.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Wat.pm
{
package FlashVideo::Site::Wat;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *json_unescape = \&FlashVideo::Utils::json_unescape; }
use HTML::Entities;
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

die "Must have Digest::MD5 for this download\n" 
  unless eval {
    require Digest::MD5;
  };

sub token {
  my $url = shift;
  my $hexdate = sprintf("%x",time());
  $hexdate .= "0" x (length($hexdate) - 8);
  my $key = "9b673b13fa4682ed14c3cfa5af5310274b514c4133e9b3a81e6e3aba00912564";
  return Digest::MD5::md5_hex($key . $url . $hexdate)."/".$hexdate;
}


sub find_video {
  my ($self, $browser) = @_;

  $browser->content =~ /url\s*:\s*["'].*?nIc0K11(\d+)["']/i
    || die "No video ID found";
  my $video_id = $1;

  $browser->get("http://www.wat.tv/interface/contentv3/$video_id");

  my $title = json_unescape(($browser->content =~ /title":"(.*?)",/)[0]);

  my $location = "/web/$video_id";
  my $token = &token($location);

  my $url = "http://www.wat.tv/get".$location.
         "?token=".$token.
         "&context=swf2&getURL=1&version=WIN%2010,3,181,14";

  my $file_type = 'flv';

  $browser->head($url);
  
  if (!$browser->success) {
    die "Couldn't do HEAD request $url: " . $browser->response->status_line;
  }

  my $content_type = $browser->response->header('Content-Type');
  if ($content_type =~ /text/) {
    $browser->get($url);

    if (!$browser->success) {
      die "Couldn't get $url: " . $browser->response->status_line;
    }

    if ($browser->content =~ m'^(http://\S+)') {
      $url = $1;

      if ($url =~ /\.h264/) {
        $file_type = 'mp4';
      }
    }
  }
  else {
    die "Unexpected Content-Type ($content_type) from Wat server."; 
  }

  my $filename = title_to_filename($title, $file_type);

  $browser->allow_redirects;

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Wat.pm
BEGIN { $INC{'FlashVideo/Site/Xhamster.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Xhamster.pm
{
package FlashVideo::Site::Xhamster;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }

sub find_video {
  my ($self, $browser) = @_;

  my $server;
  if ($browser->content =~ m{'srv': '(http://[^'"]+)'}) {
    $server = $1;
  }
  else {
    die "Couldn't determine xhamster server";
  }

  my $video_file;
  if ($browser->content =~ m{'file': '([^'"]+\.flv)'}) {
    $video_file = $1;
  }
  else {
    die "Couldn't determine xhamster video filename";
  }

  my $filename = title_to_filename(extract_title($browser));
 
  my $url = sprintf "%s/flv2/%s", $server, $video_file;

  $browser->allow_redirects;

  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Xhamster.pm
BEGIN { $INC{'FlashVideo/Site/Xnxx.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Xnxx.pm
{
package FlashVideo::Site::Xnxx;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *title_to_filename = \&FlashVideo::Utils::title_to_filename; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $url = ($browser->content =~ /flv_url=(.+?)&/)[0];
  $url = uri_unescape($url);
  die "Unable to extract url" unless $url;

  $browser->content =~ /(?:<span class="style5">|<td style="font-size: 20px;">\s*)<strong>([^<]+)/;

  my $filename = title_to_filename($1);
    
  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Xnxx.pm
BEGIN { $INC{'FlashVideo/Site/Xvideos.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Xvideos.pm
{
package FlashVideo::Site::Xvideos;

use strict;
BEGIN { FlashVideo::Site::Xnxx->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Xnxx';

1;
}
##} blib/lib/FlashVideo/Site/Xvideos.pm
BEGIN { $INC{'FlashVideo/Site/Youku.pm'}++; }
##{ blib/lib/FlashVideo/Site/Youku.pm
{
package FlashVideo::Site::Youku;

use strict;
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_json = \&FlashVideo::JSON::from_json; }
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *get_video_filename = \&FlashVideo::Utils::get_video_filename; }

sub find_video {
  my ($self, $browser, $embed_url) = @_;

  my $check_response = sub {
    my ( $message ) = @_;
    return if $browser->success;
    die sprintf $message, $browser->response->code;
  };


  if ( $embed_url !~ m`^http://v.youku.com/v_show/` )
  {
    die "Don't recognise the youku link"
      unless $embed_url =~ m`player.php/sid/(.+)/v\.swf`
      or $embed_url =~ m`qplayer\.swf\?VideoIDS=([^&]+)`;

    $embed_url = sprintf "http://v.youku.com/v_show/id_%s.html", $1;
    $browser->get( $embed_url );
  }
  $check_response->( "Can't load the youku page, server response was %s" );

  my ( $videoID ) = ( $browser->content =~ /var videoId = '(.+?)';/ );
  die "Couldn't extract video ID from youku page, we are probably out of date"
    unless $videoID;
  debug "Using video ID $videoID";

  $browser->get(
    sprintf "http://v.youku.com/player/getPlayList/VideoIDS/%s/version/5/source/video/password/?ran=%d&n=%d",
    $videoID, rand( 10000 ), 3 );
  $check_response->( "Couldn't grab video informaton from youku, server response was %s" );

  return parse_video_info( $browser );
}

sub extract {
  my ($json, $key, $type) = @_;
  die "Can't find '$key' key in the JSON data"
    unless exists $json->{$key};
  my $data = $json->{$key};
  if (defined $type) {
    my $dtype = ref $data || 'DATA';
    die "JSON data under '$key' is not the right type"
      . " (expecting $type, but got $dtype)"
      unless $dtype eq $type;
  }
  return $data;
}

sub parse_video_info {
  my ($browser) = @_;

  my $jsonstr = $browser->content;
  debug "Video data: $jsonstr";

  my $json = from_json($jsonstr);

  my $data_array = extract($json, data => 'ARRAY');
  die "No elements found in 'data' array" unless @$data_array;
  my $data = $data_array->[0];

  my $shuffle_seed = extract($data, 'seed');

  my @streamtype_preferences = qw(mp4 flv);
  my $streamtypes = extract($data, streamtypes => 'ARRAY');

  my $stream = $streamtypes->[0];

  for my $pref (@streamtype_preferences) {
    if (grep { $_ eq $pref } @$streamtypes) {
      $stream = $pref;
      last;
    }
  }

  my $streams = join ' ', @$streamtypes;
  debug "Choosing to use the $stream stream (available: $streams)";

  my $fileID;
  if (exists $data->{streamfileids}) {
    my $streamfileids = extract($data, streamfileids => 'HASH');

    $fileID = extract($streamfileids, $stream)
      if exists $streamfileids->{$stream};
  }

  $fileID = extract($data, 'fileid')
    if not $fileID and exists $data->{fileid};

  die "Can't find the encrypted file ID in the video info JSON"
    unless $fileID;
  debug "Encrypted file ID: $fileID";

  my @lookup_table = shuffle_table( $shuffle_seed );
  $fileID =~ s/(\d+)\*/$lookup_table[$1]/eg;
  debug "Decrypted file ID: $fileID (seed is $shuffle_seed)";

  my $sID = sprintf "%s1%07d_00", time, rand( 10000000 ) ;

  my $key1 = extract($data, 'key1');
  my $key2 = extract($data, 'key2');
  my $key = sprintf "%s%x", $key2, hex( $key1 ) ^ hex( 'a55aa5a5' );

  my $title = extract($data, 'title');
  $title =~ s/\\u([a-f0-9]{4})/chr(hex $1)/egi;

  my $filename = get_video_filename( $stream );
  $filename = title_to_filename( $title, $stream ) if $title;

  my $segmap = extract($data, segs => 'HASH');
  die "Stream '$stream' not found in segment map 'segs'"
    unless exists $segmap->{$stream};
  my $segs = extract($segmap, $stream, 'ARRAY');

  my @urls;
  my $segment_count = 0;

  for my $seg (@$segs) {
    my $segment_number = extract($seg, 'no');
    my $segment_size = extract($seg, 'size');
    my $segment_seconds = extract($seg, 'seconds');

    my $segment_number_str = sprintf '%02X', $segment_number;
    my $segment_fileID = $fileID;
    substr $segment_fileID, 8, 2, $segment_number_str;

    $browser->get(
      sprintf "http://f.youku.com/player/getFlvPath/sid/%s/st/%s/fileid/%s?K=%s&myp=null",
        $sID, $stream, $segment_fileID, $key );

    my $url = $browser->response->header( 'Location' );
    die "Youku rejected our attempt to get the video, we're probably out of date"
      unless $browser->response->code eq 302 and $url;

    debug "Video location for segment $segment_number is $url";
    $url = "$url.$stream" unless $url =~ /$stream$/;

    debug sprintf "%s, segment %d, %s seconds, %s bytes",
      $title, $segment_number, $segment_seconds, $segment_size
      if ( $title and $segment_seconds and $segment_size );

    push @urls, [$url, ++$segment_count, 0, $segment_size];
  }

  $_->[2] = $segment_count for @urls;

  return ( \@urls, $filename );
}

sub shuffle_table {
  my ( $seed ) = @_;
  my @lookup
    = split //,
      q`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/\:._-1234567890`;

  my @shuffled;
  while ( $#lookup > 0 )
  {
    $seed = ( 211 * $seed + 30031 ) % 2**16;

    my $x = int( $seed / 2**16 * ( $#lookup + 1 ) );
    push @shuffled, splice( @lookup, $x, 1 );
  }
  return @shuffled;
}

1;
}
##} blib/lib/FlashVideo/Site/Youku.pm
BEGIN { $INC{'FlashVideo/Site/Youtu.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Site/Youtube.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Youtube.pm
{
package FlashVideo::Site::Youtube;

use strict;
use Encode;
use HTML::Entities;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *extract_info = \&FlashVideo::Utils::extract_info; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *url_exists = \&FlashVideo::Utils::url_exists; *swfhash = \&FlashVideo::Utils::swfhash; *json_unescape = \&FlashVideo::Utils::json_unescape; }
BEGIN { FlashVideo::JSON->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *from_json = \&FlashVideo::JSON::from_json; }
BEGIN { URI::Escape->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_escape = \&URI::Escape::uri_escape; *uri_unescape = \&URI::Escape::uri_unescape; *uri_escape_utf8 = \&URI::Escape::uri_escape_utf8; }

my @formats = (
  { id => 38, resolution => [4096, 2304] },
  { id => 37, resolution => [1920, 1080] },
  { id => 22, resolution => [1280, 720] },
  { id => 35, resolution => [854, 480] },
  { id => 34, resolution => [640, 360] },
  { id => 18, resolution => [480, 270] },
  { id => 5,  resolution => [400, 224] },
  { id => 17, resolution => [176, 144] },
  { id => 13, resolution => [176, 144] },
);

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  if($embed_url !~ m!youtube\.com/watch!) {
    $browser->get($embed_url);
    if ($browser->response->header('Location') =~ m!/swf/.*video_id=([^&]+)!
        || $browser->content =~ m!\<iframe[^\>]*src="http://www.youtube.com/embed/([^"]+)"!i
        || $embed_url =~ m!/v/([-_a-z0-9]+)!i
        || $browser->uri =~ m!v%3D([-_a-z0-9]+)!i) {
      $embed_url = "http://www.youtube.com/watch?v=$1";
      $browser->get($embed_url);
    }
  }

  if (!$browser->success) {
    verify_age($browser, $prefs);
  }

  my $title = extract_info($browser)->{meta_title};
  if (!$title and
    $browser->content =~ /<div id="vidTitle">\s+<span ?>(.+?)<\/span>/ or
      $browser->content =~ /<div id="watch-vid-title">\s*<div ?>(.+?)<\/div>/) {
    $title = $1;
  }

  if ($browser->content =~ /["']fmt_url_map["']:\s{0,3}(["'][^"']+["'])/) {
    my $fmt_map = $1;
    if ($fmt_map !~ /\|/) {
      $fmt_map = uri_unescape($fmt_map);
    }
    debug "Using fmt_url_map method from page ($fmt_map)";
    return $self->download_fmt_map($prefs, $browser, $title, {}, @{from_json $fmt_map});
  }

  my $video_id;
  if ($browser->content =~ /(?:var pageVideoId =|(?:CFG_)?VIDEO_ID'?\s*:)\s*'(.+?)'/
      || $browser->content =~ /"video_id": "([^"]+)"/
      || $embed_url =~ /v=([^&]+)/) {
    $video_id = $1;
  } else {
    check_die($browser, "Couldn't extract video ID");
  }

  my $t;
  if ($browser->content =~ /\W['"]?t['"]?: ?['"](.+?)['"]/) {
    $t = $1;
  }

  my $video_page_url = $browser->uri->as_string;

  if (my %info = get_youtube_video_info($browser->clone, $video_id, $video_page_url, $t)) {
    if($self->debug) {
      require Data::Dumper;
      debug Data::Dumper::Dumper(\%info);
    }

    if ($info{conn} =~ /^rtmp/) {
      my ($season, $episode);

      if ($browser->content =~ m{<span[^>]*>Season ?(\d+)}i) {
        $season = $1;
      }

      if ($browser->content =~ m{<span[^>]*>[^<]+Ep\.?\w* ?(\d+)\W*\s*</span>}i) {
        $episode = $1;
      }

      if ($season and $episode) {
        $title .= sprintf " S%02dE%02d", $season, $episode;
      }

      my $swf_url;
      if ($browser->content =~ /SWF_URL['"] ?: ?.{0,90}?(http:\/\/[^ ]+\.swf)/) {
        $swf_url = $1;
      } elsif($browser->content =~ /swfConfig\s*=\s*(\{.*?\});/ && (my $swf = from_json($1))) {
        $swf_url = $swf->{url};
      } elsif($browser->content =~ /src=\\['"]([^'"]+\.swf)/) {
        $swf_url = json_unescape($1);
      } else {
        die "Couldn't extract SWF URL";
      }

      my $rtmp_url = $info{conn};

      if($info{fmt_stream_map}) {
        my $fmt_stream_map = parse_youtube_format_url_map($info{fmt_stream_map}, 1);

        my $preferred_quality = $prefs->quality->choose(map { $fmt_stream_map->{$_->{id}}
            ? { resolution => $_->{resolution}, url => $fmt_stream_map->{$_->{id}} }
            : () } @formats);

        $rtmp_url = $preferred_quality->{url};
      }

      return {
        flv => title_to_filename($title),
        rtmp => $rtmp_url,
        swfhash($browser, $swf_url)
      };
    } elsif($info{fmt_url_map}) {
      debug "Using fmt_url_map method from info";
      return $self->download_fmt_map($prefs, $browser, $title, \%info, $info{fmt_url_map});
    } elsif($info{url_encoded_fmt_stream_map}) {
      debug "Using url_encoded_fmt_stream_map method from info";
      if ($info{title}) {
        $title=$info{title};
      }
      return $self->download_url_encoded_fmt_stream_map($prefs, $browser, $title, \%info, $info{url_encoded_fmt_stream_map});
    }
  }

  return download_get_video($browser, $prefs, $video_id, $title, $t);
}

sub download_url_encoded_fmt_stream_map {
  my($self, $prefs, $browser, $title, $info, $fmt_map) = @_;

  my $fmt_url_map = parse_youtube_url_encoded_fmt_stream_map($fmt_map);

  if (!$title and $browser->uri->as_string =~ m'/user/.*?#') {
    my $video_id = (split /\//, $browser->uri->fragment)[-1];

    my %info = get_youtube_video_info($browser->clone, $video_id);

    $title = $info->{title};
  }

  my $preferred_quality = $prefs->quality->choose(map { $fmt_url_map->{$_->{id}}
      ? { resolution => $_->{resolution}, url => $fmt_url_map->{$_->{id}} }
      : () } @formats);

  $browser->allow_redirects;

  return $preferred_quality->{url}, title_to_filename($title, "mp4");
}

sub parse_youtube_url_encoded_fmt_stream_map {
  my($raw_map) = @_;;

  my $map = {};

  foreach my $params (split /,/, $raw_map) {
    
    my $format = "";
    my $url = "";
    
    foreach my $pair (split /&/, $params) {
      my ($name, $value) = split /=/, $pair;
      if ($name eq "itag"){
        $format = $value;
      } elsif ($name eq "url") {
        $url = uri_unescape($value);
      }
    }
    
    $map->{$format} = $url;
  }
  
  return $map;
}

sub download_fmt_map {
  my($self, $prefs, $browser, $title, $info, $fmt_map) = @_;

  my $fmt_url_map = parse_youtube_format_url_map($fmt_map);

  if (!$title and $browser->uri->as_string =~ m'/user/.*?#') {
    my $video_id = (split /\//, $browser->uri->fragment)[-1];

    my %info = get_youtube_video_info($browser->clone, $video_id);

    $title = $info->{title};
  }

  my $preferred_quality = $prefs->quality->choose(map { $fmt_url_map->{$_->{id}}
      ? { resolution => $_->{resolution}, url => $fmt_url_map->{$_->{id}} }
      : () } @formats);

  $browser->allow_redirects;

  return $preferred_quality->{url}, title_to_filename($title, "mp4");
}

sub download_get_video {
  my($browser, $prefs, $video_id, $title, $t) = @_;

  my $fetcher = sub {
    my($url, $filename) = @_;
    $url = url_exists($browser->clone, $url, 1);
    return $url, $filename if $url;
    return;
  };

  my @formats_to_try = @formats;

  while(my $fmt = $prefs->quality->choose(@formats_to_try)) {
    @formats_to_try = grep { $_ != $fmt } @formats_to_try;

    my @ret = $fetcher->("http://www.youtube.com/get_video?fmt=$fmt->{id}&video_id=$video_id&t=$t",
      title_to_filename($title, "mp4"));
    return @ret if @ret;
  }

  my @ret = $fetcher->("http://www.youtube.com/get_video?video_id=$video_id&t=$t",
    title_to_filename($title));

  check_die($browser, "Unable to find video URL") unless @ret;

  $browser->allow_redirects;

  return @ret;
}

sub check_die {
  my($browser, $message) = @_;

  if($browser->content =~ m{class="yt-alert-content">([^<]+)}) {
    my $alert = $1;
    $alert =~ s/(^\s+|\s+$)//g;
    $message .= "\nYouTube: $alert";
    error $message;
    exit 1;
  } else {
    die "$message\n";
  }
}

sub verify_age {
  my($browser, $prefs) = @_;
  my $orig_uri = $browser->uri;

  if ($browser->response->code == 303 
    && $browser->response->header('Location') =~ m!/verify_age|/accounts/!) {

    my $confirmation_url = $browser->response->header('Location');
    $browser->get($confirmation_url);

    if($browser->content =~ /has_verified=1/) {
      my($verify_url) = $browser->content =~ /href="(.*?has_verified=1)"/;
      $verify_url = decode_entities($verify_url);
      $browser->get($verify_url);
      return if $browser->response->code == 200;
    }

    my $account = $prefs->account("youtube", <<EOT);
Unfortunately, due to Youtube being lame, you have to have
an account to download this video. (See the documentation for how to configure
~/.netrc)

EOT

    unless ($account->username and $account->password) {
      error "You must supply Youtube account details.";
      exit 1;
    }

    $browser->get("http://www.youtube.com/login");
    if ($browser->response->code != 303) {
      die "Unexpected response from Youtube login.\n";
    }

    my $real_login_url = $browser->response->header('Location');
    $browser->get($real_login_url);

    $browser->form_with_fields('Email', 'Passwd');
    $browser->set_fields(
      Email  => $account->username,
      Passwd => $account->password,
    );
    $browser->submit();

    if ($browser->content =~ /your login was incorrect/) {
      error "Couldn't log you in, check your username and password.";
      exit 1;
    } elsif ($browser->response->code == 302) {
      my $check_cookie_url = $browser->response->header('Location');
      $browser->get($check_cookie_url);

      if ($browser->content =~ /<meta.*"refresh".*?url=&#39;(.*?)&#39;"/i) {
        my $redirected = decode_entities($1);
        $browser->get($redirected);

        if(URI->new($redirected)->host !~ /youtube/i) {
          if($browser->response->code == 302) {
            $browser->get($browser->response->header("Location"));
          } else {
            die "Did not find expected redirection";
          }
        }
      } else {
        die "Did not find expected redirection";
      }
    }
    else {
      die "Unexpected response during login";
    }

    $browser->get($orig_uri);

    if ($browser->response->code == 303) {
      my $real_confirmation_url = $browser->response->header('Location');
      $browser->get($real_confirmation_url);
      if ($browser->form_with_fields('next_url', 'action_confirm')) {
        $browser->field('action_confirm' => 'Confirm Birth Date');
        $browser->click_button(name => "action_confirm");

        if ($browser->response->code != 303) {
          die "Unexpected response from Youtube";
        }
        $browser->get($browser->response->header('Location'));
      }
    }
  }
  else {
    if ($browser->response->code == 302) {
      $browser->get($browser->response->header('Location'));
    }

    if ($browser->response->code == 303) {
      debug "Video not available (303), trying " . $browser->response->header('Location');
      $browser->get($browser->response->header('Location'));
    }

    if (!$browser->success) {
      die "Couldn't download URL: " . $browser->response->status_line;
    }
  }
}

sub get_youtube_video_info {
  my ($browser, $video_id, $url, $t) = @_;

  $url ||= "http://www.youtube.com/watch?v=$video_id";

  for my $el(qw(profilepage detailpage)) {
    my $video_info_url_template =
      "http://www.youtube.com/get_video_info?&video_id=%s&el=$el&ps=default&eurl=%s&hl=en_US&t=%s";

    my $video_info_url = sprintf $video_info_url_template,
      uri_escape($video_id), uri_escape($url), uri_escape_utf8($t);

    debug "get_youtube_video_info: $video_info_url";

    $browser->get($video_info_url);

    next unless $browser->success;

    my %info = parse_youtube_video_info($browser->content);
    next if $info{status} eq 'fail';

    return %info;
  }

  error "Unable to get YouTube video information.";
}

sub parse_youtube_video_info {
  my $raw_info = shift;

  my %video_info;

  foreach my $raw_pair (split /&/, $raw_info) {
    my ($key, $value) = split /=/, $raw_pair;
    $value = uri_unescape($value);
    $value =~ s/\+/ /g;

    $video_info{$key} = $value;
  }

  return %video_info;
}

sub parse_youtube_format_url_map {
  my($raw_map, $param_idx) = @_;

  $param_idx = 0 unless defined $param_idx;

  my $map = {};

  foreach my $pair (split /,/, $raw_map) {
    my ($format, @params) = split /\|/, $pair;

    my $url = $params[$param_idx];

    $url = uri_unescape($url);

    $map->{$format} = $url;
  }
  
  return $map;
}

1;
}
##} blib/lib/FlashVideo/Site/Youtube.pm
##{ blib/lib/FlashVideo/Site/Youtu.pm
{
package FlashVideo::Site::Youtu;

BEGIN { FlashVideo::Site::Youtube->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Youtube';

1;
}
##} blib/lib/FlashVideo/Site/Youtu.pm
BEGIN { $INC{'FlashVideo/Site/Youtubenocookie.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Site/Youtubenocookie.pm
{
package FlashVideo::Site::Youtubenocookie;

use strict;
BEGIN { FlashVideo::Site::Youtube->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Site::Youtube';

1;
}
##} blib/lib/FlashVideo/Site/Youtubenocookie.pm
BEGIN { $INC{'FlashVideo/Site/Zshare.pm'}++; }
# A get-flash-videos module for the zshare.net website
#################################################
#
# This file was automatically generated by utils/combine-perl.pl
# You should edit the original files, not this
# combined version.
#
# The original files are available at:
# http://github.com/monsieurvideo/get-flash-videos
#
#################################################
# Copyright (C) 2011 Rudolf Olah <rolah@goaugust.com>
# Licensed under the GNU GPL v3 or later

# Created using the instructions from: http://code.google.com/p/get-flash-videos/wiki/AddingSite

##{ blib/lib/FlashVideo/Site/Zshare.pm
{
package FlashVideo::Site::Zshare;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; }

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;
  $embed_url = ($browser->content =~ /iframe src="(.*videoplayer.*?)"/i)[0];
  $browser->get($embed_url);
  my $url = ($browser->content =~ /file:.*"(.*?)"/i)[0];
  my $filename = ($browser->content =~ /<title>.*?- (.*)<\/title>/i)[0];
  return $url, $filename;
}

1;
}
##} blib/lib/FlashVideo/Site/Zshare.pm
##{ .sitemodules
{
package main;
}
##} .sitemodules
#!/usr/bin/perl
BEGIN { $INC{'FlashVideo/URLFinder.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/Generic.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Generic.pm
{
package FlashVideo::Generic;

use strict;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *extract_title = \&FlashVideo::Utils::extract_title; *title_to_filename = \&FlashVideo::Utils::title_to_filename; *get_video_filename = \&FlashVideo::Utils::get_video_filename; *url_exists = \&FlashVideo::Utils::url_exists; *EXTENSIONS = \&FlashVideo::Utils::EXTENSIONS; }
BEGIN { URI->import(); } # (added by utils/combine-perl.pl)
BEGIN { URI::Escape->import( qw(uri_unescape)); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *uri_unescape = \&URI::Escape::uri_unescape; }

my $video_re = qr!http[-:/a-z0-9%_.?=&]+@{[EXTENSIONS]}
                  (?:\?[-:/a-z0-9%_.?=&]+)?!xi;

sub find_video {
  my ($self, $browser, $embed_url, $prefs) = @_;

  if (!$browser->success) {
    $browser->get($browser->response->header('Location'));
    die "Couldn't download URL: " . $browser->response->status_line
      unless $browser->success;
  }

  my ($possible_filename, $actual_url, $title);
  $title = extract_title($browser);

  my @flv_urls = map {
    (m{http://.+?(http://.+?@{[EXTENSIONS]})}i) ? $1 : $_
  } ($browser->content =~ m{($video_re)}gi);
  if (@flv_urls) {
    require LWP::Simple;
    require Memoize;
    Memoize::memoize("LWP::Simple::head");
    @flv_urls = sort { (LWP::Simple::head($a))[1] <=> (LWP::Simple::head($b))[1] } @flv_urls;
    $possible_filename = (split /\//, $flv_urls[-1])[-1];

    if ($flv_urls[-1] =~ /^http%3a%2f%2f/) {
      $flv_urls[-1] = uri_unescape($flv_urls[-1])
    }
    
    $actual_url = url_exists($browser->clone, $flv_urls[-1]);
  }

  my $filename_is_reliable;

  if(!$actual_url) {
    RE: for my $regex(
        qr{(?si)<embed.*?flashvars=["']?([^"'>]+)},
        qr{(?si)<embed.*?src=["']?([^"'>]+)},
        qr{(?si)<a[^>]* href=["']?([^"'>]+?@{[EXTENSIONS]})},
        qr{(?si)<object[^>]*>.*?<param [^>]*value=["']?([^"'>]+)},
        qr{(?si)<object[^>]*>(.*?)</object>},
        qr{(?si)<script[^>]*>(.*?)</script>}) {

      for my $param($browser->content =~ /$regex/gi) {
        (my $url, $possible_filename, $filename_is_reliable) = find_file_param($browser->clone, $param, $prefs);

        if($url) {
          my $resolved_url = url_exists($browser->clone, $url);
          if($resolved_url) {
            $actual_url = $resolved_url;
            last RE;
          }
        }
      }
    }

    if(!$actual_url) {
      for my $iframe($browser->content =~ /<iframe[^>]+src=["']?([^"'>]+)/gi) {
        $iframe = URI->new_abs($iframe, $browser->uri);
        debug "Found iframe: $iframe";
        my $sub_browser = $browser->clone;
        $sub_browser->get($iframe);
        ($actual_url) = eval { $self->find_video($sub_browser, undef, $prefs) };
      }
    }
  }

  my @filenames;
  
  return $actual_url, $possible_filename if $filename_is_reliable;

  $possible_filename =~ s/\?.*//;
  push @filenames, $possible_filename if $possible_filename
    && $possible_filename !~ /^[0-9_.]+@{[EXTENSIONS]}$/;

  my $ext = substr(($actual_url =~ /(@{[EXTENSIONS]})$/)[0], 1);
  push @filenames, title_to_filename($title, $ext) if
    $title && $title !~ /\Q$possible_filename\E/i;

  push @filenames, get_video_filename() if !@filenames;
  
  return $actual_url, @filenames if $actual_url;


  my %swf_urls;

  if (eval { require URI::Find }) {
    my $finder = URI::Find->new(
      sub { $swf_urls{$_[1]}++ if $_[1] =~ /\.swf$/i }
    );
    $finder->find(\$browser->content);
  }
  else {
    my $content = $browser->content;
    while($content =~ m{(http://[^ "']+?\.swf)}ig) {
      $swf_urls{$1}++;
    }
  }

  if (%swf_urls) {
    foreach my $swf_url (keys %swf_urls) {
      if (my ($flv_url, $title) = search_for_flv_in_swf($browser, $swf_url)) {
        return $flv_url, title_to_filename($title);
      }
    }
  }

  die "No URLs found";
}

sub search_for_flv_in_swf {
  my ($browser, $swf_url) = @_;

  $browser = $browser->clone();

  $browser->get($swf_url);

  if (!$browser->success) {
    die "Couldn't download SWF URL $swf_url: " .
      $browser->response->status_line();
  }

  my $swf_data = $browser->content;

  if ('C' eq substr $swf_data, 0, 1) {
    if (eval { require Compress::Zlib }) {
      $swf_data = Compress::Zlib::uncompress(substr $swf_data, 8);
    }
    else {
      die "Compress::Zlib is required to uncompress compressed SWF files.\n";
    }
  }

  if ($swf_data =~ m{(http://.{10,300}?\.flv)}i) {
    my $flv_url = $1;

    my $filename = uri_unescape(File::Basename::basename(URI->new($flv_url)->path()));
    $filename =~ s/\.flv$//i;

    return ($flv_url, $filename);
  }

  return;
}

sub find_file_param {
  my($browser, $param, $prefs) = @_;

  for my $file($param =~ /(?:video|movie|file|path)_?(?:href|src|url)?['"]?\s*[=:,]\s*['"]?([^&'" ]+)/gi,
      $param =~ /(?:config|playlist|options)['"]?\s*[,:=]\s*['"]?(http[^'"&]+)/gi,
      $param =~ /['"=](.*?@{[EXTENSIONS]})/gi,
      $param =~ /([^ ]+@{[EXTENSIONS]})/gi,
      $param =~ /SWFObject\(["']([^"']+)/) {

    debug "Found $file";

    my ($actual_url, $filename, $filename_is_reliable) = guess_file($browser, $file, '', $prefs);

    if(!$actual_url && $file =~ /\?(.*)/) {
      debug "Trying query param on $1";

      for my $query_param(split /[;&]/, $1) {
        my($query_key, $query_value) = split /=/, $query_param;
        debug "Found $query_value from $query_key";

        ($actual_url, $filename, $filename_is_reliable)
          = guess_file($browser, $query_value, '', $prefs);

        last if $actual_url;
      }
    }

    if($actual_url) {
      my $possible_filename = $filename || (split /\//, $actual_url)[-1];

      return $actual_url, $possible_filename, $filename_is_reliable;
    }
  }

  if($param =~ m{(rtmp://[^ &"']+)}) {
    info "This looks like RTMP ($1), no generic support yet..";
  }
  
  return;
}

sub guess_file {
  my($browser, $file, $once, $prefs) = @_;

  $file = uri_unescape($file) if scalar(() = $file =~ /%[A-F0-9]{2}/gi) > 3;

  my $orig_uri = URI->new_abs($file, $browser->uri);

  info "Guessed $orig_uri trying...";

  if($orig_uri) {
    my $uri = url_exists($browser->clone, $orig_uri);

    if($uri) {
      my ($package, $url) = FlashVideo::URLFinder->find_package($uri,
        $browser->clone);

      if($package && $package ne __PACKAGE__) {
        debug "$uri is supported by $package.";
        (my $browser_on_supported_site = $browser->clone())->get($uri);
        return $package->find_video($browser_on_supported_site, $uri, $prefs), 1;
      }

      my $content_type = $browser->response->header("Content-type");

      if($content_type =~ m!^(text|application/xml)!) {
        $browser->add_header("Range", "bytes=0-10000");
        $browser->get($uri);
        $browser->delete_header("Range");

        if(FlashVideo::Downloader->check_magic($browser->content)
            || $uri =~ m!$video_re!) {
          debug "Found a video at $uri";
          return $uri;
        }

        return if $browser->content =~ /<html[^>]*>/i;

        if($browser->content =~ m!($video_re)!) {
          return $1;
        } elsif(!defined $once
            && $browser->content =~ m!(http[-:/a-zA-Z0-9%_.?=&]+)!i) {
          return guess_file($browser, $1, 1, $prefs);
        } else {
          info "Tried $uri, but no video URL found";
        }
      } elsif($content_type =~ m!application/! && $uri ne $orig_uri) {
        return((find_file_param($browser, $uri))[0]);
      } else {
        return $uri->as_string;
      }
    } elsif(not defined $once) {
      if($browser->content =~ /["']([^ ]+\.swf)/) {
        my $swf_uri = URI->new_abs($1, $browser->uri);
        if($swf_uri) {
          my $new_uri = URI->new_abs($file, $swf_uri);
          debug "Found SWF: $swf_uri -> $new_uri";
          if($new_uri ne $uri) {
            return guess_file($browser, $new_uri, 1, $prefs);
          }
        }
      }
    }
  }

  return;
}

1;
}
##} blib/lib/FlashVideo/Generic.pm
##{ blib/lib/FlashVideo/URLFinder.pm
{
package FlashVideo::URLFinder;

use strict;
BEGIN { FlashVideo::Mechanize->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Generic->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Site->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *info = \&FlashVideo::Utils::info; }
BEGIN { URI->import(); } # (added by utils/combine-perl.pl)


my @extra_can_handle = qw(Brightcove Mtvnservices Gawker);

sub find_package {
  my($class, $url, $browser) = @_;
  my $package = _find_package_url($url, $browser);

  if(!defined $package) {

    for my $possible_url($browser->content =~
        m!(?:<object[^>]+>.*?|<(?:script|embed|iframe|param) [^>]*(?:src=["']?|name=["']src["']\ value=["']))(http://[^"'> ]+)!gixs) {
      $package = _find_package_url($possible_url, $browser);

      return _found($package, $possible_url) if defined $package;
    }
  }

  if(!defined $package) {
    for(@extra_can_handle) {
      my $possible_package = _load($_);

      my $r = $possible_package->can_handle($browser, $url);
      if($r) {
        $package = $possible_package;
        last;
      }
    }
  }

  if(!defined $package) {
    $package = "FlashVideo::Generic";
  }

  return _found($package, $url);
}


sub _find_package_url {
  my($url, $browser) = @_;
  my $package;

  foreach my $host_part (split /\./, URI->new($url)->host) {
    $host_part = lc $host_part;
    $host_part =~ s/[^a-z0-9]//i;

    my $possible_package = _load($host_part);

    if($possible_package->can("find_video")) {

      if($possible_package->can("can_handle")) {
        next unless $possible_package->can_handle($browser, $url);
      }

      $package = $possible_package;
      last;
    }
  }

  return $package;
}

sub _found {
  my($package, $url) = @_;
  info "Using method '" . lc((split /::/, $package)[-1]) . "' for $url";
  return $package, $url;
}

sub _load {
  my($site) = @_;

  my $package = "FlashVideo::Site::" . ucfirst lc $site;

  if(eval "require $package") {
    no strict 'refs';
    push @{$package . "::ISA"}, "FlashVideo::Site";
  }
  return $package;
}

1;
}
##} blib/lib/FlashVideo/URLFinder.pm
BEGIN { $INC{'FlashVideo/RTMPDownloader.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/RTMPDownloader.pm
{
package FlashVideo::RTMPDownloader;

use strict;
BEGIN { FlashVideo::Downloader->import(); } # (added by utils/combine-perl.pl)
use base 'FlashVideo::Downloader';
use IPC::Open3;
use Fcntl ();
use Symbol qw(gensym);
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *swfhash = \&FlashVideo::Utils::swfhash; *is_program_on_path = \&FlashVideo::Utils::is_program_on_path; }

use constant LATEST_RTMPDUMP => 2.2;

sub download {
  my ($self, $rtmp_data) = @_;

  $self->{printable_filename} = $rtmp_data->{flv};

  my $file = $rtmp_data->{flv} = $self->get_filename($rtmp_data->{flv});

  if (-s $file && !$rtmp_data->{live}) {
    info "RTMP output filename '$self->{printable_filename}' already " .
                 "exists, asking to resume...";
    $rtmp_data->{resume} = '';
  }

  if(my $socks = FlashVideo::Mechanize->new->get_socks_proxy) {
    $rtmp_data->{socks} = $socks;
  }

  my($r_fh, $w_fh); # So Perl doesn't close them behind our back..

  if ($rtmp_data->{live} && $self->action eq 'play') {

    pipe($r_fh, $w_fh);

    my $pid = fork;
    die "Fork failed" unless defined $pid;
    if(!$pid) {
      fcntl $r_fh, Fcntl::F_SETFD(), ~Fcntl::FD_CLOEXEC();
      exec $self->replace_filename($self->player, "/dev/fd/" . fileno $r_fh);
      die "Exec failed\n";
    }

    fcntl $w_fh, Fcntl::F_SETFD(), ~Fcntl::FD_CLOEXEC();
    $rtmp_data->{flv} = "/dev/fd/" . fileno $w_fh;

    $self->{stream} = undef;
  }

  my $prog = $self->get_rtmp_program;

  if($prog eq 'flvstreamer' && ($rtmp_data->{rtmp} =~ /^rtmpe:/ || $rtmp_data->{swfhash})) {
    error "FLVStreamer does not support "
      . ($rtmp_data->{swfhash} ? "SWF hashing" : "RTMPE streams")
      . ", please install rtmpdump.";
    exit 1;
  }

  if($self->debug) {
    $rtmp_data->{verbose} = undef;
  }

  my($return, @errors) = $self->run($prog, $rtmp_data);

  if($return != 0 && "@errors" =~ /failed to connect/i) {
    info "Couldn't connect on RTMP port, trying port 443 instead";
    $rtmp_data->{port} = 443;
    ($return, @errors) = $self->run($prog, $rtmp_data);
  }

  if($file ne '-' && (-s $file < 100 || !$self->check_file($file))) {
    error "Download failed, no valid file downloaded";
    unlink $rtmp_data->{flv};
    return 0;
  }

  if($return == 2) {
    info "\nDownload incomplete -- try running again to resume.";
    return 0;
  } elsif($return) {
    info "\nDownload failed.";
    return 0;
  }

  return -s $file;
}

sub get_rtmp_program {
  if(is_program_on_path("rtmpdump")) {
    return "rtmpdump";
  } elsif(is_program_on_path("flvstreamer")) {
    return "flvstreamer";
  }

  return "rtmpdump";
}

sub get_command {
  my($self, $rtmp_data, $debug) = @_;

  return map {
    my $arg = $_;

    (ref $rtmp_data->{$arg} eq 'ARRAY'
      ? (map {
        ("--$arg" => $debug
          ? $self->shell_escape($_)
          : $_) } @{$rtmp_data->{$arg}})
      : ("--$arg" => (($debug && $rtmp_data->{$arg})
        ? $self->shell_escape($rtmp_data->{$arg})
        : $rtmp_data->{$arg}) || ()))
  } keys %$rtmp_data;
}

sub run {
  my($self, $prog, $rtmp_data) = @_;

  debug "Running $prog", join(" ", $self->get_command($rtmp_data, 1));

  my($in, $out, $err);
  $err = gensym;
  my $pid = open3($in, $out, $err, $prog, $self->get_command($rtmp_data));

  local $SIG{INT};
  if ($^O =~ /mswin/i) {
    $SIG{INT} = sub {
      kill 'TERM', $pid;
      exit;
    };
  }

  my $complete = 0;
  my $buf = "";
  my @error;

  while(sysread($err, $buf, 128, length $buf) > 0) {
    $buf =~ s/\015\012/\012/g;

    my @parts = split /\015/, $buf;
    $buf = "";

    for(@parts) {
      if(/^((?:DEBUG:|WARNING:|Closing connection|ERROR: No playpath found).*)\n/) {
        debug "$prog: $1";
      } elsif(/^(ERROR: .*)\012/) {
        push @error, $1;
        info "$prog: $1";
      } elsif(/^([0-9.]+) kB(?:\s+\/ \S+ sec)?(?: \(([0-9.]+)%\))?/i) {
        $self->{downloaded} = $1 * 1024;
        my $percent = $2;

        if($self->{downloaded} && $percent != 0) {
          $self->{content_length} = $self->{downloaded} / ($percent / 100);
        }

        $self->progress;
      } elsif(/\012$/) {
        for my $l(split /\012/) {
          if($l =~ /^[A-F0-9]{,2}(?:\s+[A-F0-9]{2})*\s*$/) {
            debug $l;
          } elsif($l =~ /Download complete/) {
            $complete = 1;
          } elsif($l =~ /\s+filesize\s+(\d+)/) {
            $self->{content_length} = $1;
          } elsif($l =~ /\w/) {
            print STDERR "\r" if $self->{downloaded};
            info $l;

            if($l =~ /^RTMPDump v([0-9.]+)/ && $1 < LATEST_RTMPDUMP) {
              error "==== Using the latest version of RTMPDump (version "
                . LATEST_RTMPDUMP . ") is recommended. ====";
            }
          }
        }

        if(/open3/) {
          error "\nMake sure you have 'rtmpdump' or 'flvstreamer' installed and available on your PATH.";
          return 0;
        }
      } else {
        $buf = $_;
      }
    }

    if(defined $self->{stream} && $self->{downloaded} > 300_000) {
      $self->{stream}->();
    }
  }

  waitpid $pid, 0;
  return $? >> 8, @error;
}

1;
}
##} blib/lib/FlashVideo/RTMPDownloader.pm
BEGIN { $INC{'FlashVideo/Search.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/Search.pm
{
package FlashVideo::Search;

use strict;
use Carp;
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; }

my @sites_with_search = ('4oD', 'GoogleVideoSearch');

sub search {
  my ($class, $search, $max_per_site, $max_results) = @_;

  my @search_sites = map { FlashVideo::URLFinder::_load($_) } @sites_with_search;

  if ($search =~ /^(\w+) \w+/) {
    my $possible_site = ucfirst lc $1;

    debug "Checking to see if '$possible_site' in '$search' is a search-supported site.";

    my $possible_package = FlashVideo::URLFinder::_load($possible_site);

    if ($possible_package->can("search")) {
      debug "Search for '$search' will only search $possible_site.";

      $search =~ s/^\w+ //;

      return search_site($possible_package, $search, "site", $max_results);
    }
  }

  my @plugins = App::get_flash_videos::get_installed_plugins();

  foreach my $plugin (@plugins) {
    $plugin =~ s/\.pm$//;

    my $plugin_package = FlashVideo::URLFinder::_load($plugin);

    if ($plugin_package->can("search")) {
      debug "Plugin '$plugin' has a search method.";

      unshift @search_sites, $plugin_package;
    }
    else {
      debug "Plugin '$plugin' doesn't have a search method.";
    }
  }

  my @results = map { search_site($_, $search, "all", $max_per_site) } @search_sites;

  trim_resultset(\@results, $max_results);

  return @results;
}

sub search_site {
  my($search_site, $search, $type, $max) = @_;

  debug "Searching '$search_site' for '$search'.";

  if (my @site_results = eval { $search_site->search($search, $type) }) {
    debug "Found " . @site_results . " results for $search.";

    trim_resultset(\@site_results, $max);
    return @site_results;
  }
  elsif($@) {
    info "Searching '$search_site' failed with: $@";
  }
  else {
    debug "No results found for '$search'.";
  }

  return ();
}

sub trim_resultset {
  my ($results, $max) = @_;

  croak "Must be supplied a reference to resultset" unless ref($results) eq 'ARRAY';
  croak "No max supplied" unless $max;

  if (@$results > $max) {
    debug "Found " . @$results . " results, trimming to $max.";
    splice @$results, $max;
  }
}

1;
}
##} blib/lib/FlashVideo/Search.pm
BEGIN { $INC{'FlashVideo/VideoPreferences.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
BEGIN { $INC{'FlashVideo/VideoPreferences/Quality.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/VideoPreferences/Quality.pm
{
package FlashVideo::VideoPreferences::Quality;

use strict;

my %format_map = (
  "240p"  => [320,  240,  "low"],
  "240w"  => [427,  240,  "low"],
  "480p"  => [640,  480,  "medium"],
  "480w"  => [854,  480,  "medium"],
  "576p"  => [720,  576,  "medium"],
  "720p"  => [1280, 720,  "high"],
  "1080p" => [1920, 1080, "high"],
);

sub new {
  my($class, $quality) = @_;

  return bless \$quality, $class;
}

sub name {
  my($self) = @_;
  return $$self;
}

sub choose {
  my($self, @available) = @_;

  

  my $max_preferred_res = $self->quality_to_resolution($self->name);
  my $max_preferred_size = $max_preferred_res->[0] * $max_preferred_res->[1];

  my @sorted = 
    sort { $a->[0] <=> $b->[0] }
    map { my $r = $_->{resolution}; $r = $r->[0] * $r->[1]; [$r, $_] } @available;

  if(my @at_or_under_preferred = grep { $_->[0] <= $max_preferred_size } @sorted) {
    return $at_or_under_preferred[-1]->[1];
  } else {
    return $sorted[0]->[1];
  }
}

sub format_to_resolution {
  my($self, $name) = @_;
  $name .= "p" if $name !~ /[a-z]$/i;

  if(my $resolution = $format_map{lc $name}) {
    return $resolution;
  } elsif(my $num = ($name =~ /(\d+)/)[0]) {
    my $resolution = [($num) x 2];
    return [@$resolution, $self->resolution_to_quality($resolution)];
  }

  die "Unknown format '$name'";
}

sub quality_to_resolution {
  my($self, $quality) = @_;

  if($quality =~ /^(\d+)x(\d+)$/) {
    my $resolution = [$1, $2];
    return [@$resolution, $self->resolution_to_quality($resolution)];

  } elsif(my $resolution = eval { $self->format_to_resolution($quality) }) {
    return $resolution;

  } else {
    for my $r(sort { ($b->[0]*$b->[1]) <=> ($a->[0]*$a->[1]) }
        values %format_map) {
      if($r->[2] eq lc $quality) {
        return $r;
      }
    }
  }

  die "Unknown quality '$quality'";
}

sub resolution_to_quality {
  my($self, $resolution) = @_;

  my $quality = "high";

  for my $r(sort { ($b->[0]*$b->[1]) <=> ($a->[0]*$a->[1]) }
      values %format_map) {
    $quality = $r->[2] if $r->[0] >= $resolution->[0];
  }

  return $quality;
}

1;
}
##} blib/lib/FlashVideo/VideoPreferences/Quality.pm
BEGIN { $INC{'FlashVideo/VideoPreferences/Account.pm'}++; }
# Part of get-flash-videos. See get_flash_videos for copyright.
##{ blib/lib/FlashVideo/VideoPreferences/Account.pm
{
package FlashVideo::VideoPreferences::Account;

use strict;

sub new {
  my($class, $site, $prompt) = @_;

  require Net::Netrc; # Core since 5.8

  my $record = Net::Netrc->lookup($site);
  my($user, $pass) = $record ? $record->lpa : ();


  if(!$user) {
    print $prompt;

    print "Username: ";
    chomp($user = <STDIN>);
  }

  if(!$pass) {
    print "Ok, need your password";
    if(eval { require Term::ReadKey }) {
      print ": ";
      Term::ReadKey::ReadMode(2);
      chomp($pass = <STDIN>);
      Term::ReadKey::ReadMode(0);
      print "\n";
    } else {
      print " (will be displayed): ";
      chomp($pass = <STDIN>);
    }
  }
  
  return bless {
    username => $user,
    password => $pass,
  }, $class;
}

sub username {
  my($self) = @_;
  return $self->{username};
}

sub password {
  my($self) = @_;
  return $self->{password};
}

1;
}
##} blib/lib/FlashVideo/VideoPreferences/Account.pm
##{ blib/lib/FlashVideo/VideoPreferences.pm
{
package FlashVideo::VideoPreferences;

use strict;
BEGIN { FlashVideo::VideoPreferences::Quality->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::VideoPreferences::Account->import(); } # (added by utils/combine-perl.pl)

sub new {
  my($class, %opt) = @_;

  return bless {
    quality => $opt{quality} || "high",
    subtitles => $opt{subtitles} || 0,
  }, $class;
}

sub quality {
  my($self) = @_;

  return FlashVideo::VideoPreferences::Quality->new($self->{quality});
}

sub subtitles {
  my($self) = @_;

  return $self->{subtitles};
}

sub account {
  my($self, $site, $prompt) = @_;

  return FlashVideo::VideoPreferences::Account->new($site, $prompt);
}

1;
}
##} blib/lib/FlashVideo/VideoPreferences.pm
##{ bin/get_flash_videos
{
package main;
$::SCRIPT_NAME = "get_flash_videos";
$::INSTALL_TYPE = "cpan-manual";

package App::get_flash_videos;
use strict;
use Encode ();
use File::Basename qw(basename);
use File::stat;
use Getopt::Long;
use Text::Wrap;

BEGIN {
  if(!$::SCRIPT_NAME) {
    require Cwd;
    require File::Spec;
    my($vol, $dir) = (File::Spec->splitpath(Cwd::realpath($0)))[0, 1];
    unshift @INC, File::Spec->catpath($vol, File::Spec->catdir($dir, "lib"));
  }
}

BEGIN { FlashVideo::URLFinder->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Mechanize->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Downloader->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::RTMPDownloader->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Search->import(); } # (added by utils/combine-perl.pl)
BEGIN { FlashVideo::Utils->import(); } # (added by utils/combine-perl.pl)
BEGIN { no strict 'refs'; *debug = \&FlashVideo::Utils::debug; *info = \&FlashVideo::Utils::info; *error = \&FlashVideo::Utils::error; *get_user_config_dir = \&FlashVideo::Utils::get_user_config_dir; *get_win_codepage = \&FlashVideo::Utils::get_win_codepage; *is_program_on_path = \&FlashVideo::Utils::is_program_on_path; *get_terminal_width = \&FlashVideo::Utils::get_terminal_width; }
BEGIN { FlashVideo::VideoPreferences->import(); } # (added by utils/combine-perl.pl)

unshift @INC, \&plugin_loader;

our $VERSION = "1.25";

our %opt;
BEGIN {
  my $player = "mplayer -really-quiet";
  $player = "VLC" if $^O =~ /MSWin/i;
  $player = "open" if $^O =~ /darwin/ && !is_program_on_path("mplayer");

  if(is_program_on_path("xdg-open") && !is_program_on_path("mplayer")) {
    $player = "xdg-open";
  } elsif(is_program_on_path("gnome-open") && !is_program_on_path("mplayer")) {
    $player = "gnome-open";
  } elsif(is_program_on_path("kde-open") && !is_program_on_path("mplayer")) {
    $player = "kde-open";
  }

  %opt = (
    yes => 0,
    filename => '',
    version => 0,
    update => 0,
    play => 0,
    player => $player,
    proxy => '',
    debug => 0,
    quiet => 0,
    quality => "high",
    subtitles => 0,
    info => 0
  );
}

use constant VER_INFO => <<EOF;
get_flash_videos version $VERSION (http://code.google.com/p/get-flash-videos/)
EOF

use constant USAGE => VER_INFO . <<EOF;

Usage: $0 [OPTION]... URL...
       $0 [OPTION]... search string

Downloads videos from the web pages given in URL or searches Google Video
Search for 'search string'. If the URL contains characters such as '&' you
will need to quote it.

Options:
     --add-plugin Add a plugin from a URL.
  -d --debug      Print extra debugging information.
  -f --filename   Filename to save the video as.
  -p --play       Start playing the video once enough has been downloaded.
     --player     Player to use for the video (default: $opt{player}).
     --proxy      Proxy to use, use host:port for SOCKS, or URL for HTTP.
     --subtitles  Download subtitles where available.
  -q --quiet      Be quiet (only print errors).
  -r --quality    Quality to download at (high|medium|low, or site specific).
  -u --update     Update to latest version.
  -v --version    Print version.
  -y --yes        Say yes to any questions (don't prompt for any information).
  -i --info       Print out info about video instead of downloading.

EOF

use constant REQ_INFO => <<EOF;

A required Perl module for downloading this video is not installed.
EOF

use constant FRIENDLY_FAILURE => <<EOF;

Couldn't extract Flash movie URL. This site may need specific support adding,
or fixing.

Please confirm the site is using Flash video and if you have Flash available
check that the URL really works(!).

Check for updates by running: $0 --update

If the latest version does not support this please open a bug (or
contribute a patch!) at http://code.google.com/p/get-flash-videos/
make sure you include the output with --debug enabled.
EOF

read_conf();

GetOptions(
  "yes|y"        => \$opt{yes},
  "filename|f=s" => \$opt{filename},
  "version|v"    => \$opt{version},
  "update|u"     => \$opt{update},
  "help|h"       => \$opt{help},
  "play|p"       => \$opt{play},
  "player=s"     => \$opt{player},
  "proxy=s"      => \$opt{proxy},
  "debug|d"      => \$opt{debug},
  "quiet|q"      => \$opt{quiet},
  "add-plugin=s" => \$opt{add_plugin},
  "quality|r=s"  => \$opt{quality},
  "subtitles"    => \$opt{subtitles},
  "info|i"       => \$opt{info},
) or die "Try $0 --help for more information.\n";

if($opt{version}) {
  die VER_INFO;
} elsif($opt{update}) {
  exit update();
} elsif($opt{help}) {
  die USAGE;
} elsif($opt{add_plugin}) {
  exit add_plugin($opt{add_plugin});
}

if ($opt{debug}) {
  if(my @plugins = get_installed_plugins()) {
    debug @plugins . " plugin" . (@plugins != 1 && "s") . " installed:";
    debug "- $_" for @plugins;
  } else {
    debug "No plugins installed";
  }
}

if($^O =~ /MSWin/i) {
  $opt{filename} = Encode::decode(get_win_codepage(), $opt{filename});
  binmode STDERR, ":encoding(" . get_win_codepage() . ")";
  binmode STDOUT, ":encoding(" . get_win_codepage() . ")";
} else {
  $opt{filename} = Encode::decode("utf-8", $opt{filename});
  binmode STDERR, '<:encoding(UTF-8)';
  binmode STDOUT, '<:encoding(UTF-8)';
}

my (@urls) = @ARGV;
@urls > 0 or die USAGE;

my $search;
if ( ((@urls == 1) and $urls[0] !~ m'\.') or
     ( (@urls > 1) and ! grep /^http:\/\/|^[\w\-]+\.[\w\-]+/, @urls)) {
  $search = join ' ', @urls;
}

my @download_urls;

if ($search) {
  if (my @results = FlashVideo::Search->search($search, 10, 20)) {
    if ($opt{yes} or @results == 1) {
      my $message = (@results == 1) ?
        "Downloading only match for '$search': '$results[0]->{name}'" :
        "Downloading first match for '$search': '$results[0]->{name}'" ;
      info $message;

      push @download_urls, $results[0]->{url};
    }
    else {
      print "Search for '$search' found these results:\n";

      my $columns = get_terminal_width() - 5;
      local $Text::Wrap::columns = $columns;

      my $count = 1;
      for my $result(@results) {
        printf "[%2d] %s\n", $count, $result->{name};

        if ($result->{description}) {
          print wrap("     ", "     ",
                     substr($result->{description}, 0, $columns * 2)), "\n";
        }

        $count++;
      }

      print "Enter the number(s) or range (e.g. 1-3) of the videos to download " .
            "(separate multiple with comma or space): ";
      chomp(my $choice = <STDIN>);
      $choice ||= 1;

      for(split /[ ,]+/, $choice) {
        if (/-/) {
          my ($lower, $upper) = split /-/, $choice;
          if ($upper > $lower and $upper > 0) {
            push @download_urls, map { $results[$_]->{url} } $lower - 1 .. $upper - 1;
            next;
          }
          else {
            print STDERR "Search range '$_' is invalid.\n";
            exit 1;
          }
        }

        $_--;

        if (!$results[$_]) {
          print STDERR "'$_' is an invalid choice.\n";
          exit 1;
        }

        push @download_urls, $results[$_]->{url};
      }
    }
  }
  else {
    print STDERR "No results found for '$search'.\n";
    exit 1;
  }
}
else {
  @download_urls = @urls;
}

my $download_count = 0;

my $prefs = FlashVideo::VideoPreferences->new(%opt);

foreach my $url (@download_urls) {
  if (download($url, $prefs, @download_urls - $download_count)) {
    $download_count++;
  }
}

if($download_count == 0) {
  info "Couldn't download any videos.";
  exit 1;
} elsif($download_count != @download_urls) {
  info "Problems downloading some videos.";
  exit 2;
}

exit 0;

sub download {
  my($url, $prefs, $remaining) = @_;

  $url = "http://$url" if $url !~ m!^\w+:!;

  my $browser = FlashVideo::Mechanize->new;

  my($package, $possible_url) = FlashVideo::URLFinder->find_package($url, $browser);

  if($package->can("pre_find")) {
    $package->pre_find($browser);
  }

  info "Downloading $url";
  $browser->get($url);

  if (!$browser->success and !$browser->response->is_redirect) {
    if ($opt{proxy}) {
      if ($browser->response->header('Client-Warning') eq 'Internal response') {
        info "Couldn't download $url - might not be able to contact " .
             "your proxy server ($opt{proxy})";
      }
    }

    error "Couldn't download '$url': " . $browser->response->status_line;
  }

  my($actual_url, @suggested_fnames) = eval {
    $package->find_video($browser, $possible_url, $prefs);
  };

  if(!$actual_url) {
    if($@ =~ /^Must have | requires /) {
      my $error = "$@";
      $error =~ s/at $0.*//;
      print STDERR "$error" . REQ_INFO;
      return 0;
    } else {
      print STDERR "Error: $@" . FRIENDLY_FAILURE;
      return 0;
    }
  }

  my $suggested_filename = $suggested_fnames[-1];

  if (!$opt{play}) {
    if (!$opt{yes} && @suggested_fnames > 1) {
      print "There are different suggested filenames, please choose:\n";
      my $count;
      foreach my $filename (@suggested_fnames) {
        $count++;
        print "$count - $filename\n";
      }

      print "\nWhich filename would you like to use?: ";
      chomp(my $chosen_fname = <STDIN>);

      $suggested_filename = $suggested_fnames[$chosen_fname - 1] ||
        $suggested_fnames[-1];
    }
  }

  my $save_as = $opt{filename} || $suggested_filename;

  if($opt{info}) {
    print "Filename: " . ($save_as || $actual_url->{flv}) . "\n";
    $_ = $suggested_filename || $actual_url->{flv};
    s/_/ /g;
    s/\.[^\.]*$//;
    print "Title: " . $_ . "\n";
    print "Content-Location: ";
    if(ref($actual_url) eq 'HASH') {
      print $actual_url->{rtmp} . "\n";
    } else {
      print $actual_url . "\n";
      $browser->head($actual_url);
      if($browser->response->header('Content-Length')) {
        print "Content-Length: " . $browser->response->header('Content-Length') . "\n";
      }
    }
    exit;
  }

  my $action = $opt{play} ? "play" : "download";

  for my $data((ref($actual_url) eq 'ARRAY' ? @$actual_url : $actual_url)) {
    my $downloader;
    my $file = $save_as;

    if(ref $data eq 'HASH') {
      $downloader = FlashVideo::RTMPDownloader->new;
      $file ||= $data->{flv};
    } else {
      $downloader = FlashVideo::Downloader->new;
    }

    if (ref $data eq 'ARRAY') {
      my ($url, $part_number, $part_count, $part_size) = @$data;
      $data = $url;
      if (defined $part_number && defined $part_count) {
        my $part_suffix = sprintf('.part%02d_of_%02d', $part_number, $part_count);
        substr $file, rindex($file, '.'), 0, $part_suffix
          if $part_count > 1;
      }

      if (defined $part_size && -f $file && -s $file == $part_size) {
        info "Already downloaded $file ($part_size bytes)";
        next;
      }
    }

    my $size = $downloader->$action($data, $file, $browser) || return 0;

    info "\n" . ($remaining == 1 ? "Done. " : "")
      . "Saved $size bytes to $downloader->{printable_filename}";
  }

  return 1;
}

sub read_conf {
  for my $file("/etc/get_flash_videosrc", "$ENV{HOME}/.get_flash_videosrc") {
    open my $fh, "<", $file or next;

    while(<$fh>) {
      s/\r?\n//;
      next if /^\s*(#|$)/;

      my($n, $v) = split /\s*=\s*/;
      $v = 1 unless defined $v;
      $opt{$n} = $v;
    }
  }
}

sub add_plugin {
  my($plugin_url) = @_;

  my $uri = URI->new($plugin_url);

  unless(-d get_plugin_dir()) {
    require File::Path;
    File::Path::mkpath(get_plugin_dir())
      or die "Unable to create plugin dir: $!";
  }

  my $filename = get_plugin_dir() . "/" . basename($uri->path);

  if($filename !~ /\.pm$/) {
    die "Plugins must have a file extension of '.pm'\n";
  }

  if(!$uri->scheme) {
    require File::Copy;
    File::Copy::copy($plugin_url => $filename)
      || die "Unable to copy plugin to '$filename': $!\n";

    info "Plugin installed.";
    return 0;
  } else {
    my $browser = FlashVideo::Mechanize->new;
    return !install_plugin($browser, $plugin_url, $filename);
  }
}

sub update {
  my %update_types = (
    'cpan-cpan' => [1, "cpan " . __PACKAGE__],
    'cpan-cpanp' => [1, "cpanp i " . __PACKAGE__],
    'cpan-cpanm' => [1, "cpanm " . __PACKAGE__],
    'cpan-manual' => [0, "Manual install"],
  );

  if($::SCRIPT_NAME) {
    my $browser = FlashVideo::Mechanize->new;

    $browser->get("http://get-flash-videos.googlecode.com/svn/wiki/Version.wiki");

    if(!$browser->response->is_success) {
      die "Unable to retrieve version data: " . $browser->response->status_line . "\n";
    }

    my $version = ($browser->content =~ /version: (\S+)/)[0];
    my $base = ($browser->content =~ /from: (\S+)/)[0];
    my $info = ($browser->content =~ /info: (\S+)/)[0];
    my $url = $base . $::SCRIPT_NAME . "-" . $version;

    die "Unable to parse version data" unless $version and $base;

    my @v = split /\./, $version;
    my @V = split /\./, $VERSION;

    my $newer = 0;
    my $i = 0;
    for(@v) {
      $newer = 1 if !defined $V[$i] || $_ > $V[$i];
      last if $V[$i] > $v[$i];
      $i++;
    }

    if($newer) {
      info "Newer version ($version) available";
      debug "(Install type: $::INSTALL_TYPE)";

      if($::INSTALL_TYPE =~ /^cpan-/) {

        my $update_method = $update_types{$::INSTALL_TYPE};
        if($update_method->[0]) {
          info "This was installed via CPAN, you may upgrade by running:";
          info $update_method->[1];

          my $run_cpan = $opt{yes} || do {
            info "Shall I run that for you? (Y/n)";
            <STDIN> =~ /(?:^\s*$|y)/i;
          };

          if($run_cpan) {
            system $update_method->[1];
          }
        } else {
          info "Please visit http://code.google.com/p/get-flash-videos to upgrade";
        }
      } else {
        update_script($browser, $url, $info);
      }
    } else {
      print STDERR "You already have the latest version.\n";
    }
  } else {
    info "Development version, not updated";
  }

  update_plugins();

  return 0; # exit code
}

sub update_script {
  my($browser, $url, $info) = @_;

  info "Downloading new version...";
  die "Cannot update -- unable to write to $0\n" unless -w $0;

  my $new_file = $0 . ".new";
  $browser->mirror($url, $new_file);

  if($browser->response->is_success && -f $new_file) {
    rename $0, "$0.old" or die "Unable to rename $0 to $0.old: $!";
    rename $new_file, $0 or die "Unable to rename $new_file to $0: $!";
    chmod 0755, $0;

    info "New version installed as $0";
    info "(previous version backed up to $0.old).";
    info $info;
  } else {
    die "Download failed: " . $browser->response->status_line;
  }
}

sub update_plugins {
  my $browser = FlashVideo::Mechanize->new;

  foreach my $plugin(get_installed_plugins()) {
    debug "Seeing if there is an update for $plugin..";

    my $file = get_plugin_dir() . "/$plugin";
    require $file;

    my $package = "FlashVideo::Site::" . ($plugin =~ /(.*)\.pm$/)[0];

    if($package->can("update")) {
      $package->update();
    } else {
      no strict 'refs';

      my $downloaded  = 0;
      my $newer_found = 0;

      foreach my $update_url (@{ "$package\::update_urls" }) {
        $browser->head($update_url);

        if (!$browser->response->is_success) {
          debug "Couldn't retrieve $update_url for $plugin: " . $browser->response->status_line;
          next;
        }

        my $file_mtime = stat($file)->mtime;

        my $remote_plugin_mtime = $browser->response->last_modified;

        if ($remote_plugin_mtime > $file_mtime) {
          info "Newer version of plugin $plugin found at $update_url, trying to download and install";
          $newer_found = 1;

          if ($downloaded = install_plugin($browser, $update_url, $file)) {
            last;
          }
        }
        else {
          debug "Plugin $plugin is already the lastest version.";
          debug "(Remote: " . $browser->response->header("Last-Modified")
            . "; Local: " . gmtime($file_mtime) . " GMT)";
        }
      }

      if ($newer_found and !$downloaded) {
        die "Couldn't install $plugin plugin";
      }
    }
  }
}

sub install_plugin {
  my ($browser, $url, $file) = @_;

  my $plugin_exists = -f $file;

  my $new_file = $plugin_exists ? "$file.new" : $file;

  $browser->mirror($url, $new_file);

  if ($browser->response->is_success && -f $new_file) {
    my $short_name = basename($file);

    if ($plugin_exists) {
      rename $file, "$file.old" or die "Unable to rename $file to $file.old: $!";
      rename $new_file, $file   or die "Unable to rename $new_file to $file: $!";

      info "New version of $short_name installed as $file";
      info "(previous version backed up to $file.old).";
    }
    else {
      info "New plugin $short_name installed as $file";
    }

    return 1;
  }
  else {
    warn "Download failed: " . $browser->response->status_line;
  }

  return 0;
}

sub plugin_loader {
  my (undef, $module) = @_;

  if ($module =~ m'^FlashVideo/Site/(.*)') {
    my $plugin_name = $1;

    my $plugin_dir = get_plugin_dir();

    debug "Trying to open plugin $plugin_dir/$plugin_name";

    if (open my $plugin_fh, '<', "$plugin_dir/$plugin_name") {
      return $plugin_fh; # Perl then reads the plugin from the FH
    }
  }

  return;
}

sub get_installed_plugins {
  my $plugin_dir = get_plugin_dir();

  my @plugins;
  if (opendir my $plugin_dir_dh, $plugin_dir) {
    @plugins = grep /\.pm$/i,
               readdir $plugin_dir_dh;
    closedir $plugin_dir_dh;
  }

  return @plugins;
}

sub get_plugin_dir {
  return get_user_config_dir() . "/plugins";
}
}
##} bin/get_flash_videos
